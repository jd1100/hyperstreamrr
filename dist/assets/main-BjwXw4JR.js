(function(){const a=document.createElement("link").relList;if(a&&a.supports&&a.supports("modulepreload"))return;for(const g of document.querySelectorAll('link[rel="modulepreload"]'))l(g);new MutationObserver(g=>{for(const y of g)if(y.type==="childList")for(const h of y.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&l(h)}).observe(document,{childList:!0,subtree:!0});function p(g){const y={};return g.integrity&&(y.integrity=g.integrity),g.referrerPolicy&&(y.referrerPolicy=g.referrerPolicy),g.crossOrigin==="use-credentials"?y.credentials="include":g.crossOrigin==="anonymous"?y.credentials="omit":y.credentials="same-origin",y}function l(g){if(g.ep)return;g.ep=!0;const y=p(g);fetch(g.href,y)}})();function ti(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Rv(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var a=n.default;if(typeof a=="function"){var p=function l(){var g=!1;try{g=this instanceof l}catch{}return g?Reflect.construct(a,arguments,this.constructor):a.apply(this,arguments)};p.prototype=a.prototype}else p={};return Object.defineProperty(p,"__esModule",{value:!0}),Object.keys(n).forEach(function(l){var g=Object.getOwnPropertyDescriptor(n,l);Object.defineProperty(p,l,g.get?g:{enumerable:!0,get:function(){return n[l]}})}),p}var Ia={exports:{}},dh,v_;function x1(){if(v_)return dh;v_=1;function n(l){return l.length}function a(l){const g=l.byteLength;let y="";for(let h=0;h<g;h++)y+=String.fromCharCode(l[h]);return y}function p(l,g,y=0,h=n(g)){const o=Math.min(h,l.byteLength-y);for(let c=0;c<o;c++)l[y+c]=g.charCodeAt(c);return o}return dh={byteLength:n,toString:a,write:p},dh}var fh,k_;function E1(){if(k_)return fh;k_=1;const n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=new Uint8Array(256);for(let y=0;y<n.length;y++)a[n.charCodeAt(y)]=y;a[45]=62,a[95]=63;function p(y){let h=y.length;return y.charCodeAt(h-1)===61&&h--,h>1&&y.charCodeAt(h-1)===61&&h--,h*3>>>2}function l(y){const h=y.byteLength;let o="";for(let c=0;c<h;c+=3)o+=n[y[c]>>2]+n[(y[c]&3)<<4|y[c+1]>>4]+n[(y[c+1]&15)<<2|y[c+2]>>6]+n[y[c+2]&63];return h%3===2?o=o.substring(0,o.length-1)+"=":h%3===1&&(o=o.substring(0,o.length-2)+"=="),o}function g(y,h,o=0,c=p(h)){const s=Math.min(c,y.byteLength-o);for(let u=0,f=0;f<s;u+=4){const m=a[h.charCodeAt(u)],E=a[h.charCodeAt(u+1)],b=a[h.charCodeAt(u+2)],_=a[h.charCodeAt(u+3)];y[f++]=m<<2|E>>4,y[f++]=(E&15)<<4|b>>2,y[f++]=(b&3)<<6|_&63}return s}return fh={byteLength:p,toString:l,write:g},fh}var gh,S_;function A1(){if(S_)return gh;S_=1;function n(g){return g.length>>>1}function a(g){const y=g.byteLength;g=new DataView(g.buffer,g.byteOffset,y);let h="",o=0;for(let c=y-y%4;o<c;o+=4)h+=g.getUint32(o).toString(16).padStart(8,"0");for(;o<y;o++)h+=g.getUint8(o).toString(16).padStart(2,"0");return h}function p(g,y,h=0,o=n(y)){const c=Math.min(o,g.byteLength-h);for(let s=0;s<c;s++){const u=l(y.charCodeAt(s*2)),f=l(y.charCodeAt(s*2+1));if(u===void 0||f===void 0)return g.subarray(0,s);g[h+s]=u<<4|f}return c}gh={byteLength:n,toString:a,write:p};function l(g){if(g>=48&&g<=57)return g-48;if(g>=65&&g<=70)return g-65+10;if(g>=97&&g<=102)return g-97+10}return gh}var ph,x_;function R1(){if(x_)return ph;x_=1;function n(l){let g=0;for(let y=0,h=l.length;y<h;y++){const o=l.charCodeAt(y);if(o>=55296&&o<=56319&&y+1<h){const c=l.charCodeAt(y+1);if(c>=56320&&c<=57343){g+=4,y++;continue}}o<=127?g+=1:o<=2047?g+=2:g+=3}return g}let a;if(typeof TextDecoder<"u"){const l=new TextDecoder;a=function(y){return l.decode(y)}}else a=function(g){const y=g.byteLength;let h="",o=0;for(;o<y;){let c=g[o];if(c<=127){h+=String.fromCharCode(c),o++;continue}let s=0,u=0;if(c<=223?(s=1,u=c&31):c<=239?(s=2,u=c&15):c<=244&&(s=3,u=c&7),y-o-s>0){let f=0;for(;f<s;)c=g[o+f+1],u=u<<6|c&63,f+=1}else u=65533,s=y-o;h+=String.fromCodePoint(u),o+=s+1}return h};let p;if(typeof TextEncoder<"u"){const l=new TextEncoder;p=function(y,h,o=0,c=n(h)){const s=Math.min(c,y.byteLength-o);return l.encodeInto(h,y.subarray(o,o+s)),s}}else p=function(g,y,h=0,o=n(y)){const c=Math.min(o,g.byteLength-h);g=g.subarray(h,h+c);let s=0,u=0;for(;s<y.length;){const f=y.codePointAt(s);if(f<=127){g[u++]=f,s++;continue}let m=0,E=0;for(f<=2047?(m=6,E=192):f<=65535?(m=12,E=224):f<=2097151&&(m=18,E=240),g[u++]=E|f>>m,m-=6;m>=0;)g[u++]=128|f>>m&63,m-=6;s+=f>=65536?2:1}return c};return ph={byteLength:n,toString:a,write:p},ph}var yh,E_;function L1(){if(E_)return yh;E_=1;function n(l){return l.length*2}function a(l){const g=l.byteLength;let y="";for(let h=0;h<g-1;h+=2)y+=String.fromCharCode(l[h]+l[h+1]*256);return y}function p(l,g,y=0,h=n(g)){const o=Math.min(h,l.byteLength-y);let c=o;for(let s=0;s<g.length&&!((c-=2)<0);++s){const u=g.charCodeAt(s),f=u>>8,m=u%256;l[y+s*2]=m,l[y+s*2+1]=f}return o}return yh={byteLength:n,toString:a,write:p},yh}var A_;function Ue(){return A_||(A_=1,function(n,a){const p=x1(),l=E1(),g=A1(),y=R1(),h=L1(),o=new Uint8Array(Uint16Array.of(255).buffer)[0]===255;function c(I){switch(I){case"ascii":return p;case"base64":return l;case"hex":return g;case"utf8":case"utf-8":case void 0:case null:return y;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return h;default:throw new Error(`Unknown encoding: ${I}`)}}function s(I){return I instanceof Uint8Array}function u(I){try{return c(I),!0}catch{return!1}}function f(I,L,V){const te=new Uint8Array(I);return L!==void 0&&a.fill(te,L,0,te.byteLength,V),te}function m(I){return new Uint8Array(I)}function E(I){return new Uint8Array(I)}function b(I,L){return c(L).byteLength(I)}function _(I,L){if(I===L)return 0;const V=Math.min(I.byteLength,L.byteLength);I=new DataView(I.buffer,I.byteOffset,I.byteLength),L=new DataView(L.buffer,L.byteOffset,L.byteLength);let te=0;for(let de=V-V%4;te<de;te+=4){const C=I.getUint32(te,o),ee=L.getUint32(te,o);if(C!==ee)break}for(;te<V;te++){const de=I.getUint8(te),C=L.getUint8(te);if(de<C)return-1;if(de>C)return 1}return I.byteLength>L.byteLength?1:I.byteLength<L.byteLength?-1:0}function B(I,L){L===void 0&&(L=I.reduce((de,C)=>de+C.byteLength,0));const V=new Uint8Array(L);let te=0;for(const de of I){if(te+de.byteLength>V.byteLength){const C=de.subarray(0,V.byteLength-te);return V.set(C,te),V}V.set(de,te),te+=de.byteLength}return V}function M(I,L,V=0,te=0,de=I.byteLength){if(de>0&&de<te||de===te||I.byteLength===0||L.byteLength===0)return 0;if(V<0)throw new RangeError("targetStart is out of range");if(te<0||te>=I.byteLength)throw new RangeError("sourceStart is out of range");if(de<0)throw new RangeError("sourceEnd is out of range");V>=L.byteLength&&(V=L.byteLength),de>I.byteLength&&(de=I.byteLength),L.byteLength-V<de-te&&(de=L.length-V+te);const C=de-te;return I===L?L.copyWithin(V,te,de):L.set(I.subarray(te,de),V),C}function z(I,L){if(I===L)return!0;if(I.byteLength!==L.byteLength)return!1;const V=I.byteLength;I=new DataView(I.buffer,I.byteOffset,I.byteLength),L=new DataView(L.buffer,L.byteOffset,L.byteLength);let te=0;for(let de=V-V%4;te<de;te+=4)if(I.getUint32(te,o)!==L.getUint32(te,o))return!1;for(;te<V;te++)if(I.getUint8(te)!==L.getUint8(te))return!1;return!0}function j(I,L,V,te,de){if(typeof L=="string"?typeof V=="string"?(de=V,V=0,te=I.byteLength):typeof te=="string"&&(de=te,te=I.byteLength):typeof L=="number"?L=L&255:typeof L=="boolean"&&(L=+L),V<0||I.byteLength<V||I.byteLength<te)throw new RangeError("Out of range index");if(V===void 0&&(V=0),te===void 0&&(te=I.byteLength),te<=V)return I;if(L||(L=0),typeof L=="number")for(let C=V;C<te;++C)I[C]=L;else{L=s(L)?L:v(L,de);const C=L.byteLength;for(let ee=0;ee<te-V;++ee)I[ee+V]=L[ee%C]}return I}function v(I,L,V){return typeof I=="string"?w(I,L):Array.isArray(I)?R(I):ArrayBuffer.isView(I)?A(I):q(I,L,V)}function w(I,L){const V=c(L),te=new Uint8Array(V.byteLength(I));return V.write(te,I,0,te.byteLength),te}function R(I){const L=new Uint8Array(I.length);return L.set(I),L}function A(I){const L=new Uint8Array(I.byteLength);return L.set(I),L}function q(I,L,V){return new Uint8Array(I,L,V)}function U(I,L,V,te){return Q(I,L,V,te)!==-1}function T(I,L,V,te,de){if(I.byteLength===0)return-1;if(typeof V=="string"?(te=V,V=0):V===void 0?V=de?0:I.length-1:V<0&&(V+=I.byteLength),V>=I.byteLength){if(de)return-1;V=I.byteLength-1}else if(V<0)if(de)V=0;else return-1;if(typeof L=="string")L=v(L,te);else if(typeof L=="number")return L=L&255,de?I.indexOf(L,V):I.lastIndexOf(L,V);if(L.byteLength===0)return-1;if(de){let C=-1;for(let ee=V;ee<I.byteLength;ee++)if(I[ee]===L[C===-1?0:ee-C]){if(C===-1&&(C=ee),ee-C+1===L.byteLength)return C}else C!==-1&&(ee-=ee-C),C=-1}else{V+L.byteLength>I.byteLength&&(V=I.byteLength-L.byteLength);for(let C=V;C>=0;C--){let ee=!0;for(let fe=0;fe<L.byteLength;fe++)if(I[C+fe]!==L[fe]){ee=!1;break}if(ee)return C}}return-1}function Q(I,L,V,te){return T(I,L,V,te,!0)}function le(I,L,V,te){return T(I,L,V,te,!1)}function Y(I,L,V){const te=I[L];I[L]=I[V],I[V]=te}function oe(I){const L=I.byteLength;if(L%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let V=0;V<L;V+=2)Y(I,V,V+1);return I}function ue(I){const L=I.byteLength;if(L%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let V=0;V<L;V+=4)Y(I,V,V+3),Y(I,V+1,V+2);return I}function O(I){const L=I.byteLength;if(L%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let V=0;V<L;V+=8)Y(I,V,V+7),Y(I,V+1,V+6),Y(I,V+2,V+5),Y(I,V+3,V+4);return I}function P(I){return I}function Z(I,L,V=0,te=I.byteLength){const de=I.byteLength;return V>=de||te<=V?"":(V<0&&(V=0),te>de&&(te=de),(V!==0||te<de)&&(I=I.subarray(V,te)),c(L).toString(I))}function he(I,L,V,te,de){return V===void 0?de="utf8":te===void 0&&typeof V=="string"?(de=V,V=void 0):de===void 0&&typeof te=="string"&&(de=te,te=void 0),c(de).write(I,L,V,te)}function se(I,L,V){return V===void 0&&(V=0),new DataView(I.buffer,I.byteOffset,I.byteLength).setFloat64(V,L,!0),V+8}function G(I,L,V){return V===void 0&&(V=0),new DataView(I.buffer,I.byteOffset,I.byteLength).setFloat32(V,L,!0),V+4}function re(I,L,V){return V===void 0&&(V=0),new DataView(I.buffer,I.byteOffset,I.byteLength).setUint32(V,L,!0),V+4}function W(I,L,V){return V===void 0&&(V=0),new DataView(I.buffer,I.byteOffset,I.byteLength).setInt32(V,L,!0),V+4}function $(I,L){return L===void 0&&(L=0),new DataView(I.buffer,I.byteOffset,I.byteLength).getFloat64(L,!0)}function S(I,L){return L===void 0&&(L=0),new DataView(I.buffer,I.byteOffset,I.byteLength).getFloat32(L,!0)}function N(I,L){return L===void 0&&(L=0),new DataView(I.buffer,I.byteOffset,I.byteLength).getUint32(L,!0)}function D(I,L){return L===void 0&&(L=0),new DataView(I.buffer,I.byteOffset,I.byteLength).getInt32(L,!0)}function H(I,L,V){return V===void 0&&(V=0),new DataView(I.buffer,I.byteOffset,I.byteLength).setFloat64(V,L,!1),V+8}function _e(I,L,V){return V===void 0&&(V=0),new DataView(I.buffer,I.byteOffset,I.byteLength).setFloat32(V,L,!1),V+4}function ce(I,L,V){return V===void 0&&(V=0),new DataView(I.buffer,I.byteOffset,I.byteLength).setUint32(V,L,!1),V+4}function J(I,L,V){return V===void 0&&(V=0),new DataView(I.buffer,I.byteOffset,I.byteLength).setInt32(V,L,!1),V+4}function d(I,L){return L===void 0&&(L=0),new DataView(I.buffer,I.byteOffset,I.byteLength).getFloat64(L,!1)}function k(I,L){return L===void 0&&(L=0),new DataView(I.buffer,I.byteOffset,I.byteLength).getFloat32(L,!1)}function X(I,L){return L===void 0&&(L=0),new DataView(I.buffer,I.byteOffset,I.byteLength).getUint32(L,!1)}function ie(I,L){return L===void 0&&(L=0),new DataView(I.buffer,I.byteOffset,I.byteLength).getInt32(L,!1)}n.exports=a={isBuffer:s,isEncoding:u,alloc:f,allocUnsafe:m,allocUnsafeSlow:E,byteLength:b,compare:_,concat:B,copy:M,equals:z,fill:j,from:v,includes:U,indexOf:Q,lastIndexOf:le,swap16:oe,swap32:ue,swap64:O,toBuffer:P,toString:Z,write:he,writeDoubleLE:se,writeFloatLE:G,writeUInt32LE:re,writeInt32LE:W,readDoubleLE:$,readFloatLE:S,readUInt32LE:N,readInt32LE:D,writeDoubleBE:H,writeFloatBE:_e,writeUInt32BE:ce,writeInt32BE:J,readDoubleBE:d,readFloatBE:k,readUInt32BE:X,readInt32BE:ie}}(Ia,Ia.exports)),Ia.exports}const Kt={},T1=Object.freeze(Object.defineProperty({__proto__:null,default:Kt},Symbol.toStringTag,{value:"Module"})),nn=Rv(T1);var _h,R_;function Rn(){if(R_)return _h;R_=1;const n=nn;_h=class extends n{constructor(){super(),this.opening=null,this.closing=null,this.opened=!1,this.closed=!1}ready(){return this.opening!==null?this.opening:(this.opening=a(this),this.opening)}close(){return this.closing!==null?this.closing:(this.closing=p(this),this.closing)}async _open(){}async _close(){}};async function a(l){if(l.closing===null){try{await l._open()}catch(g){throw l.close(),g}l.opened=!0,l.emit("ready")}}async function p(l){try{l.opened===!1&&l.opening!==null&&await l.opening}catch{}(l.opened===!0||l.opening===null)&&await l._close(),l.closed=!0,l.emit("close")}return _h}var mh,L_;function Lv(){return L_||(L_=1,mh=function(a,p=null){return l.running=null,l;async function l(){if(l.running!==null)try{await l.running}catch{}if(l.running!==null)return l.running;l.running=a.call(p);try{return await l.running}finally{l.running=null}}}),mh}var wh={},Ka={},T_;function Tv(){if(T_)return Ka;T_=1;const n=Ka.LE=new Uint8Array(new Uint16Array([255]).buffer)[0]===255;return Ka.BE=!n,Ka}var za={exports:{}},D_;function D1(){return D_||(D_=1,function(n,a){const p=Ue(),{BE:l}=Tv();a=n.exports={preencode(s,u){s.end+=u.byteLength},encode(s,u){s.buffer.set(u,s.start),s.start+=u.byteLength},decode(s){const u=s.buffer.subarray(s.start,s.end);return s.start=s.end,u}};const g=a.buffer={preencode(s,u){u?h.preencode(s,u):s.end++},encode(s,u){u?h.encode(s,u):s.buffer[s.start++]=0},decode(s){const u=s.buffer.subarray(s.start);return u.byteLength===0?null:(s.start=s.end,u)}};a.binary={...g,preencode(s,u){typeof u=="string"?c.preencode(s,u):g.preencode(s,u)},encode(s,u){typeof u=="string"?c.encode(s,u):g.encode(s,u)}},a.arraybuffer={preencode(s,u){s.end+=u.byteLength},encode(s,u){const f=new Uint8Array(u);s.buffer.set(f,s.start),s.start+=u.byteLength},decode(s){const u=new ArrayBuffer(s.end-s.start);return new Uint8Array(u).set(s.buffer.subarray(s.start)),s.start=s.end,u}};function y(s,u){const f=s.BYTES_PER_ELEMENT;return{preencode(m,E){m.end+=E.byteLength},encode(m,E){const b=new Uint8Array(E.buffer,E.byteOffset,E.byteLength);l&&u&&u(b),m.buffer.set(b,m.start),m.start+=E.byteLength},decode(m){let E=m.buffer.subarray(m.start);return E.byteOffset%f!==0&&(E=new Uint8Array(E)),l&&u&&u(E),m.start=m.end,new s(E.buffer,E.byteOffset,E.byteLength/f)}}}const h=a.uint8array=y(Uint8Array);a.uint16array=y(Uint16Array,p.swap16),a.uint32array=y(Uint32Array,p.swap32),a.int8array=y(Int8Array),a.int16array=y(Int16Array,p.swap16),a.int32array=y(Int32Array,p.swap32),a.biguint64array=y(BigUint64Array,p.swap64),a.bigint64array=y(BigInt64Array,p.swap64),a.float32array=y(Float32Array,p.swap32),a.float64array=y(Float64Array,p.swap64);function o(s){return{preencode(u,f){u.end+=p.byteLength(f,s)},encode(u,f){u.start+=p.write(u.buffer,f,u.start,s)},decode(u){const f=p.toString(u.buffer,s,u.start);return u.start=u.end,f}}}const c=a.string=a.utf8=o("utf-8");a.ascii=o("ascii"),a.hex=o("hex"),a.base64=o("base64"),a.ucs2=a.utf16le=o("utf16le"),a.array=function(u){return{preencode(f,m){for(const E of m)u.preencode(f,E)},encode(f,m){for(const E of m)u.encode(f,E)},decode(f){const m=[];for(;f.start<f.end;)m.push(u.decode(f));return m}}},a.json={preencode(s,u){c.preencode(s,JSON.stringify(u))},encode(s,u){c.encode(s,JSON.stringify(u))},decode(s){return JSON.parse(c.decode(s))}},a.ndjson={preencode(s,u){c.preencode(s,JSON.stringify(u)+`
`)},encode(s,u){c.encode(s,JSON.stringify(u)+`
`)},decode(s){return JSON.parse(c.decode(s))}}}(za,za.exports)),za.exports}var bh,B_;function B1(){if(B_)return bh;B_=1,bh={preencode:n,encode:a,decode:p};function n(l,g){if(g<251)l.end++;else if(g<256)l.end+=2;else if(g<65536)l.end+=3;else if(g<16777216)l.end+=4;else if(g<4294967296)l.end+=5;else{l.end++;const y=Math.floor(Math.log(g)/Math.log(2))-32;n(l,y),l.end+=6}}function a(l,g){const h=g-251;if(g<251)l.buffer[l.start++]=g;else if(g<256)l.buffer[l.start++]=251,l.buffer[l.start++]=h;else if(g<65536)l.buffer[l.start++]=252,l.buffer[l.start++]=h>>8&255,l.buffer[l.start++]=h&255;else if(g<16777216)l.buffer[l.start++]=253,l.buffer[l.start++]=h>>16,l.buffer[l.start++]=h>>8&255,l.buffer[l.start++]=h&255;else if(g<4294967296)l.buffer[l.start++]=254,l.buffer[l.start++]=h>>24,l.buffer[l.start++]=h>>16&255,l.buffer[l.start++]=h>>8&255,l.buffer[l.start++]=h&255;else{const o=Math.floor(Math.log(h)/Math.log(2))-32;l.buffer[l.start++]=255,a(l,o);const c=h/Math.pow(2,o-11);for(let s=5;s>=0;s--)l.buffer[l.start++]=c/Math.pow(2,8*s)&255}}function p(l){if(l.end-l.start<1)throw new Error("Out of bounds");const y=l.buffer[l.start++];if(y<251)return y;if(l.end-l.start<y-251+1)throw new Error("Out of bounds.");if(y<252)return l.buffer[l.start++]+251;if(y<253)return(l.buffer[l.start++]<<8)+l.buffer[l.start++]+251;if(y<254)return(l.buffer[l.start++]<<16)+(l.buffer[l.start++]<<8)+l.buffer[l.start++]+251;if(y<255)return l.buffer[l.start++]*16777216+(l.buffer[l.start++]<<16)+(l.buffer[l.start++]<<8)+l.buffer[l.start++]+251;const h=p(l);if(l.end-l.start<6)throw new Error("Out of bounds");let o=0;for(let c=5;c>=0;c--)o+=l.buffer[l.start++]*Math.pow(2,8*c);return o*Math.pow(2,h-11)+251}return bh}var N_;function et(){return N_||(N_=1,function(n){const a=Ue(),{BE:p}=Tv();n.state=function(G=0,re=0,W=null){return{start:G,end:re,buffer:W,cache:null}};const l=n.raw=D1(),g=n.uint={preencode(G,re){G.end+=re<=252?1:re<=65535?3:re<=4294967295?5:9},encode(G,re){re<=252?y.encode(G,re):re<=65535?(G.buffer[G.start++]=253,h.encode(G,re)):re<=4294967295?(G.buffer[G.start++]=254,c.encode(G,re)):(G.buffer[G.start++]=255,m.encode(G,re))},decode(G){const re=y.decode(G);return re<=252?re:re===253?h.decode(G):re===254?c.decode(G):m.decode(G)}},y=n.uint8={preencode(G,re){G.end+=1},encode(G,re){se(re),G.buffer[G.start++]=re},decode(G){if(G.start>=G.end)throw new Error("Out of bounds");return G.buffer[G.start++]}},h=n.uint16={preencode(G,re){G.end+=2},encode(G,re){se(re),G.buffer[G.start++]=re,G.buffer[G.start++]=re>>>8},decode(G){if(G.end-G.start<2)throw new Error("Out of bounds");return G.buffer[G.start++]+G.buffer[G.start++]*256}},o=n.uint24={preencode(G,re){G.end+=3},encode(G,re){se(re),G.buffer[G.start++]=re,G.buffer[G.start++]=re>>>8,G.buffer[G.start++]=re>>>16},decode(G){if(G.end-G.start<3)throw new Error("Out of bounds");return G.buffer[G.start++]+G.buffer[G.start++]*256+G.buffer[G.start++]*65536}},c=n.uint32={preencode(G,re){G.end+=4},encode(G,re){se(re),G.buffer[G.start++]=re,G.buffer[G.start++]=re>>>8,G.buffer[G.start++]=re>>>16,G.buffer[G.start++]=re>>>24},decode(G){if(G.end-G.start<4)throw new Error("Out of bounds");return G.buffer[G.start++]+G.buffer[G.start++]*256+G.buffer[G.start++]*65536+G.buffer[G.start++]*16777216}},s=n.uint40={preencode(G,re){G.end+=5},encode(G,re){se(re);const W=Math.floor(re/256);y.encode(G,re),c.encode(G,W)},decode(G){if(G.end-G.start<5)throw new Error("Out of bounds");return y.decode(G)+256*c.decode(G)}},u=n.uint48={preencode(G,re){G.end+=6},encode(G,re){se(re);const W=Math.floor(re/65536);h.encode(G,re),c.encode(G,W)},decode(G){if(G.end-G.start<6)throw new Error("Out of bounds");return h.decode(G)+65536*c.decode(G)}},f=n.uint56={preencode(G,re){G.end+=7},encode(G,re){se(re);const W=Math.floor(re/16777216);o.encode(G,re),c.encode(G,W)},decode(G){if(G.end-G.start<7)throw new Error("Out of bounds");return o.decode(G)+16777216*c.decode(G)}},m=n.uint64={preencode(G,re){G.end+=8},encode(G,re){se(re);const W=Math.floor(re/4294967296);c.encode(G,re),c.encode(G,W)},decode(G){if(G.end-G.start<8)throw new Error("Out of bounds");return c.decode(G)+4294967296*c.decode(G)}},E=n.int=oe(g);n.int8=oe(y),n.int16=oe(h),n.int24=oe(o),n.int32=oe(c),n.int40=oe(s),n.int48=oe(u),n.int56=oe(f),n.int64=oe(m);const b=n.biguint64={preencode(G,re){G.end+=8},encode(G,re){new DataView(G.buffer.buffer,G.start+G.buffer.byteOffset,8).setBigUint64(0,re,!0),G.start+=8},decode(G){if(G.end-G.start<8)throw new Error("Out of bounds");const W=new DataView(G.buffer.buffer,G.start+G.buffer.byteOffset,8).getBigUint64(0,!0);return G.start+=8,W}};n.bigint64=P(b);const _=n.biguint={preencode(G,re){let W=0;for(let $=re;$;$=$>>64n)W++;g.preencode(G,W),G.end+=8*W},encode(G,re){let W=0;for(let S=re;S;S=S>>64n)W++;g.encode(G,W);const $=new DataView(G.buffer.buffer,G.start+G.buffer.byteOffset,8*W);for(let S=re,N=0;S;S=S>>64n,N+=8)$.setBigUint64(N,BigInt.asUintN(64,S),!0);G.start+=8*W},decode(G){const re=g.decode(G);if(G.end-G.start<8*re)throw new Error("Out of bounds");const W=new DataView(G.buffer.buffer,G.start+G.buffer.byteOffset,8*re);let $=0n;for(let S=re-1;S>=0;S--)$=($<<64n)+W.getBigUint64(S*8,!0);return G.start+=8*re,$}};n.bigint=P(_),n.lexint=B1(),n.float32={preencode(G,re){G.end+=4},encode(G,re){new DataView(G.buffer.buffer,G.start+G.buffer.byteOffset,4).setFloat32(0,re,!0),G.start+=4},decode(G){if(G.end-G.start<4)throw new Error("Out of bounds");const W=new DataView(G.buffer.buffer,G.start+G.buffer.byteOffset,4).getFloat32(0,!0);return G.start+=4,W}},n.float64={preencode(G,re){G.end+=8},encode(G,re){new DataView(G.buffer.buffer,G.start+G.buffer.byteOffset,8).setFloat64(0,re,!0),G.start+=8},decode(G){if(G.end-G.start<8)throw new Error("Out of bounds");const W=new DataView(G.buffer.buffer,G.start+G.buffer.byteOffset,8).getFloat64(0,!0);return G.start+=8,W}};const B=n.buffer={preencode(G,re){re?z.preencode(G,re):G.end++},encode(G,re){re?z.encode(G,re):G.buffer[G.start++]=0},decode(G){const re=g.decode(G);if(re===0)return null;if(G.end-G.start<re)throw new Error("Out of bounds");return G.buffer.subarray(G.start,G.start+=re)}};n.binary={...B,preencode(G,re){typeof re=="string"?v.preencode(G,re):B.preencode(G,re)},encode(G,re){typeof re=="string"?v.encode(G,re):B.encode(G,re)}},n.arraybuffer={preencode(G,re){g.preencode(G,re.byteLength),G.end+=re.byteLength},encode(G,re){g.encode(G,re.byteLength);const W=new Uint8Array(re);G.buffer.set(W,G.start),G.start+=re.byteLength},decode(G){const re=g.decode(G),W=new ArrayBuffer(re);return new Uint8Array(W).set(G.buffer.subarray(G.start,G.start+=re)),W}};function M(G,re){const W=G.BYTES_PER_ELEMENT;return{preencode($,S){g.preencode($,S.length),$.end+=S.byteLength},encode($,S){g.encode($,S.length);const N=new Uint8Array(S.buffer,S.byteOffset,S.byteLength);p&&re&&re(N),$.buffer.set(N,$.start),$.start+=S.byteLength},decode($){const S=g.decode($);let N=$.buffer.subarray($.start,$.start+=S*W);if(N.byteLength!==S*W)throw new Error("Out of bounds");return N.byteOffset%W!==0&&(N=new Uint8Array(N)),p&&re&&re(N),new G(N.buffer,N.byteOffset,N.byteLength/W)}}}const z=n.uint8array=M(Uint8Array);n.uint16array=M(Uint16Array,a.swap16),n.uint32array=M(Uint32Array,a.swap32),n.int8array=M(Int8Array),n.int16array=M(Int16Array,a.swap16),n.int32array=M(Int32Array,a.swap32),n.biguint64array=M(BigUint64Array,a.swap64),n.bigint64array=M(BigInt64Array,a.swap64),n.float32array=M(Float32Array,a.swap32),n.float64array=M(Float64Array,a.swap64);function j(G){return{preencode(re,W){const $=a.byteLength(W,G);g.preencode(re,$),re.end+=$},encode(re,W){const $=a.byteLength(W,G);g.encode(re,$),a.write(re.buffer,W,re.start,G),re.start+=$},decode(re){const W=g.decode(re);if(re.end-re.start<W)throw new Error("Out of bounds");return a.toString(re.buffer,G,re.start,re.start+=W)},fixed(re){return{preencode(W){W.end+=re},encode(W,$){a.write(W.buffer,$,W.start,re,G),W.start+=re},decode(W){if(W.end-W.start<re)throw new Error("Out of bounds");return a.toString(W.buffer,G,W.start,W.start+=re)}}}}}const v=n.string=n.utf8=j("utf-8");n.ascii=j("ascii"),n.hex=j("hex"),n.base64=j("base64"),n.ucs2=n.utf16le=j("utf16le"),n.bool={preencode(G,re){G.end++},encode(G,re){G.buffer[G.start++]=re?1:0},decode(G){if(G.start>=G.end)throw Error("Out of bounds");return G.buffer[G.start++]===1}};const w=n.fixed=function(re){return{preencode(W,$){if($.byteLength!==re)throw new Error("Incorrect buffer size");W.end+=re},encode(W,$){W.buffer.set($,W.start),W.start+=re},decode(W){if(W.end-W.start<re)throw new Error("Out of bounds");return W.buffer.subarray(W.start,W.start+=re)}}};n.fixed32=w(32),n.fixed64=w(64),n.array=function(re){return{preencode(W,$){g.preencode(W,$.length);for(let S=0;S<$.length;S++)re.preencode(W,$[S])},encode(W,$){g.encode(W,$.length);for(let S=0;S<$.length;S++)re.encode(W,$[S])},decode(W){const $=g.decode(W);if($>1048576)throw new Error("Array is too big");const S=new Array($);for(let N=0;N<$;N++)S[N]=re.decode(W);return S}}},n.frame=function(re){const W=n.state();return{preencode($,S){const N=$.end;re.preencode($,S),g.preencode($,$.end-N)},encode($,S){W.end=0,re.preencode(W,S),g.encode($,W.end),re.encode($,S)},decode($){const S=$.end,N=g.decode($);$.end=$.start+N;const D=re.decode($);return $.start=$.end,$.end=S,D}}},n.date={preencode(G,re){E.preencode(G,re.getTime())},encode(G,re){E.encode(G,re.getTime())},decode(G,re){return new Date(E.decode(G))}},n.json={preencode(G,re){v.preencode(G,JSON.stringify(re))},encode(G,re){v.encode(G,JSON.stringify(re))},decode(G){return JSON.parse(v.decode(G))}},n.ndjson={preencode(G,re){v.preencode(G,JSON.stringify(re)+`
`)},encode(G,re){v.encode(G,JSON.stringify(re)+`
`)},decode(G){return JSON.parse(v.decode(G))}},n.none={preencode(G,re){},encode(G,re){},decode(G){return null}};const R={preencode(G,re){g.preencode(G,re.length);for(let W=0;W<re.length;W++)U.preencode(G,re[W])},encode(G,re){g.encode(G,re.length);for(let W=0;W<re.length;W++)U.encode(G,re[W])},decode(G){const re=[];let W=g.decode(G);for(;W-- >0;)re.push(U.decode(G));return re}},A={preencode(G,re){const W=Object.keys(re);g.preencode(G,W.length);for(const $ of W)v.preencode(G,$),U.preencode(G,re[$])},encode(G,re){const W=Object.keys(re);g.encode(G,W.length);for(const $ of W)v.encode(G,$),U.encode(G,re[$])},decode(G){let re=g.decode(G);const W={};for(;re-- >0;){const $=v.decode(G);W[$]=U.decode(G)}return W}},q=[n.none,n.bool,n.string,n.buffer,n.uint,n.int,n.float64,R,A,n.date],U=n.any={preencode(G,re){const W=T(re);g.preencode(G,W),q[W].preencode(G,re)},encode(G,re){const W=T(re);g.encode(G,W),q[W].encode(G,re)},decode(G){const re=g.decode(G);if(re>=q.length)throw new Error("Unknown type: "+re);return q[re].decode(G)}};function T(G){if(G==null)return 0;if(typeof G=="boolean")return 1;if(typeof G=="string")return 2;if(a.isBuffer(G))return 3;if(typeof G=="number")return Number.isInteger(G)?G>=0?4:5:6;if(Array.isArray(G))return 7;if(G instanceof Date)return 9;if(typeof G=="object")return 8;throw new Error("Unsupported type for "+G)}n.from=function(re){return typeof re=="string"?Q(re):re.preencode?re:re.encodingLength?Y(re):le(re)};function Q(G){switch(G){case"ascii":return l.ascii;case"utf-8":case"utf8":return l.utf8;case"hex":return l.hex;case"base64":return l.base64;case"utf16-le":case"utf16le":case"ucs-2":case"ucs2":return l.ucs2;case"ndjson":return l.ndjson;case"json":return l.json;case"binary":default:return l.binary}}function le(G){let re=null,W=null;return{preencode($,S){re=S,W=G.encode(S),$.end+=W.byteLength},encode($,S){l.encode($,S===re?W:G.encode(S)),re=W=null},decode($){return G.decode(l.decode($))}}}function Y(G){return{preencode(re,W){re.end+=G.encodingLength(W)},encode(re,W){G.encode(W,re.buffer,re.start),re.start+=G.encode.bytes},decode(re){const W=G.decode(re.buffer,re.start,re.end);return re.start+=G.decode.bytes,W}}}n.encode=function(re,W){const $=n.state();return re.preencode($,W),$.buffer=a.allocUnsafe($.end),re.encode($,W),$.buffer},n.decode=function(re,W){return re.decode(n.state(0,W.byteLength,W))};function oe(G){return{preencode(re,W){G.preencode(re,O(W))},encode(re,W){G.encode(re,O(W))},decode(re){return ue(G.decode(re))}}}function ue(G){return G===0?G:(G&1)===0?G/2:-(G+1)/2}function O(G){return G<0?2*-G-1:G===0?0:2*G}function P(G){return{preencode(re,W){G.preencode(re,he(W))},encode(re,W){G.encode(re,he(W))},decode(re){return Z(G.decode(re))}}}function Z(G){return G===0n?G:(G&1n)===0n?G/2n:-(G+1n)/2n}function he(G){return G<0n?2n*-G-1n:G===0n?0n:2n*G}function se(G){if(!(G>=0))throw new Error("uint must be positive")}}(wh)),wh}var vh,q_;function jt(){if(q_)return vh;q_=1,vh=p;function n(l){return l?l instanceof TypeError||l instanceof SyntaxError||l instanceof ReferenceError||l instanceof EvalError||l instanceof RangeError||l instanceof URIError||l.code==="ERR_ASSERTION":!1}function a(l){queueMicrotask(()=>{throw l})}function p(l){if(n(l))throw a(l),l}return vh}var ro={},C_;function Of(){if(C_)return ro;C_=1;const n=Ue(),a="ybndrfg8ejkmcpqxot1uwisza345h769",p=49,l=122,g=new Int8Array(1+l-p);g.fill(-1);for(let c=0;c<a.length;c++){const s=a.charCodeAt(c)-p;g[s]=c}ro.encode=h,ro.decode=y,ro.ALPHABET=a;function y(c,s){let u=0,f=0;const m=c.length&7,E=(c.length-m)/8;s||(s=n.allocUnsafe(Math.ceil(c.length*5/8)));for(let R=0;R<E;R++){const A=o(c,f++),q=o(c,f++),U=o(c,f++),T=o(c,f++),Q=o(c,f++),le=o(c,f++),Y=o(c,f++),oe=o(c,f++);s[u++]=A<<3|q>>>2,s[u++]=(q&3)<<6|U<<1|T>>>4,s[u++]=(T&15)<<4|Q>>>1,s[u++]=(Q&1)<<7|le<<2|Y>>>3,s[u++]=(Y&7)<<5|oe}if(m===0)return s.subarray(0,u);const b=o(c,f++),_=o(c,f++);if(s[u++]=b<<3|_>>>2,m<=2)return s.subarray(0,u);const B=o(c,f++),M=o(c,f++);if(s[u++]=(_&3)<<6|B<<1|M>>>4,m<=4)return s.subarray(0,u);const z=o(c,f++);if(s[u++]=(M&15)<<4|z>>>1,m<=5)return s.subarray(0,u);const j=o(c,f++),v=o(c,f++);if(s[u++]=(z&1)<<7|j<<2|v>>>3,m<=7)return s.subarray(0,u);const w=o(c,f++);return s[u++]=(v&7)<<5|w,s.subarray(0,u)}function h(c){typeof c=="string"&&(c=n.from(c));const s=c.byteLength*8;let u="";for(let f=0;f<s;f+=5){const m=f>>>3,E=f&7;if(E<=3){u+=a[c[m]>>>3-E&31];continue}const b=E-3,_=c[m]<<b&31,B=(m>=c.byteLength?0:c[m+1])>>>8-b;u+=a[_|B]}return u}function o(c,s){if(s>c.length)return 0;const u=c.charCodeAt(s);if(u<p||u>l)throw Error('Invalid character in base32 input: "'+c[s]+'" at position '+s);const f=g[u-p];if(f===-1)throw Error('Invalid character in base32 input: "'+c[s]+'" at position '+s);return f}return ro}var kh,M_;function ol(){if(M_)return kh;M_=1;const n=Of(),a=Ue();kh={encode:p,decode:l,normalize:g,isValid:y};function p(h){if(!a.isBuffer(h))throw new Error("Key must be a Buffer");if(h.byteLength!==32)throw new Error("Key must be 32-bytes long");return n.encode(h)}function l(h){if(a.isBuffer(h)){if(h.byteLength!==32)throw new Error("ID must be 32-bytes long");return h}if(typeof h=="string"){if(h.startsWith("pear://")&&(h=h.slice(7).split("/")[0]),h.length===52)return n.decode(h);if(h.length===64){const o=a.from(h,"hex");if(o.byteLength===32)return o}}throw new Error("Invalid Hypercore key")}function g(h){return p(l(h))}function y(h){try{return l(h),!0}catch{return!1}}return kh}var Sh,U_;function On(){if(U_)return Sh;U_=1,Sh=a;class n extends Error{}n.prototype.name="AssertionError";function a(p,l){if(!p){var g=new n(l);throw Error.captureStackTrace&&Error.captureStackTrace(g,a),g}}return Sh}var xh,O_;function Dv(){if(O_)return xh;O_=1,xh=class{constructor(){this._resolve=null,this._reject=null,this._promise=null,this._bind=a.bind(this),this._onerror=n.bind(this),this._onsuccess=n.bind(this,null),this._timers=new Set}wait(l){return this._promise||(this._promise=new Promise(this._bind),this._promise.then(this._onsuccess).catch(this._onerror)),l?this._sleep(l):this._promise}_sleep(l){return new Promise((y,h)=>{const s={id:setTimeout(()=>{this._timers.delete(s),y(!0)},l),resolve:y,reject:h};this._timers.add(s)})}notify(l){if(!this._promise)return;const g=this._resolve,y=this._reject;this._promise=null,l?y(l):g(!0)}};function n(p){for(const{id:l,resolve:g,reject:y}of this._timers)clearTimeout(l),p?y(p):g(!0);this._timers.clear()}function a(p,l){this._resolve=p,this._reject=l}return xh}var Eh,P_;function N1(){if(P_)return Eh;P_=1;const n=jt();return Eh=class{constructor(p,l){this.target=p,this.wakeup=l,this.coupled=new Set,this._onpeeraddBound=this._onpeeradd.bind(this),this.target.on("peer-add",this._onpeeraddBound)}add(p){const l=this.coupled.size;this.coupled.add(p),l!==this.coupled.size&&this._couple(p)}remove(p){this.coupled.delete(p)}destroy(){this.target.off("peer-add",this._onpeeraddBound)}async update(p){const l=p.userData;if(l)try{if(!await this._hasMuxer(this.target,l))return;let g=null;for(const y of this.coupled)await this._hasMuxer(y,l)||(g===null&&(g=[]),g.push(y));g!==null&&this.wakeup(p,g)}catch(g){n(g)}}async _couple(p){try{let l=null;for(const g of this.target.peers)await this._hasPeer(p,g)||(l===null&&(l=[]),l.push(g));if(l!==null&&this.coupled.has(p))for(const g of l)this.wakeup(g.stream,[p])}catch(l){n(l)}}async _onpeeradd(p){try{let l=null;for(const g of this.coupled)await this._hasPeer(g,p)||(l===null&&(l=[]),l.push(g));l!==null&&this.wakeup(p.stream,l)}catch(l){n(l)}}_hasMuxer(p,l){const g=l.getLastChannel({protocol:"hypercore",id:p.discoveryKey});if(g)return g.fullyOpened();const y=l.getLastChannel({protocol:"hypercore/alpha",id:p.discoveryKey});return y?y.fullyOpened():Promise.resolve(!1)}_hasPeer(p,l){return this._hasMuxer(p,l.protomux)}},Eh}var Ah,I_;function Bv(){return I_||(I_=1,Ah=typeof queueMicrotask=="function"?queueMicrotask:n=>Promise.resolve().then(n)),Ah}var Rh,K_;function Nv(){if(K_)return Rh;K_=1;var n=Bv(),a=function(){var p=[],l=null,g=function(){l(h)},y=function(o){return l?p.push(o):(l=o,y.locked=!0,n(g),0)};y.locked=!1;var h=function(o,c,s){l=null,y.locked=!1,p.length&&y(p.shift()),o&&o(c,s)};return y};return Rh=a,Rh}var Lh,z_;function qv(){if(z_)return Lh;z_=1;var n=Nv(),a=function(){var p=n(),l=function(){return new Promise(p)};return Object.defineProperty(l,"locked",{get:function(){return p.locked},enumerable:!0}),l};return Lh=a,Lh}var Ut={};const q1={},C1=Object.freeze(Object.defineProperty({__proto__:null,default:q1},Symbol.toStringTag,{value:"Module"})),Cv=Rv(C1);var Th,H_;function sn(){return H_||(H_=1,Th=Cv),Th}var F_;function _t(){if(F_)return Ut;F_=1;const n=sn(),a=et(),p=Ue(),l=p.from([0]),g=p.from([1]),y=p.from([2]),h=p.from("hypercore");Ut.keyPair=function(c){const s=p.allocUnsafeSlow(n.crypto_sign_PUBLICKEYBYTES+n.crypto_sign_SECRETKEYBYTES),u=s.subarray(0,n.crypto_sign_PUBLICKEYBYTES),f=s.subarray(n.crypto_sign_PUBLICKEYBYTES);return c?n.crypto_sign_seed_keypair(u,f,c):n.crypto_sign_keypair(u,f),{publicKey:u,secretKey:f}},Ut.validateKeyPair=function(c){const s=p.allocUnsafe(n.crypto_sign_PUBLICKEYBYTES);return n.crypto_sign_ed25519_sk_to_pk(s,c.secretKey),p.equals(s,c.publicKey)},Ut.sign=function(c,s){const u=p.allocUnsafeSlow(n.crypto_sign_BYTES);return n.crypto_sign_detached(u,c,s),u},Ut.verify=function(c,s,u){return s.byteLength!==n.crypto_sign_BYTES||u.byteLength!==n.crypto_sign_PUBLICKEYBYTES?!1:n.crypto_sign_verify_detached(s,c,u)},Ut.encrypt=function(c,s){const u=p.alloc(c.byteLength+n.crypto_box_SEALBYTES);return n.crypto_box_seal(u,c,s),u},Ut.decrypt=function(c,s){if(c.byteLength<n.crypto_box_SEALBYTES)return null;const u=p.alloc(c.byteLength-n.crypto_box_SEALBYTES);return n.crypto_box_seal_open(u,c,s.publicKey,s.secretKey)?u:null},Ut.encryptionKeyPair=function(c){const s=p.alloc(n.crypto_box_PUBLICKEYBYTES),u=p.alloc(n.crypto_box_SECRETKEYBYTES);return c?n.crypto_box_seed_keypair(s,u,c):n.crypto_box_keypair(s,u),{publicKey:s,secretKey:u}},Ut.data=function(c){const s=p.allocUnsafe(32);return n.crypto_generichash_batch(s,[l,a.encode(a.uint64,c.byteLength),c]),s},Ut.parent=function(c,s){if(c.index>s.index){const f=c;c=s,s=f}const u=p.allocUnsafe(32);return n.crypto_generichash_batch(u,[g,a.encode(a.uint64,c.size+s.size),c.hash,s.hash]),u},Ut.tree=function(c,s){const u=new Array(3*c.length+1);let f=0;u[f++]=y;for(let m=0;m<c.length;m++){const E=c[m];u[f++]=E.hash,u[f++]=a.encode(a.uint64,E.index),u[f++]=a.encode(a.uint64,E.size)}return s||(s=p.allocUnsafe(32)),n.crypto_generichash_batch(s,u),s},Ut.hash=function(c,s){return s||(s=p.allocUnsafe(32)),Array.isArray(c)||(c=[c]),n.crypto_generichash_batch(s,c),s},Ut.randomBytes=function(c){const s=p.allocUnsafe(c);return n.randombytes_buf(s),s},Ut.discoveryKey=function(c){if(!c||c.byteLength!==32)throw new Error("Must pass a 32 byte buffer");const s=p.allocUnsafeSlow(32);return n.crypto_generichash(s,h,c),s},n.sodium_free?Ut.free=function(c){c.secure&&n.sodium_free(c)}:Ut.free=function(){},Ut.namespace=function(c,s){const u=typeof s=="number"?o(s):s,f=p.allocUnsafeSlow(32*u.length),m=new Array(u.length),E=p.allocUnsafe(33);n.crypto_generichash(E.subarray(0,32),typeof c=="string"?p.from(c):c);for(let b=0;b<m.length;b++)m[b]=f.subarray(32*b,32*b+32),E[32]=u[b],n.crypto_generichash(m[b],E);return m};function o(c){const s=new Array(c);for(let u=0;u<c;u++)s[u]=u;return s}return Ut}var Dh,V_;function Xt(){if(V_)return Dh;V_=1;const n=Ue();a.all=l,a.is=p,Dh=a;function a(g){if(g===null||g.buffer.byteLength===g.byteLength)return g;const y=n.allocUnsafeSlow(g.byteLength);return y.set(g,0),y}function p(g){return g.buffer.byteLength!==g.byteLength}function l(g){let y=0;for(let s=0;s<g.length;s++){const u=g[s];y+=u===null||u.buffer.byteLength===u.byteLength?0:u.byteLength}const h=n.allocUnsafeSlow(y),o=new Array(g.length);let c=0;for(let s=0;s<g.length;s++){let u=g[s];u!==null&&u.buffer.byteLength!==u.byteLength&&(h.set(u,c),u=h.subarray(c,c+=u.byteLength)),o[s]=u}return o}return Dh}var Bh,j_;function Pf(){if(j_)return Bh;j_=1;const n=Ue(),a=et(),p=Bv(),l=jt(),g=Xt(),y=32768,h=1/0,o=8*1024*1024;class c{constructor(_,B,M,z,j,v,w,R,A,q,U,T){this.userData=M,this.protocol=z,this.aliases=j,this.id=v,this.handshake=null,this.messages=[],this.opened=!1,this.closed=!1,this.destroyed=!1,this.onopen=A,this.onclose=q,this.ondestroy=U,this.ondrain=T,this._handshake=w,this._mux=_,this._info=B,this._localId=0,this._remoteId=0,this._active=0,this._extensions=null,this._decBound=this._dec.bind(this),this._decAndDestroyBound=this._decAndDestroy.bind(this),this._openedPromise=null,this._openedResolve=null,this._destroyedPromise=null,this._destroyedResolve=null;for(const Q of R)this.addMessage(Q)}get drained(){return this._mux.drained}fullyOpened(){return this.opened?Promise.resolve(!0):this.closed?Promise.resolve(!1):this._openedPromise?this._openedPromise:(this._openedPromise=new Promise(_=>{this._openedResolve=_}),this._openedPromise)}fullyClosed(){return this.destroyed?Promise.resolve():this._destroyedPromise?this._destroyedPromise:(this._destroyedPromise=new Promise(_=>{this._destroyedResolve=_}),this._destroyedPromise)}open(_){const B=this._mux._free.length>0?this._mux._free.pop():this._mux._local.push(null)-1;this._info.opened++,this._info.lastChannel=this,this._localId=B+1,this._mux._local[B]=this,this._remoteId===0&&this._info.outgoing.push(this._localId);const M={buffer:null,start:2,end:2};a.uint.preencode(M,this._localId),a.string.preencode(M,this.protocol),a.buffer.preencode(M,this.id),this._handshake&&this._handshake.preencode(M,_),M.buffer=this._mux._alloc(M.end),M.buffer[0]=0,M.buffer[1]=1,a.uint.encode(M,this._localId),a.string.encode(M,this.protocol),a.buffer.encode(M,this.id),this._handshake&&this._handshake.encode(M,_),this._mux._write0(M.buffer)}_dec(){--this._active===0&&this.closed===!0&&this._destroy()}_decAndDestroy(_){this._dec(),this._mux._safeDestroy(_)}_fullyOpenSoon(){this._mux._remote[this._remoteId-1].session=this,p(this._fullyOpen.bind(this))}_fullyOpen(){if(this.opened===!0||this.closed===!0)return;const _=this._mux._remote[this._remoteId-1];this.opened=!0,this.handshake=this._handshake?this._handshake.decode(_.state):null,this._track(this.onopen(this.handshake,this)),_.session=this,_.state=null,_.pending!==null&&this._drain(_),this._resolveOpen(!0)}_resolveOpen(_){this._openedResolve!==null&&(this._openedResolve(_),this._openedResolve=this._openedPromise=null)}_resolveDestroyed(){this._destroyedResolve!==null&&(this._destroyedResolve(),this._destroyedResolve=this._destroyedPromise=null)}_drain(_){for(let B=0;B<_.pending.length;B++){const M=_.pending[B];this._mux._buffered-=f(M.state),this._recv(M.type,M.state)}_.pending=null,this._mux._resumeMaybe()}_track(_){return m(_)===!0?(this._active++,_.then(this._decBound,this._decAndDestroyBound)):null}_close(_){this.closed!==!0&&(this.closed=!0,this._info.opened--,this._info.lastChannel===this&&(this._info.lastChannel=null),this._remoteId>0&&(this._mux._remote[this._remoteId-1]=null,this._remoteId=0,this._mux._free.push(this._localId-1)),this._mux._local[this._localId-1]=null,this._localId=0,this._mux._gc(this._info),this._track(this.onclose(_,this)),this._active===0&&this._destroy(),this._resolveOpen(!1))}_destroy(){this.destroyed!==!0&&(this.destroyed=!0,this._track(this.ondestroy(this)),this._resolveDestroyed())}_recv(_,B){if(_<this.messages.length){const M=this.messages[_],z=M.recv(B,this);if(M.autoBatch===!0)return z}return null}cork(){this._mux.cork()}uncork(){this._mux.uncork()}close(){if(this.closed===!0)return;const _={buffer:null,start:2,end:2};a.uint.preencode(_,this._localId),_.buffer=this._mux._alloc(_.end),_.buffer[0]=0,_.buffer[1]=3,a.uint.encode(_,this._localId),this._close(!1),this._mux._write0(_.buffer)}addMessage(_){if(!_)return this._skipMessage();const B=this.messages.length,M=_.autoBatch!==!1,z=_.encoding||a.raw,j=_.onmessage||s,v=this,w=E(a.uint,B),R={type:B,autoBatch:M,encoding:z,onmessage:j,recv(A,q){return q._track(R.onmessage(z.decode(A),q))},send(A,q=v){if(q.closed===!0)return!1;const U=q._mux,T={buffer:null,start:0,end:w};return U._batch!==null?(z.preencode(T,A),T.buffer=U._alloc(T.end),a.uint.encode(T,B),z.encode(T,A),U._pushBatch(q._localId,T.buffer),!0):(a.uint.preencode(T,q._localId),z.preencode(T,A),T.buffer=U._alloc(T.end),a.uint.encode(T,q._localId),a.uint.encode(T,B),z.encode(T,A),U.drained=U.stream.write(T.buffer),U.drained)}};return this.messages.push(R),R}_skipMessage(){const B={type:this.messages.length,encoding:a.raw,onmessage:s,recv(M,z){},send(M,z){}};return this.messages.push(B),B}}Bh=class{constructor(_,{alloc:B}={}){_.userData===null&&(_.userData=this),this.isProtomux=!0,this.stream=_,this.corked=0,this.drained=!0,this._alloc=B||(typeof _.alloc=="function"?_.alloc.bind(_):n.allocUnsafe),this._safeDestroyBound=this._safeDestroy.bind(this),this._uncorkBound=this.uncork.bind(this),this._remoteBacklog=0,this._buffered=0,this._paused=!1,this._remote=[],this._local=[],this._free=[],this._batch=null,this._batchState=null,this._infos=new Map,this._notify=new Map,this.stream.on("data",this._ondata.bind(this)),this.stream.on("drain",this._ondrain.bind(this)),this.stream.on("end",this._onend.bind(this)),this.stream.on("error",s),this.stream.on("close",this._shutdown.bind(this))}static from(_,B){return _.userData&&_.userData.isProtomux?_.userData:_.isProtomux?_:new this(_,B)}static isProtomux(_){return typeof _=="object"&&_.isProtomux===!0}*[Symbol.iterator](){for(const _ of this._local)_!==null&&(yield _)}isIdle(){return this._local.length===this._free.length}cork(){++this.corked===1&&(this._batch=[],this._batchState={buffer:null,start:0,end:1})}uncork(){--this.corked===0&&(this._sendBatch(this._batch,this._batchState),this._batch=null,this._batchState=null)}getLastChannel({protocol:_,id:B=null}){const M=u(_,B),z=this._infos.get(M);return z?z.lastChannel:null}pair({protocol:_,id:B=null},M){this._notify.set(u(_,B),M)}unpair({protocol:_,id:B=null}){this._notify.delete(u(_,B))}opened({protocol:_,id:B=null}){const M=u(_,B),z=this._infos.get(M);return z?z.opened>0:!1}createChannel({userData:_=null,protocol:B,aliases:M=[],id:z=null,unique:j=!0,handshake:v=null,messages:w=[],onopen:R=s,onclose:A=s,ondestroy:q=s,ondrain:U=s}){if(this.stream.destroyed)return null;const T=this._get(B,z,M);if(j&&T.opened>0)return null;if(T.incoming.length===0)return new c(this,T,_,B,M,z,v,w,R,A,q,U);this._remoteBacklog--;const Q=T.incoming.shift();if(this._remote[Q-1]===null)return null;const Y=new c(this,T,_,B,M,z,v,w,R,A,q,U);return Y._remoteId=Q,Y._fullyOpenSoon(),Y}_pushBatch(_,B){this._batchState.end>=o&&(this._sendBatch(this._batch,this._batchState),this._batch=[],this._batchState={buffer:null,start:0,end:1}),(this._batch.length===0||this._batch[this._batch.length-1].localId!==_)&&(this._batchState.end++,a.uint.preencode(this._batchState,_)),a.buffer.preencode(this._batchState,B),this._batch.push({localId:_,buffer:B})}_sendBatch(_,B){if(_.length===0)return;let M=_[0].localId;B.buffer=this._alloc(B.end),B.buffer[B.start++]=0,B.buffer[B.start++]=0,a.uint.encode(B,M);for(let z=0;z<_.length;z++){const j=_[z];M!==j.localId&&(B.buffer[B.start++]=0,a.uint.encode(B,M=j.localId)),a.buffer.encode(B,j.buffer)}this.drained=this.stream.write(B.buffer)}_get(_,B,M=[]){const z=u(_,B);let j=this._infos.get(z);if(j)return j;j={key:z,protocol:_,aliases:[],id:B,pairing:0,opened:0,incoming:[],outgoing:[],lastChannel:null},this._infos.set(z,j);for(const v of M){const w=u(v,B);j.aliases.push(w),this._infos.set(w,j)}return j}_gc(_){if(_.opened===0&&_.outgoing.length===0&&_.incoming.length===0){this._infos.delete(_.key);for(const B of _.aliases)this._infos.delete(B)}}_ondata(_){if(_.byteLength!==0)try{const B={buffer:_,start:0,end:_.byteLength};this._decode(a.uint.decode(B),B)}catch(B){this._safeDestroy(B)}}_ondrain(){this.drained=!0;for(const _ of this._local)_!==null&&_._track(_.ondrain(_))}_onend(){this.stream.end()}_decode(_,B){const M=a.uint.decode(B);if(_===0)return this._oncontrolsession(M,B);const z=_<=this._remote.length?this._remote[_-1]:null;return z===null?null:z.pending!==null?(this._bufferMessage(z,M,B),null):z.session._recv(M,B)}_oncontrolsession(_,B){switch(_){case 0:this._onbatch(B);break;case 1:return this._onopensession(B);case 2:this._onrejectsession(B);break;case 3:this._onclosesession(B);break}return null}_bufferMessage(_,B,{buffer:M,start:z,end:j}){const v={buffer:M,start:z,end:j};_.pending.push({type:B,state:v}),this._buffered+=f(v),this._pauseMaybe()}_pauseMaybe(){this._paused===!0||this._buffered<=y||(this._paused=!0,this.stream.pause())}_resumeMaybe(){this._paused===!1||this._buffered>y||(this._paused=!1,this.stream.resume())}_onbatch(_){const B=_.end;let M=a.uint.decode(_),z=null;for(;_.end>_.start;){const j=a.uint.decode(_);if(j===0){M=a.uint.decode(_);continue}_.end=_.start+j,B!==_.end&&z===null&&(z=[],this.cork());const v=this._decode(M,_);z!==null&&v!==null&&z.push(v),_.start=_.end,_.end=B}z!==null&&Promise.all(z).then(this._uncorkBound,this._safeDestroyBound)}_onopensession(_){const B=a.uint.decode(_),M=a.string.decode(_),z=g(a.buffer.decode(_));if(B===0)return this._rejectSession(0),null;const j=B-1,v=this._get(M,z);if(this._remote.length===j&&this._remote.push(null),j>=this._remote.length||this._remote[j]!==null)throw new Error("Invalid open message");if(v.outgoing.length>0){const R=v.outgoing.shift(),A=this._local[R-1];return A===null?(this._free.push(R-1),null):(this._remote[j]={state:_,pending:null,session:null},A._remoteId=B,A._fullyOpen(),null)}const w={buffer:_.buffer,start:_.start,end:_.end};if(this._remote[j]={state:w,pending:[],session:null},++this._remoteBacklog>h)throw new Error("Remote exceeded backlog");return v.pairing++,v.incoming.push(B),this._requestSession(M,z,v).catch(this._safeDestroyBound)}_onrejectsession(_){const B=a.uint.decode(_);for(const M of this._infos.values()){const z=M.outgoing.indexOf(B);if(z===-1)continue;M.outgoing.splice(z,1);const j=this._local[B-1];this._free.push(B-1),j!==null&&j._close(!0),this._gc(M);return}throw new Error("Invalid reject message")}_onclosesession(_){const B=a.uint.decode(_);if(B===0)return;const M=B-1,z=M<this._remote.length?this._remote[M]:null;z!==null&&z.session!==null&&z.session._close(!0)}async _requestSession(_,B,M){const z=this._notify.get(u(_,B))||this._notify.get(u(_,null));if(z&&await z(B),!(--M.pairing>0)){for(;M.incoming.length>0;)this._rejectSession(M,M.incoming.shift());this._gc(M)}}_rejectSession(_,B){if(B>0){const z=this._remote[B-1];if(z.pending!==null)for(let j=0;j<z.pending.length;j++)this._buffered-=f(z.pending[j].state);this._remote[B-1]=null,this._resumeMaybe()}const M={buffer:null,start:2,end:2};a.uint.preencode(M,B),M.buffer=this._alloc(M.end),M.buffer[0]=0,M.buffer[1]=2,a.uint.encode(M,B),this._write0(M.buffer)}_write0(_){if(this._batch!==null){this._pushBatch(0,_.subarray(1));return}this.drained=this.stream.write(_)}destroy(_){this.stream.destroy(_)}_safeDestroy(_){l(_),this.stream.destroy(_)}_shutdown(){for(const _ of this._local)_!==null&&_._close(!0)}};function s(){}function u(b,_){return b+"##"+(_?n.toString(_,"hex"):"")}function f(b){return 512+(b.end-b.start)}function m(b){return!!(b&&typeof b.then=="function")}function E(b,_){const B={buffer:null,start:0,end:0};return b.preencode(B,_),B.end}return Bh}var Nh,G_;function If(){return G_||(G_=1,Nh={c:et()}),Nh}var qh,Y_;function M1(){if(Y_)return qh;Y_=1;const n=1,{c:a}=If();let p=n;const l={preencode(_,B){_.end++},encode(_,B){const M=B.active?1:0;a.uint.encode(_,M)},decode(_){return{active:(a.uint.decode(_)&1)!==0}}},g={preencode(_,B){a.uint.preencode(_,B.version),a.fixed32.preencode(_,B.capability),_.end++},encode(_,B){const M=B.active?1:0;a.uint.encode(_,B.version),a.fixed32.encode(_,B.capability),a.uint.encode(_,M)},decode(_){const B=a.uint.decode(_),M=a.fixed32.decode(_),z=a.uint.decode(_);return{version:B,capability:M,active:(z&1)!==0}}},y={preencode(_,B){a.fixed32.preencode(_,B.key),a.uint.preencode(_,B.length)},encode(_,B){a.fixed32.encode(_,B.key),a.uint.encode(_,B.length)},decode(_){const B=a.fixed32.decode(_),M=a.uint.decode(_);return{key:B,length:M}}},h=a.array(y),o={preencode(_,B){_.end++,B.hash&&a.fixed32.preencode(_,B.hash)},encode(_,B){const M=B.hash?1:0;a.uint.encode(_,M),B.hash&&a.fixed32.encode(_,B.hash)},decode(_){return{hash:(a.uint.decode(_)&1)!==0?a.fixed32.decode(_):null}}};function c(_){p=_}function s(_,B,M=n){return p=M,a.encode(m(_),B)}function u(_,B,M=n){return p=M,a.decode(m(_),B)}function f(_){throw new Error("Enum not found "+_)}function m(_){switch(_){case"@wakeup/info":return l;case"@wakeup/handshake":return g;case"@wakeup/writer":return y;case"@wakeup/announce":return h;case"@wakeup/lookup":return o;default:throw new Error("Encoder not found "+_)}}function E(_,B=n){const M=m(_);return{preencode(z,j){p=B,M.preencode(z,j)},encode(z,j){p=B,M.encode(z,j)},decode(z){return p=B,M.decode(z)}}}return qh={resolveStruct:E,getStruct:E,getEnum:f,getEncoding:m,encode:s,decode:u,setVersion:c,version:p},qh}var Ch,W_;function U1(){if(W_)return Ch;W_=1;const n=_t(),a=Pf(),p=Ue(),l=M1(),[g,y]=n.namespace("wakeup",2),h=l.getEncoding("@wakeup/handshake"),o=l.getEncoding("@wakeup/announce"),c=l.getEncoding("@wakeup/lookup"),s=l.getEncoding("@wakeup/info");Ch=class{constructor(w=j){this.topics=new Map,this.topicsGC=new Set,this.muxers=new Set,this.onwakeup=w,this._gcInterval=null,this._gcBound=this._gc.bind(this)}session(w,R={}){const A=R.discoveryKey||n.discoveryKey(w),q=R.active!==!1,U=p.toString(A,"hex");let T=this.topics.get(U);if(T)return T.addSession(R);T=new m(this,A,w,q),this.topics.set(U,T);for(const Q of this.muxers)T._onopen(Q,!0);return T.addSession(R)}getSessions(w,R={}){const A=R.discoveryKey||n.discoveryKey(w),q=p.toString(A,"hex"),U=this.topics.get(q);return U?U.sessions:[]}addStream(w){const R=w.noiseStream||w;if(!R.connected){R.once("open",this.addStream.bind(this,R));return}const A=z(R);A.pair({protocol:"wakeup"},q=>this._onpair(q,A)),this.muxers.add(A),R.on("close",()=>this.muxers.delete(A));for(const q of this.topics.values())q.isActive&&q._onopen(A,!0)}_onActive(w){for(const R of this.muxers)w._onopen(R,!1)}_addGC(w){w.destroyed||(this.topicsGC.add(w),this._gcInterval===null&&(this._gcInterval=setInterval(this._gcBound,2e3)))}_removeGC(w){this.topicsGC.delete(w),this.topicsGC.size===0&&this._gcInterval&&(clearInterval(this._gcInterval),this._gcInterval=null)}_gc(){const w=[];for(const R of this.topicsGC)R.idleTicks++,R.idleTicks>=5&&w.push(R);for(const R of w)R.teardown()}destroy(){this._gcInterval&&clearInterval(this._gcInterval),this._gcInterval=null;for(const w of this.topics.values())w.teardown()}async _onpair(w,R){const A=p.toString(w,"hex"),q=this.topics.get(A);if(!q||!q.sessions.length)return this.onwakeup(w,R);q._onopen(z(R),!1)}};class u{constructor(w){this.index=0,this.userData=null,this.clock=0,this.pending=!0,this.removed=!1,this.topic=w,this.channel=null,this.stream=null,this.wireLookup=null,this.wireAnnounce=null,this.wireInfo=null}unlink(w){const R=w.pop();R!==this&&(R.index=this.index,w[R.index]=R)}}class f{constructor(w,R){this.index=0,this.topic=w,this.handlers=R,this.isActive=R.active!==!1,this.destroyed=!1}get peers(){return this.topic.peers}addStream(w){this.topic.addStream(w)}getPeer(w){return this.topic.peersByStream.get(w)||null}broadcastLookup(w){for(const R of this.topic.pendingPeers)this.lookup(R,w);for(const R of this.topic.peers)this.lookup(R,w)}lookupByStream(w,R){const A=this.topic.peersByStream.get(w);A&&this.lookup(A,R)}lookup(w,R){w.wireLookup.send(R||{hash:null})}announceByStream(w,R){const A=this.topic.peersByStream.get(w);A&&!A.pending&&this.announce(A,R)}announce(w,R){w.wireAnnounce.send(R)}active(){this.isActive=!0,this.topic._bumpActivity()}inactive(){this.isActive=!1,this.topic._bumpActivity()}destroy(){this.destroyed||(this.destroyed=!0,this.topic.removeSession(this))}}class m{constructor(w,R,A,q){this.state=w,this.sessions=[],this.id=R,this.capability=A,this.peers=[],this.pendingPeers=[],this.peersByStream=new Map,this.activePeers=0,this.isActive=q,this.idleTicks=0,this.gcing=!1,this.destroyed=!1}addSession(w){const R=new f(this,w);return R.index=this.sessions.length,this.sessions.push(R),this._bumpActivity(),R}removeSession(w){if(this.sessions.length<=w.index||this.sessions[w.index]!==w)return;const R=this.sessions.pop();R!==w&&(R.index=w.index,this.sessions[R.index]=R),this._bumpActivity(),this._checkGC()}_bumpActivity(){let w=!1;for(let R=this.sessions.length-1;R>=0;R--)if(this.sessions[R].isActive){w=!0;break}w?this.active():this.inactive()}active(){this.isActive||(this.idleTicks=0,this.isActive=!0,this._updateActive(!0))}inactive(){this.isActive&&(this.isActive=!1,this._updateActive(!1))}_updateActive(w){const R={active:w};for(const A of this.pendingPeers)A.wireInfo.send(R);for(const A of this.peers)A.wireInfo.send(R);this._checkGC(),w&&this.state._onActive(this)}teardown(){if(this.destroyed)return;this.destroyed=!0;for(let R=this.peers.length-1;R>=0;R--)this.peers[R].channel.close();for(let R=this.pendingPeers.length-1;R>=0;R--)this.pendingPeers[R].channel.close();const w=p.toString(this.id,"hex");this.gcing=!1,this.state.topics.delete(w),this.state._removeGC(this)}addStream(w){this._onopen(z(w),!1)}_proveCapabilityTo(w){return this._makeCapability(w.isInitiator,w.handshakeHash)}_makeCapability(w,R){return n.hash([w?g:y,this.capability,R])}_addPeer(w,R){if(!p.equals(R.capability,this._makeCapability(!w.stream.isInitiator,w.stream.handshakeHash))){w.channel.close();return}w.pending&&w.unlink(this.pendingPeers),w.active=R.active,w.pending=!1,w.index=this.peers.push(w)-1,w.active&&(this.activePeers++,this._checkGC());for(let A=this.sessions.length-1;A>=0;A--){const q=this.sessions[A],U=q.handlers;U.onpeeradd&&U.onpeeradd(w,q),w.active&&U.onpeeractive&&U.onpeeractive(w,q)}}_checkGC(){this.activePeers===0&&this.sessions.length===0?this.gcing||(this.gcing=!0,this.state._addGC(this)):this.gcing&&(this.gcing=!1,this.state._removeGC(this))}_removePeer(w){if(w.removed=!0,this.peersByStream.delete(w.stream),w.pending){w.unlink(this.pendingPeers);return}const R=w.active;R&&(w.active=!1,this.activePeers--,this._checkGC()),w.unlink(this.peers);for(let A=this.sessions.length-1;A>=0;A--){const q=this.sessions[A],U=q.handlers;R&&U.onpeerinactive&&U.onpeerinactive(w,q),U.onpeerremove&&U.onpeerremove(w,q)}}_onannounce(w,R){for(let A=this.sessions.length-1;A>=0;A--){const q=this.sessions[A],U=q.handlers;U.onannounce&&U.onannounce(w,R,q)}}_onlookup(w,R){for(let A=this.sessions.length-1;A>=0;A--){const q=this.sessions[A],U=q.handlers;U.onlookup&&U.onlookup(w,R,q)}}_oninfo(w,R){if(w.active){if(!R.active){R.active=!0,this.activePeers++,this._checkGC();for(let A=this.sessions.length-1;A>=0;A--){const q=this.sessions[A],U=q.handlers;U.onpeeractive&&U.onpeeractive(R,q)}}}else if(R.active){R.active=!1,this.activePeers--,this._checkGC();for(let A=this.sessions.length-1;A>=0;A--){const q=this.sessions[A],U=q.handlers;U.onpeerinactive&&U.onpeerinactive(R,q)}}}_onopen(w,R){if(!R&&this.peersByStream.has(w.stream))return;const A=new u(this),q=w.createChannel({userData:A,protocol:"wakeup",id:this.id,handshake:h,messages:[{encoding:c,onmessage:_},{encoding:o,onmessage:B},{encoding:s,onmessage:M}],onopen:E,onclose:b});q&&(A.channel=q,A.stream=w.stream,A.wireLookup=q.messages[0],A.wireAnnounce=q.messages[1],A.wireInfo=q.messages[2],A.index=this.pendingPeers.push(A)-1,this.peersByStream.set(w.stream,A),q.open({version:0,capability:this._proveCapabilityTo(w.stream),active:this.isActive}))}}function E(v,w){const R=w.userData;R.topic._addPeer(R,v)}function b(v,w){const R=w.userData;R.topic._removePeer(R)}function _(v,w){const R=w.userData;R.topic._onlookup(v,R)}function B(v,w){const R=w.userData;R.topic._onannounce(v,R)}function M(v,w){const R=w.userData;R.topic._oninfo(v,R)}function z(v){if(a.isProtomux(v))return v;if(v.noiseStream.userData)return v.noiseStream.userData;const w=a.from(v.noiseStream);return v.noiseStream.userData=w,w}function j(){}return Ch}var Ha={exports:{}},Q_;function go(){if(Q_)return Ha.exports;Q_=1;let n=null,a=null;Promise.withResolvers?Ha.exports=Promise.withResolvers.bind(Promise):Ha.exports=function(){const y={promise:new Promise(p),resolve:n,reject:a};return n=a=null,y};function p(l,g){n=l,a=g}return Ha.exports}var Mh,X_;function Kf(){if(X_)return Mh;X_=1;const n=Ue();return Mh=function(p){return typeof p=="object"&&p&&!n.isBuffer(p)},Mh}var Fa={exports:{}};function tn(n){throw new Error('Could not dynamically require "'+n+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var oo={exports:{}},Uh,Z_;function O1(){return Z_||(Z_=1,Uh=typeof Bare<"u"?"bare":typeof process<"u"?"node":"unknown"),Uh}var Oh,$_;function P1(){return $_||($_=1,Oh=tn.addon.bind(tn)),Oh}var Va={exports:{}},ja={exports:{}},Ga={exports:{}},qi={},Ph,J_;function zf(){return J_||(J_=1,Ph={EQ:1,LT:2,LTE:3,GT:4,GTE:5}),Ph}var Ih,em;function Hf(){return em||(em=1,Ih=class Xs extends Error{constructor(a,p,l=Xs){super(`${p}: ${a}`),this.code=p,Error.captureStackTrace&&Error.captureStackTrace(this,l)}get name(){return"SemVerError"}static INVALID_VERSION(a,p=Xs.INVALID_VERSION){return new Xs(a,"INVALID_VERSION",p)}static INVALID_RANGE(a,p=Xs.INVALID_RANGE){return new Xs(a,"INVALID_RANGE",p)}}),Ih}var Ya={exports:{}},tm;function Mv(){return tm||(tm=1,function(n,a){const p=Hf(),l=n.exports=a=class{constructor(h,o,c,s={}){const{prerelease:u=[],build:f=[]}=s;this.major=h,this.minor=o,this.patch=c,this.prerelease=u,this.build=f}compare(h){return a.compare(this,h)}toString(){let h=`${this.major}.${this.minor}.${this.patch}`;return this.prerelease.length&&(h+="-"+this.prerelease.join(".")),this.build.length&&(h+="+"+this.build.join(".")),h}};a.parse=function(h,o={position:0,partial:!1}){let c=o.position,s;const u=b=>{let _;throw c>=h.length?_=`Unexpected end of input in '${h}'`:_=`Unexpected token '${h[c]}' in '${h}' at position ${c}`,b&&(_+=`, ${b}`),p.INVALID_VERSION(_,u)},f=[];for(;f.length<3;)if(s=h[c],f.length>0&&(s==="."?s=h[++c]:u("expected '.'")),s==="0")f.push(0),c++;else if(s>="1"&&s<="9"){let b=0;do s=h[c+ ++b];while(s>="0"&&s<="9");f.push(parseInt(h.substring(c,c+b))),c+=b}else u("expected /[0-9]/");const m=[];if(h[c]==="-")for(c++;;){s=h[c];let b="",_=0;for(;s>="0"&&s<="9";)s=h[c+ ++_];let B=!1;for(_&&(b+=h.substring(c,c+_),s=h[c+=_],B=b[0]!=="0"||b.length===1),_=0;s>="0"&&s<="9"||s>="a"&&s<="z"||s>="A"&&s<="Z"||s==="-";)s=h[c+ ++_];if(_?(b+=h.substring(c,c+_),s=h[c+=_]):B||u("expected /[a-zA-Z-]/"),m.push(b),s===".")s=h[++c];else break}const E=[];if(h[c]==="+")for(c++;;){s=h[c];let b="",_=0;for(;s>="0"&&s<="9"||s>="a"&&s<="z"||s>="A"&&s<="Z"||s==="-";)s=h[c+ ++_];if(_?(b+=h.substring(c,c+_),s=h[c+=_]):u("expected /[0-9a-zA-Z-]/"),E.push(b),s===".")s=h[++c];else break}return c<h.length&&o.partial===!1&&u("expected end of input"),o.position=c,new l(...f,{prerelease:m,build:E})};const g=/^[0-9]+$/;a.compare=function(h,o){if(h.major>o.major)return 1;if(h.major<o.major)return-1;if(h.minor>o.minor)return 1;if(h.minor<o.minor)return-1;if(h.patch>o.patch)return 1;if(h.patch<o.patch)return-1;if(h.prerelease.length===0)return o.prerelease.length===0?0:1;if(o.prerelease.length===0)return-1;let c=0;do{let s=h.prerelease[c],u=o.prerelease[c];if(s===void 0)return u===void 0?0:-1;if(u===void 0)return 1;if(s===u)continue;const f=g.test(s),m=g.test(u);if(f&&m)s=+s,u=+u;else{if(f)return-1;if(m)return 1}return s>u?1:-1}while(++c)}}(Ya,Ya.exports)),Ya.exports}var Wa={exports:{}},Kh,nm;function Uv(){if(nm)return Kh;nm=1;const n=zf(),a={[n.EQ]:"=",[n.LT]:"<",[n.LTE]:"<=",[n.GT]:">",[n.GTE]:">="};return Kh=class{constructor(l,g){this.operator=l,this.version=g}test(l){const g=l.compare(this.version);switch(this.operator){case n.LT:return g<0;case n.LTE:return g<=0;case n.GT:return g>0;case n.GTE:return g>=0;default:return g===0}}toString(){return a[this.operator]+this.version}},Kh}var im;function I1(){return im||(im=1,function(n,a){const p=zf(),l=Hf(),g=Mv(),y=Uv(),h=n.exports=a=class{constructor(c=[]){this.comparators=c}test(c){for(const s of this.comparators){let u=!0;for(const f of s)if(!f.test(c)){u=!1;break}if(u)return!0}return!1}toString(){let c="",s=!0;for(const u of this.comparators)s?s=!1:c+=" || ",c+=u.join(" ");return c}};a.parse=function(c,s={position:0,partial:!1}){let u=s.position,f;const m=b=>{let _;throw u>=c.length?_=`Unexpected end of input in '${c}'`:_=`Unexpected token '${c[u]}' in '${c}' at position ${u}`,b&&(_+=`, ${b}`),l.INVALID_VERSION(_,m)},E=[];for(;u<c.length;){const b=[];for(;u<c.length;){f=c[u];let _=p.EQ;f==="<"?(_=p.LT,f=c[++u],f==="="&&(_=p.LTE,f=c[++u])):f===">"?(_=p.GT,f=c[++u],f==="="&&(_=p.GTE,f=c[++u])):f==="="&&(f=c[++u]);const B={position:u,partial:!0};for(b.push(new y(_,g.parse(c,B))),f=c[u=B.position];f===" ";)f=c[++u];if(f==="|"&&c[u+1]==="|"){for(f=c[u+=2];f===" ";)f=c[++u];break}f&&f!=="<"&&f!==">"&&m("expected '||', '<', or '>'")}b.length&&E.push(b)}return u<c.length&&s.partial===!1&&m("expected end of input"),s.position=u,new h(E)}}(Wa,Wa.exports)),Wa.exports}var sm;function Ov(){if(sm)return qi;sm=1,qi.constants=zf(),qi.errors=Hf();const n=qi.Version=Mv(),a=qi.Range=I1();return qi.Comparator=Uv(),qi.satisfies=function(l,g){return typeof l=="string"&&(l=n.parse(l)),typeof g=="string"&&(g=a.parse(g)),g.test(l)},qi}var zh,rm;function K1(){return rm||(rm=1,zh=class kn extends Error{constructor(a,p,l=kn){super(`${p}: ${a}`),this.code=p,Error.captureStackTrace&&Error.captureStackTrace(this,l)}get name(){return"ModuleResolveError"}static INVALID_MODULE_SPECIFIER(a){return new kn(a,"INVALID_MODULE_SPECIFIER",kn.INVALID_MODULE_SPECIFIER)}static INVALID_PACKAGE_TARGET(a){return new kn(a,"INVALID_PACKAGE_TARGET",kn.INVALID_PACKAGE_TARGET)}static PACKAGE_PATH_NOT_EXPORTED(a){return new kn(a,"PACKAGE_PATH_NOT_EXPORTED",kn.PACKAGE_PATH_NOT_EXPORTED)}static PACKAGE_IMPORT_NOT_DEFINED(a){return new kn(a,"PACKAGE_IMPORT_NOT_DEFINED",kn.PACKAGE_IMPORT_NOT_DEFINED)}static UNSUPPORTED_ENGINE(a){return new kn(a,"UNSUPPORTED_ENGINE",kn.UNSUPPORTED_ENGINE)}}),zh}var om;function z1(){return om||(om=1,function(n,a){const{satisfies:p}=Ov(),l=K1();n.exports=a=function(m,E,b,_){return typeof b=="function"?(_=b,b={}):typeof _!="function"&&(_=g),{*[Symbol.iterator](){const B=a.module(m,E,b);let M=B.next();for(;M.done!==!0;){const z=M.value;z.package?M=B.next(_(z.package)):M=B.next(yield z.resolution)}return M.value},async*[Symbol.asyncIterator](){const B=a.module(m,E,b);let M=B.next();for(;M.done!==!0;){const z=M.value;z.package?M=B.next(await _(z.package)):M=B.next(yield z.resolution)}return M.value}}};function g(){return null}const y=0,h=1,o=h|2;a.constants={UNRESOLVED:y,YIELDED:h,RESOLVED:o},a.module=function*(f,m,E={}){const{resolutions:b=null,imports:_=null}=E;a.startsWithWindowsDriveLetter(f)&&(f="/"+f);let B;return b&&(B=yield*a.preresolved(f,b,m,E),B)||(B=yield*a.url(f,m,E),B)||(B=yield*a.packageImports(f,m,E),B)?B:f==="."||f===".."||f[0]==="/"||f[0]==="\\"||f.startsWith("./")||f.startsWith(".\\")||f.startsWith("../")||f.startsWith("..\\")?_&&(B=yield*a.packageImportsExports(f,_,m,!0,E),B)||(B=yield*a.deferred(f,E),B)||(B=yield*a.file(f,m,!1,E),B===o)?B:yield*a.directory(f,m,E):yield*a.package(f,m,E)},a.url=function*(f,m,E={}){const{imports:b=null,deferredProtocol:_="deferred:"}=E;let B;try{B=new URL(f)}catch{return y}if(b){const z=yield*a.packageImportsExports(B.href,b,m,!0,E);if(z)return z}if(B.protocol===_){const z=B.pathname;return yield*a.module(z,m,E)}if(B.protocol==="node:"){const z=B.pathname;if(z==="."||z===".."||z[0]==="/"||z.startsWith("./")||z.startsWith("../"))throw l.INVALID_MODULE_SPECIFIER(`Module specifier '${f}' is not a valid package name`);return yield*a.package(z,m,E)}return(yield{resolution:B})?o:h},a.preresolved=function*(f,m,E,b={}){const _=m[E.href];return typeof _=="object"&&_!==null?yield*a.packageImportsExports(f,_,E,!0,b):y},a.deferred=function*(f,m={}){const{deferredProtocol:E="deferred:",defer:b=[]}=m;return b.includes(f)?(yield{resolution:new URL(E+f)})?o:h:y},a.package=function*(f,m,E={}){const{builtins:b=[]}=E;if(f==="")throw l.INVALID_MODULE_SPECIFIER(`Module specifier '${f}' is not a valid package name`);let _;if(f[0]!=="@")_=f.split("/",1).join();else{if(!f.includes("/"))throw l.INVALID_MODULE_SPECIFIER(`Module specifier '${f}' is not a valid package name`);_=f.split("/",2).join("/")}if(_[0]==="."||_.includes("\\")||_.includes("%"))throw l.INVALID_MODULE_SPECIFIER(`Module specifier '${f}' is not a valid package name`);let B;if(B=yield*a.builtinTarget(f,null,b,E),B||(B=yield*a.deferred(f,E),B))return B;let M="."+f.substring(_.length);if(B=yield*a.packageSelf(_,M,m,E),B)return B;m=new URL(m.href);do{const z=new URL("node_modules/"+_+"/",m);m.pathname=m.pathname.substring(0,m.pathname.lastIndexOf("/"));const j=yield{package:new URL("package.json",z)};if(j){if(j.engines&&a.validateEngines(z,j.engines,E),j.exports)return yield*a.packageExports(z,M,j.exports,E);if(M===".")if(typeof j.main=="string"&&j.main!=="")M=j.main;else return yield*a.file("index",z,!0,E);return B=yield*a.file(M,z,!1,E),B===o?B:yield*a.directory(M,z,E)}}while(m.pathname!==""&&m.pathname!=="/");return y},a.packageSelf=function*(f,m,E,b={}){for(const _ of a.lookupPackageScope(E,b)){const B=yield{package:_};if(B){if(B.name!==f)return!1;if(B.exports)return yield*a.packageExports(_,m,B.exports,b);if(m===".")if(typeof B.main=="string"&&B.main!=="")m=B.main;else return yield*a.file("index",_,!0,b);const M=yield*a.file(m,_,!1,b);return M===o?M:yield*a.directory(m,_,b)}}return y},a.packageExports=function*(f,m,E,b={}){if(m==="."){let _;if(typeof E=="string"||Array.isArray(E)?_=E:typeof E=="object"&&E!==null&&(Object.keys(E).some(M=>M.startsWith("."))?"."in E&&(_=E["."]):_=E),_){const B=yield*a.packageTarget(f,_,null,!1,b);if(B)return B}}else if(typeof E=="object"&&E!==null&&Object.keys(E).every(B=>B.startsWith("."))){const B=yield*a.packageImportsExports(m,E,f,!1,b);if(B)return B}throw f=new URL("package.json",f),l.PACKAGE_PATH_NOT_EXPORTED(`Package subpath '${m}' is not defined by "exports" in '${f}'`)},a.packageImports=function*(f,m,E={}){const{imports:b=null}=E;if(f==="#"||f.startsWith("#/"))throw l.INVALID_MODULE_SPECIFIER(`Module specifier '${f}' is not a valid internal imports specifier`);for(const _ of a.lookupPackageScope(m,E)){const B=yield{package:_};if(B){if(B.imports){const M=yield*a.packageImportsExports(f,B.imports,_,!0,E);if(M)return M}if(f.startsWith("#"))throw l.PACKAGE_IMPORT_NOT_DEFINED(`Package import specifier '${f}' is not defined by "imports" in '${_}'`);break}}if(b){const _=yield*a.packageImportsExports(f,b,m,!0,E);if(_)return _}return y},a.packageImportsExports=function*(f,m,E,b,_={}){if(f in m&&!f.includes("*")){const M=m[f];return yield*a.packageTarget(E,M,null,b,_)}const B=Object.keys(m).filter(M=>M.includes("*")).sort(a.patternKeyCompare);for(const M of B){const z=M.indexOf("*"),j=M.substring(0,z);if(f.startsWith(j)&&f!==j){const v=M.substring(z+1);if(v===""||f.endsWith(v)&&f.length>=M.length){const w=m[M],R=f.substring(j.length,f.length-v.length);return yield*a.packageTarget(E,w,R,b,_)}}}return y},a.validateEngines=function(m,E,b={}){const{engines:_={}}=b;for(const[B,M]of Object.entries(E))if(B in _){const z=_[B];if(!p(z,M))throw m=new URL("package.json",m),l.UNSUPPORTED_ENGINE(`Package not compatible with engine '${B}' ${z}, requires range '${M}' defined by "engines" in '${m}'`)}},a.patternKeyCompare=function(m,E){const b=m.indexOf("*"),_=E.indexOf("*"),B=b===-1?m.length:b+1,M=_===-1?E.length:_+1;return B>M?-1:M>B||b===-1?1:_===-1||m.length>E.length?-1:E.length>m.length?1:0},a.packageTarget=function*(f,m,E,b,_={}){const{conditions:B=[],matchedConditions:M=[]}=_;if(typeof m=="string"){if(!m.startsWith("./")&&!b)throw f=new URL("package.json",f),l.INVALID_PACKAGE_TARGET(`Invalid target '${m}' defined by "exports" in '${f}'`);E!==null&&(m=m.replaceAll("*",E));const z=yield*a.url(m,f,_);return z||(m==="."||m===".."||m[0]==="/"||m.startsWith("./")||m.startsWith("../")?(yield{resolution:new URL(m,f)})?o:h:yield*a.package(m,f,_))}if(Array.isArray(m))for(const z of m){const j=yield*a.packageTarget(f,z,E,b,_);if(j)return j}else if(typeof m=="object"&&m!==null){let z=y;for(const[j,v,w]of a.conditionMatches(m,B,_))M.push(j),z|=yield*a.packageTarget(f,v,E,b,{..._,conditions:w}),M.pop();if(z)return z}return y},a.builtinTarget=function*(f,m,E,b={}){const{builtinProtocol:_="builtin:",conditions:B=[],matchedConditions:M=[]}=b;if(typeof E=="string"){const z=E.split("@");let j,v;if(E[0]!=="@"?(j=z[0],v=z[1]||null):(j=z.slice(0,2).join("@"),v=z[2]||null),f===j){if(m===null&&v===null)return(yield{resolution:new URL(_+f)})?o:h;let w=null;if(m===null?w=v:(v===null||m===v)&&(w=m),w!==null)return(yield{resolution:new URL(_+f+"@"+w)})?o:h}}else if(Array.isArray(E))for(const z of E){const j=yield*a.builtinTarget(f,m,z,b);if(j)return j}else if(typeof E=="object"&&E!==null){let z=y;for(const[j,v,w]of a.conditionMatches(E,B,b))M.push(j),z|=yield*a.builtinTarget(f,m,v,{...b,conditions:w}),M.pop();if(z)return z}return y},a.conditionMatches=function*f(m,E,b={}){if(E.every(B=>typeof B=="string")){const B=Object.keys(m);for(const M of B)if(M==="default"||E.includes(M))return yield[M,m[M],E],!0;return!1}let _=!1;for(const B of E)(yield*f(m,B,b))&&(_=!0);return _},a.lookupPackageScope=function*(m,E={}){const{resolutions:b=null}=E;if(b){for(const{resolution:B}of a.preresolved("#package",b,m,E))if(B)return yield B;for(const{resolution:B}of a.preresolved("bare:package",b,m,E))if(B)return yield B}const _=new URL(m.href);do if(_.pathname.endsWith("/node_modules")||(yield new URL("package.json",_),_.pathname=_.pathname.substring(0,_.pathname.lastIndexOf("/")),_.pathname.length===3&&a.isWindowsDriveLetter(_.pathname.substring(1))))break;while(_.pathname!==""&&_.pathname!=="/")},a.file=function*(f,m,E,b={}){if(f==="."||f===".."||f[f.length-1]==="/"||f[f.length-1]==="\\")return y;if(m.protocol==="file:"&&/%2f|%5c/i.test(f))throw l.INVALID_MODULE_SPECIFIER(`Module specifier '${f}' is invalid`);const{extensions:_=[]}=b;let B=y;if(!E){if(yield{resolution:new URL(f,m)})return o;B=h}for(const M of _){if(yield{resolution:new URL(f+M,m)})return o;B=h}return B},a.directory=function*(f,m,E={}){let b;f[f.length-1]==="/"||f[f.length-1]==="\\"?b=new URL(f,m):b=new URL(f+"/",m);const _=yield{package:new URL("package.json",b)};if(_){if(_.exports)return yield*a.packageExports(b,".",_.exports,E);if(typeof _.main=="string"&&_.main!==""){const B=yield*a.file(_.main,b,!1,E);return B===o?B:yield*a.directory(_.main,b,E)}}return yield*a.file("index",b,!0,E)};function c(f){return f>=65&&f<=90}function s(f){return f>=97&&f<=122}function u(f){return c(f)||s(f)}a.isWindowsDriveLetter=function(m){return m.length>=2&&u(m.charCodeAt(0))&&(m.charCodeAt(1)===58||m.charCodeAt(1)===124)},a.startsWithWindowsDriveLetter=function(m){return m.length>=2&&a.isWindowsDriveLetter(m)&&(m.length===2||m.charCodeAt(2)===47||m.charCodeAt(2)===92||m.charCodeAt(2)===63||m.charCodeAt(2)===35)}}(Ga,Ga.exports)),Ga.exports}var Hh,am;function H1(){return am||(am=1,Hh=class Zs extends Error{constructor(a,p,l=Zs){super(`${p}: ${a}`),this.code=p,Error.captureStackTrace&&Error.captureStackTrace(this,l)}get name(){return"AddonResolveError"}static INVALID_ADDON_SPECIFIER(a){return new Zs(a,"INVALID_ADDON_SPECIFIER",Zs.INVALID_ADDON_SPECIFIER)}static INVALID_PACKAGE_NAME(a){return new Zs(a,"INVALID_PACKAGE_NAME",Zs.INVALID_PACKAGE_NAME)}}),Hh}var lm;function F1(){return lm||(lm=1,function(n,a){const p=z1(),{Version:l}=Ov(),g=H1();n.exports=a=function(f,m,E,b){return typeof E=="function"?(b=E,E={}):typeof b!="function"&&(b=y),{*[Symbol.iterator](){const _=a.addon(f,m,E);let B=_.next();for(;B.done!==!0;){const M=B.value;M.package?B=_.next(b(M.package)):B=_.next(yield M.resolution)}return B.value},async*[Symbol.asyncIterator](){const _=a.addon(f,m,E);let B=_.next();for(;B.done!==!0;){const M=B.value;M.package?B=_.next(await b(M.package)):B=_.next(yield M.resolution)}return B.value}}};function y(){return null}const{UNRESOLVED:h,YIELDED:o,RESOLVED:c}=p.constants;a.constants={UNRESOLVED:h,YIELDED:o,RESOLVED:c},a.addon=function*(u,f,m={}){const{resolutions:E=null}=m;a.startsWithWindowsDriveLetter(u)&&(u="/"+u);let b;if(E&&(b=yield*p.preresolved(u,E,f,m),b)||(b=yield*a.url(u,f,m),b))return b;let _=null;const B=u.lastIndexOf("@");if(B>0){_=u.substring(B+1);try{l.parse(_),u=u.substring(0,B)}catch{_=null}}return u==="."||u===".."||u[0]==="/"||u[0]==="\\"||u.startsWith("./")||u.startsWith(".\\")||u.startsWith("../")||u.startsWith("..\\")?yield*a.directory(u,_,f,m):yield*a.package(u,_,f,m)},a.url=function*(u,f,m={}){let E;try{E=new URL(u)}catch{return h}return(yield{resolution:E})?c:o},a.package=function*(u,f,m,E={}){if(u==="")throw g.INVALID_ADDON_SPECIFIER(`Addon specifier '${u}' is not a valid package name`);let b;if(u[0]!=="@")b=u.split("/",1).join();else{if(!u.includes("/"))throw g.INVALID_ADDON_SPECIFIER(`Addon specifier '${u}' is not a valid package name`);b=u.split("/",2).join("/")}if(b[0]==="."||b.includes("\\")||b.includes("%"))throw g.INVALID_ADDON_SPECIFIER(`Addon specifier '${u}' is not a valid package name`);const _="."+u.substring(b.length),B=yield*a.packageSelf(b,_,f,m,E);if(B)return B;m=new URL(m.href);do{const M=new URL("node_modules/"+b+"/",m);if(m.pathname=m.pathname.substring(0,m.pathname.lastIndexOf("/")),yield{package:new URL("package.json",M)})return yield*a.directory(_,f,M,E)}while(m.pathname!==""&&m.pathname!=="/");return h},a.packageSelf=function*(u,f,m,E,b={}){for(const _ of p.lookupPackageScope(E,b)){const B=yield{package:_};if(B){if(B.name===u)return yield*a.directory(f,m,_,b);break}}return h},a.lookupPrebuildsScope=function*(f,m={}){const{resolutions:E=null}=m;if(E){for(const{resolution:_}of p.preresolved("#prebuilds",E,f,m))if(_)return yield _}const b=new URL(f.href);do if(yield new URL("prebuilds/",b),b.pathname=b.pathname.substring(0,b.pathname.lastIndexOf("/")),b.pathname.length===3&&a.isWindowsDriveLetter(b.pathname.substring(1)))break;while(b.pathname!==""&&b.pathname!=="/")},a.file=function*(u,f,m={}){if(f.protocol==="file:"&&/%2f|%5c/i.test(u))throw g.INVALID_ADDON_SPECIFIER(`Addon specifier '${u}' is invalid`);const{extensions:E=[]}=m;let b=h;for(const _ of E){if(yield{resolution:new URL(u+_,f)})return c;b=o}return b},a.directory=function*(u,f,m,E={}){const{resolutions:b=null,host:_=null,hosts:B=_!==null?[_]:[],builtins:M=[],matchedConditions:z=[]}=E;let j;if(u[u.length-1]==="/"||u[u.length-1]==="\\"?j=new URL(u,m):j=new URL(u+"/",m),b){const q=yield*p.preresolved("bare:addon",b,j,E);if(q)return q}const v=f===null;let w=null;const R=yield{package:new URL("package.json",j)};if(R){if(typeof R.name=="string"&&R.name!==""){if(R.name.includes("__"))throw g.INVALID_PACKAGE_NAME(`Package name '${R.name}' is invalid`);w=R.name.replace(/\//g,"__").replace(/^@/,"")}else return h;if(typeof R.version=="string"&&R.version!==""){if(f!==null&&R.version!==f)return h;f=R.version}}else return h;let A;if(A=yield*p.builtinTarget(w,f,M,E),A)return A;for(const q of a.lookupPrebuildsScope(j,E)){A=h;for(const U of B){const T=U.split("-");z.push(...T),f!==null&&(A|=yield*a.file(U+"/"+w+"@"+f,q,E)),v&&(A|=yield*a.file(U+"/"+w,q,E));for(const Q of T)z.pop()}if(A===c)return A}return yield*a.linked(w,f,E)},a.linked=function*(u,f=null,m={}){const{linked:E=!0,host:b=null,hosts:_=b!==null?[b]:[],matchedConditions:B=[]}=m;if(E===!1||_.length===0)return h;let M=h;for(const z of _){const[j=null]=z.split("-",1);j!==null&&(B.push(j),M|=yield*s(u,f,j,m),B.pop())}return M};function*s(u,f=null,m,E={}){const{linkedProtocol:b="linked:"}=E;return m==="darwin"||m==="ios"?f!==null&&((yield{resolution:new URL(`${b}${u}.${f}.framework/${u}.${f}`)})||m==="darwin"&&(yield{resolution:new URL(`${b}lib${u}.${f}.dylib`)}))||(yield{resolution:new URL(`${b}${u}.framework/${u}`)})||m==="darwin"&&(yield{resolution:new URL(`${b}lib${u}.dylib`)})?c:o:m==="linux"||m==="android"?f!==null&&(yield{resolution:new URL(`${b}lib${u}.${f}.so`)})||(yield{resolution:new URL(`${b}lib${u}.so`)})?c:o:m==="win32"&&(f!==null&&(yield{resolution:new URL(`${b}${u}-${f}.dll`)})||(yield{resolution:new URL(`${b}${u}.dll`)}))?c:h}a.isWindowsDriveLetter=p.isWindowsDriveLetter,a.startsWithWindowsDriveLetter=p.startsWithWindowsDriveLetter}(ja,ja.exports)),ja.exports}var cm;function V1(){if(cm)return Va.exports;if(cm=1,typeof tn.addon=="function")Va.exports=tn.addon.bind(tn);else{const n=nn,a=F1(),p=process.platform+"-"+process.arch,l=["node",process.platform,process.arch],g=[".node"];Va.exports=function(h,o){typeof o=="string"&&(o=n.pathToFileURL(o));for(const s of a(h,o,{host:p,conditions:l,extensions:g},c))switch(s.protocol){case"file:":try{return tn(n.fileURLToPath(s))}catch{continue}}throw new Error(`Cannot find addon '${h}' imported from '${o.href}'`);function c(s){try{return tn(n.fileURLToPath(s))}catch{return null}}}}return Va.exports}var Qa={exports:{}},hm;function j1(){return hm||(hm=1,typeof tn.addon=="function"?Qa.exports=tn.addon.bind(tn):Qa.exports=function(a,p){throw new Error(`Cannot find addon '${a}' imported from '${p}'`)}),Qa.exports}var um;function Pv(){if(um)return oo.exports;um=1;const n=O1();return n==="bare"?oo.exports=P1():n==="node"?oo.exports=V1():oo.exports=j1(),oo.exports}var Fh,dm;function po(){return dm||(dm=1,tn.addon=Pv(),Fh=tn.addon(".",__filename)),Fh}var Xa={},fm;function Iv(){return fm||(fm=1,Xa.BloomFilterPolicy=class{get type(){return 1}constructor(a){this.bitsPerKey=a}},Xa.RibbonFilterPolicy=class{get type(){return 2}constructor(a,p=0){this.bloomEquivalentBitsPerKey=a,this.bloomBeforeLevel=p}}),Xa}var Vh,gm;function Kv(){if(gm)return Vh;gm=1;const n=po(),{BloomFilterPolicy:a}=Iv();class p{constructor(g,y={}){const{enableBlobFiles:h=!1,minBlobSize:o=0,blobFileSize:c=0,enableBlobGarbageCollection:s=!0,tableBlockSize:u=8192,tableCacheIndexAndFilterBlocks:f=!0,tableFormatVersion:m=6,optimizeFiltersForMemory:E=!1,blockCache:b=!0,filterPolicy:_=new a(10)}=y;this._name=g,this._flushing=null,this._options={enableBlobFiles:h,minBlobSize:o,blobFileSize:c,enableBlobGarbageCollection:s,tableBlockSize:u,tableCacheIndexAndFilterBlocks:f,tableFormatVersion:m,optimizeFiltersForMemory:E,blockCache:b,filterPolicy:_};const B=[];if(_===null)B.push(0);else switch(B.push(_.type),_.type){case 1:B.push(_.bitsPerKey);break;case 2:B.push(_.bloomEquivalentBitsPerKey,_.bloomBeforeLevel);break}this._handle=n.columnFamilyInit(g,h,o,c,s,u,f,m,E,b===!1,...B)}cloneSettings(g){return new p(g,this._options)}get name(){return this._name}destroy(){this._handle!==null&&(n.columnFamilyDestroy(this._handle),this._handle=null)}}return Vh=p,Vh}var jh,pm;function G1(){return pm||(pm=1,jh=class{constructor(a){if(!(a>0)||(a-1&a)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(a),this.mask=a-1,this.top=0,this.btm=0,this.next=null}clear(){this.top=this.btm=0,this.next=null,this.buffer.fill(void 0)}push(a){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=a,this.top=this.top+1&this.mask,!0)}shift(){const a=this.buffer[this.btm];if(a!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,a}peek(){return this.buffer[this.btm]}isEmpty(){return this.buffer[this.btm]===void 0}}),jh}var Gh,ym;function Ff(){if(ym)return Gh;ym=1;const n=G1();return Gh=class{constructor(p){this.hwm=p||16,this.head=new n(this.hwm),this.tail=this.head,this.length=0}clear(){this.head=this.tail,this.head.clear(),this.length=0}push(p){if(this.length++,!this.head.push(p)){const l=this.head;this.head=l.next=new n(2*this.head.buffer.length),this.head.push(p)}}shift(){this.length!==0&&this.length--;const p=this.tail.shift();if(p===void 0&&this.tail.next){const l=this.tail.next;return this.tail.next=null,this.tail=l,this.tail.shift()}return p}peek(){const p=this.tail.peek();return p===void 0&&this.tail.next?this.tail.next.peek():p}isEmpty(){return this.length===0}},Gh}var Yh,_m;function mm(){return _m||(_m=1,Yh=class{constructor(a){this.decoder=new TextDecoder(a==="utf16le"?"utf16-le":a)}get remaining(){return-1}decode(a){return this.decoder.decode(a,{stream:!0})}flush(){return this.decoder.decode(new Uint8Array(0))}}),Yh}var Wh,wm;function Y1(){if(wm)return Wh;wm=1;const n=mm(),a=mm();Wh=class{constructor(g="utf8"){switch(this.encoding=p(g),this.encoding){case"utf8":this.decoder=new a;break;case"utf16le":case"base64":throw new Error("Unsupported encoding: "+this.encoding);default:this.decoder=new n(this.encoding)}}get remaining(){return this.decoder.remaining}push(g){return typeof g=="string"?g:this.decoder.decode(g)}write(g){return this.push(g)}end(g){let y="";return g&&(y=this.push(g)),y+=this.decoder.flush(),y}};function p(l){switch(l=l.toLowerCase(),l){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return l;default:throw new Error("Unknown encoding: "+l)}}return Wh}var Qh,bm;function Sn(){if(bm)return Qh;bm=1;const{EventEmitter:n}=nn,a=new Error("Stream was destroyed"),p=new Error("Premature close"),l=Ff(),g=Y1(),y=typeof queueMicrotask>"u"?Me=>globalThis.process.nextTick(Me):queueMicrotask,h=(1<<29)-1,o=1,c=2,s=4,u=8,f=h^o,m=h^c,E=16,b=32,_=64,B=128,M=256,z=512,j=1024,v=2048,w=4096,R=8192,A=16384,q=32768,U=65536,T=131072,Q=M|z,le=E|U,Y=_|E,oe=w|B,ue=M|T,O=h^E,P=h^_,Z=h^(_|U),he=h^U,se=h^M,G=h^(B|R),re=h^j,W=h^Q,$=h^q,S=h^b,N=h^T,D=h^ue,H=1<<18,_e=2<<18,ce=4<<18,J=8<<18,d=16<<18,k=32<<18,X=64<<18,ie=128<<18,I=256<<18,L=512<<18,V=1024<<18,te=h^(H|I),de=h^ce,C=h^(H|L),ee=h^d,fe=h^J,ve=h^ie,we=h^_e,F=h^V,ne=E|H,ye=h^ne,me=A|k,Ee=s|u|c,qe=Ee|o,Oe=Ee|me,Pe=de&P,ze=ie|q,it=ze&ye,at=qe|it,xt=qe|j|A,ii=qe|A|B,si=qe|j|B,hs=qe|w|B|R,Ui=qe|E|j|A|U|T,Oi=Ee|j|A,cl=b|qe|q|_,vo=q|o,ko=qe|L|k,rr=J|d,us=J|H,So=J|d|qe|H,xo=qe|H|J|V,Ln=ce|H,Bt=H|I,zt=qe|L|us|k,ri=d|Ee|L|k,or=_e|qe|ie|ce,hl=L|k|Ee,ds=Symbol.asyncIterator||Symbol("asyncIterator");class ar{constructor(pe,{highWaterMark:Ce=16384,map:He=null,mapWritable:Xe,byteLength:gt,byteLengthWritable:ht}={}){this.stream=pe,this.queue=new l,this.highWaterMark=Ce,this.buffered=0,this.error=null,this.pipeline=null,this.drains=null,this.byteLength=ht||gt||Gt,this.map=Xe||He,this.afterWrite=Et.bind(this),this.afterUpdateNextTick=In.bind(this)}get ended(){return(this.stream._duplexState&k)!==0}push(pe){return(this.stream._duplexState&hl)!==0?!1:(this.map!==null&&(pe=this.map(pe)),this.buffered+=this.byteLength(pe),this.queue.push(pe),this.buffered<this.highWaterMark?(this.stream._duplexState|=J,!0):(this.stream._duplexState|=rr,!1))}shift(){const pe=this.queue.shift();return this.buffered-=this.byteLength(pe),this.buffered===0&&(this.stream._duplexState&=fe),pe}end(pe){typeof pe=="function"?this.stream.once("finish",pe):pe!=null&&this.push(pe),this.stream._duplexState=(this.stream._duplexState|L)&de}autoBatch(pe,Ce){const He=[],Xe=this.stream;for(He.push(pe);(Xe._duplexState&xo)===us;)He.push(Xe._writableState.shift());if((Xe._duplexState&qe)!==0)return Ce(null);Xe._writev(He,Ce)}update(){const pe=this.stream;pe._duplexState|=_e;do{for(;(pe._duplexState&xo)===J;){const Ce=this.shift();pe._duplexState|=Bt,pe._write(Ce,this.afterWrite)}(pe._duplexState&Ln)===0&&this.updateNonPrimary()}while(this.continueUpdate()===!0);pe._duplexState&=we}updateNonPrimary(){const pe=this.stream;if((pe._duplexState&zt)===L){pe._duplexState=pe._duplexState|H,pe._final(Ii.bind(this));return}if((pe._duplexState&Ee)===s){(pe._duplexState&ze)===0&&(pe._duplexState|=ne,pe._destroy(Pn.bind(this)));return}(pe._duplexState&at)===o&&(pe._duplexState=(pe._duplexState|ne)&f,pe._open(Ro.bind(this)))}continueUpdate(){return(this.stream._duplexState&ie)===0?!1:(this.stream._duplexState&=ve,!0)}updateCallback(){(this.stream._duplexState&or)===ce?this.update():this.updateNextTick()}updateNextTick(){(this.stream._duplexState&ie)===0&&(this.stream._duplexState|=ie,(this.stream._duplexState&_e)===0&&y(this.afterUpdateNextTick))}}class Pi{constructor(pe,{highWaterMark:Ce=16384,map:He=null,mapReadable:Xe,byteLength:gt,byteLengthReadable:ht}={}){this.stream=pe,this.queue=new l,this.highWaterMark=Ce===0?1:Ce,this.buffered=0,this.readAhead=Ce>0,this.error=null,this.pipeline=null,this.byteLength=ht||gt||Gt,this.map=Xe||He,this.pipeTo=null,this.afterRead=Eo.bind(this),this.afterUpdateNextTick=Ao.bind(this)}get ended(){return(this.stream._duplexState&A)!==0}pipe(pe,Ce){if(this.pipeTo!==null)throw new Error("Can only pipe to one destination");if(typeof Ce!="function"&&(Ce=null),this.stream._duplexState|=z,this.pipeTo=pe,this.pipeline=new oi(this.stream,pe,Ce),Ce&&this.stream.on("error",_s),Nt(pe))pe._writableState.pipeline=this.pipeline,Ce&&pe.on("error",_s),pe.on("finish",this.pipeline.finished.bind(this.pipeline));else{const He=this.pipeline.done.bind(this.pipeline,pe),Xe=this.pipeline.done.bind(this.pipeline,pe,null);pe.on("error",He),pe.on("close",Xe),pe.on("finish",this.pipeline.finished.bind(this.pipeline))}pe.on("drain",ai.bind(this)),this.stream.emit("piping",pe),pe.emit("pipe",this.stream)}push(pe){const Ce=this.stream;return pe===null?(this.highWaterMark=0,Ce._duplexState=(Ce._duplexState|j)&Z,!1):this.map!==null&&(pe=this.map(pe),pe===null)?(Ce._duplexState&=he,this.buffered<this.highWaterMark):(this.buffered+=this.byteLength(pe),this.queue.push(pe),Ce._duplexState=(Ce._duplexState|B)&he,this.buffered<this.highWaterMark)}shift(){const pe=this.queue.shift();return this.buffered-=this.byteLength(pe),this.buffered===0&&(this.stream._duplexState&=G),pe}unshift(pe){const Ce=[this.map!==null?this.map(pe):pe];for(;this.buffered>0;)Ce.push(this.shift());for(let He=0;He<Ce.length-1;He++){const Xe=Ce[He];this.buffered+=this.byteLength(Xe),this.queue.push(Xe)}this.push(Ce[Ce.length-1])}read(){const pe=this.stream;if((pe._duplexState&ii)===B){const Ce=this.shift();return this.pipeTo!==null&&this.pipeTo.write(Ce)===!1&&(pe._duplexState&=W),(pe._duplexState&v)!==0&&pe.emit("data",Ce),Ce}return this.readAhead===!1&&(pe._duplexState|=T,this.updateNextTick()),null}drain(){const pe=this.stream;for(;(pe._duplexState&ii)===B&&(pe._duplexState&Q)!==0;){const Ce=this.shift();this.pipeTo!==null&&this.pipeTo.write(Ce)===!1&&(pe._duplexState&=W),(pe._duplexState&v)!==0&&pe.emit("data",Ce)}}update(){const pe=this.stream;pe._duplexState|=b;do{for(this.drain();this.buffered<this.highWaterMark&&(pe._duplexState&Ui)===T;)pe._duplexState|=le,pe._read(this.afterRead),this.drain();(pe._duplexState&hs)===oe&&(pe._duplexState|=R,pe.emit("readable")),(pe._duplexState&Y)===0&&this.updateNonPrimary()}while(this.continueUpdate()===!0);pe._duplexState&=S}updateNonPrimary(){const pe=this.stream;if((pe._duplexState&si)===j&&(pe._duplexState=(pe._duplexState|A)&re,pe.emit("end"),(pe._duplexState&Oe)===me&&(pe._duplexState|=s),this.pipeTo!==null&&this.pipeTo.end()),(pe._duplexState&Ee)===s){(pe._duplexState&ze)===0&&(pe._duplexState|=ne,pe._destroy(Pn.bind(this)));return}(pe._duplexState&at)===o&&(pe._duplexState=(pe._duplexState|ne)&f,pe._open(Ro.bind(this)))}continueUpdate(){return(this.stream._duplexState&q)===0?!1:(this.stream._duplexState&=$,!0)}updateCallback(){(this.stream._duplexState&cl)===_?this.update():this.updateNextTick()}updateNextTickIfOpen(){(this.stream._duplexState&vo)===0&&(this.stream._duplexState|=q,(this.stream._duplexState&b)===0&&y(this.afterUpdateNextTick))}updateNextTick(){(this.stream._duplexState&q)===0&&(this.stream._duplexState|=q,(this.stream._duplexState&b)===0&&y(this.afterUpdateNextTick))}}class lr{constructor(pe){this.data=null,this.afterTransform=Lo.bind(pe),this.afterFinal=null}}class oi{constructor(pe,Ce,He){this.from=pe,this.to=Ce,this.afterPipe=He,this.error=null,this.pipeToFinished=!1}finished(){this.pipeToFinished=!0}done(pe,Ce){if(Ce&&(this.error=Ce),pe===this.to&&(this.to=null,this.from!==null)){((this.from._duplexState&A)===0||!this.pipeToFinished)&&this.from.destroy(this.error||new Error("Writable stream closed prematurely"));return}if(pe===this.from&&(this.from=null,this.to!==null)){(pe._duplexState&A)===0&&this.to.destroy(this.error||new Error("Readable stream closed before ending"));return}this.afterPipe!==null&&this.afterPipe(this.error),this.to=this.from=this.afterPipe=null}}function ai(){this.stream._duplexState|=z,this.updateCallback()}function Ii(Me){const pe=this.stream;Me&&pe.destroy(Me),(pe._duplexState&Ee)===0&&(pe._duplexState|=k,pe.emit("finish")),(pe._duplexState&Oe)===me&&(pe._duplexState|=s),pe._duplexState&=C,(pe._duplexState&_e)===0?this.update():this.updateNextTick()}function Pn(Me){const pe=this.stream;!Me&&this.error!==a&&(Me=this.error),Me&&pe.emit("error",Me),pe._duplexState|=u,pe.emit("close");const Ce=pe._readableState,He=pe._writableState;if(Ce!==null&&Ce.pipeline!==null&&Ce.pipeline.done(pe,Me),He!==null){for(;He.drains!==null&&He.drains.length>0;)He.drains.shift().resolve(!1);He.pipeline!==null&&He.pipeline.done(pe,Me)}}function Et(Me){const pe=this.stream;Me&&pe.destroy(Me),pe._duplexState&=te,this.drains!==null&&li(this.drains),(pe._duplexState&So)===d&&(pe._duplexState&=ee,(pe._duplexState&X)===X&&pe.emit("drain")),this.updateCallback()}function Eo(Me){Me&&this.stream.destroy(Me),this.stream._duplexState&=O,this.readAhead===!1&&(this.stream._duplexState&M)===0&&(this.stream._duplexState&=N),this.updateCallback()}function Ao(){(this.stream._duplexState&b)===0&&(this.stream._duplexState&=$,this.update())}function In(){(this.stream._duplexState&_e)===0&&(this.stream._duplexState&=ve,this.update())}function li(Me){for(let pe=0;pe<Me.length;pe++)--Me[pe].writes===0&&(Me.shift().resolve(!0),pe--)}function Ro(Me){const pe=this.stream;Me&&pe.destroy(Me),(pe._duplexState&s)===0&&((pe._duplexState&xt)===0&&(pe._duplexState|=_),(pe._duplexState&ko)===0&&(pe._duplexState|=ce),pe.emit("open")),pe._duplexState&=ye,pe._writableState!==null&&pe._writableState.updateCallback(),pe._readableState!==null&&pe._readableState.updateCallback()}function Lo(Me,pe){pe!=null&&this.push(pe),this._writableState.afterWrite(Me)}function To(Me){this._readableState!==null&&(Me==="data"&&(this._duplexState|=v|ue,this._readableState.updateNextTick()),Me==="readable"&&(this._duplexState|=w,this._readableState.updateNextTick())),this._writableState!==null&&Me==="drain"&&(this._duplexState|=X,this._writableState.updateNextTick())}class cr extends n{constructor(pe){super(),this._duplexState=0,this._readableState=null,this._writableState=null,pe&&(pe.open&&(this._open=pe.open),pe.destroy&&(this._destroy=pe.destroy),pe.predestroy&&(this._predestroy=pe.predestroy),pe.signal&&pe.signal.addEventListener("abort",qo.bind(this))),this.on("newListener",To)}_open(pe){pe(null)}_destroy(pe){pe(null)}_predestroy(){}get readable(){return this._readableState!==null?!0:void 0}get writable(){return this._writableState!==null?!0:void 0}get destroyed(){return(this._duplexState&u)!==0}get destroying(){return(this._duplexState&Ee)!==0}destroy(pe){(this._duplexState&Ee)===0&&(pe||(pe=a),this._duplexState=(this._duplexState|s)&Pe,this._readableState!==null&&(this._readableState.highWaterMark=0,this._readableState.error=pe),this._writableState!==null&&(this._writableState.highWaterMark=0,this._writableState.error=pe),this._duplexState|=c,this._predestroy(),this._duplexState&=m,this._readableState!==null&&this._readableState.updateNextTick(),this._writableState!==null&&this._writableState.updateNextTick())}}class Tn extends cr{constructor(pe){super(pe),this._duplexState|=o|k|T,this._readableState=new Pi(this,pe),pe&&(this._readableState.readAhead===!1&&(this._duplexState&=N),pe.read&&(this._read=pe.read),pe.eagerOpen&&this._readableState.updateNextTick(),pe.encoding&&this.setEncoding(pe.encoding))}setEncoding(pe){const Ce=new g(pe),He=this._readableState.map||ul;return this._readableState.map=Xe,this;function Xe(gt){const ht=Ce.push(gt);return ht===""&&(gt.byteLength!==0||Ce.remaining>0)?null:He(ht)}}_read(pe){pe(null)}pipe(pe,Ce){return this._readableState.updateNextTick(),this._readableState.pipe(pe,Ce),pe}read(){return this._readableState.updateNextTick(),this._readableState.read()}push(pe){return this._readableState.updateNextTickIfOpen(),this._readableState.push(pe)}unshift(pe){return this._readableState.updateNextTickIfOpen(),this._readableState.unshift(pe)}resume(){return this._duplexState|=ue,this._readableState.updateNextTick(),this}pause(){return this._duplexState&=this._readableState.readAhead===!1?D:se,this}static _fromAsyncIterator(pe,Ce){let He;const Xe=new Tn({...Ce,read(ht){pe.next().then(gt).then(ht.bind(null,null)).catch(ht)},predestroy(){He=pe.return()},destroy(ht){if(!He)return ht(null);He.then(ht.bind(null,null)).catch(ht)}});return Xe;function gt(ht){ht.done?Xe.push(null):Xe.push(ht.value)}}static from(pe,Ce){if(No(pe))return pe;if(pe[ds])return this._fromAsyncIterator(pe[ds](),Ce);Array.isArray(pe)||(pe=pe===void 0?[]:[pe]);let He=0;return new Tn({...Ce,read(Xe){this.push(He===pe.length?null:pe[He++]),Xe(null)}})}static isBackpressured(pe){return(pe._duplexState&Oi)!==0||pe._readableState.buffered>=pe._readableState.highWaterMark}static isPaused(pe){return(pe._duplexState&M)===0}[ds](){const pe=this;let Ce=null,He=null,Xe=null;return this.on("error",tt=>{Ce=tt}),this.on("readable",gt),this.on("close",ht),{[ds](){return this},next(){return new Promise(function(tt,Yt){He=tt,Xe=Yt;const gn=pe.read();gn!==null?Dn(gn):(pe._duplexState&u)!==0&&Dn(null)})},return(){return zi(null)},throw(tt){return zi(tt)}};function gt(){He!==null&&Dn(pe.read())}function ht(){He!==null&&Dn(null)}function Dn(tt){Xe!==null&&(Ce?Xe(Ce):tt===null&&(pe._duplexState&A)===0?Xe(a):He({value:tt,done:tt===null}),Xe=He=null)}function zi(tt){return pe.destroy(tt),new Promise((Yt,gn)=>{if(pe._duplexState&u)return Yt({value:void 0,done:!0});pe.once("close",function(){tt?gn(tt):Yt({value:void 0,done:!0})})})}}}class Ki extends cr{constructor(pe){super(pe),this._duplexState|=o|A,this._writableState=new ar(this,pe),pe&&(pe.writev&&(this._writev=pe.writev),pe.write&&(this._write=pe.write),pe.final&&(this._final=pe.final),pe.eagerOpen&&this._writableState.updateNextTick())}cork(){this._duplexState|=V}uncork(){this._duplexState&=F,this._writableState.updateNextTick()}_writev(pe,Ce){Ce(null)}_write(pe,Ce){this._writableState.autoBatch(pe,Ce)}_final(pe){pe(null)}static isBackpressured(pe){return(pe._duplexState&ri)!==0}static drained(pe){if(pe.destroyed)return Promise.resolve(!1);const Ce=pe._writableState,Xe=(dr(pe)?Math.min(1,Ce.queue.length):Ce.queue.length)+(pe._duplexState&I?1:0);return Xe===0?Promise.resolve(!0):(Ce.drains===null&&(Ce.drains=[]),new Promise(gt=>{Ce.drains.push({writes:Xe,resolve:gt})}))}write(pe){return this._writableState.updateNextTick(),this._writableState.push(pe)}end(pe){return this._writableState.updateNextTick(),this._writableState.end(pe),this}}class on extends Tn{constructor(pe){super(pe),this._duplexState=o|this._duplexState&T,this._writableState=new ar(this,pe),pe&&(pe.writev&&(this._writev=pe.writev),pe.write&&(this._write=pe.write),pe.final&&(this._final=pe.final))}cork(){this._duplexState|=V}uncork(){this._duplexState&=F,this._writableState.updateNextTick()}_writev(pe,Ce){Ce(null)}_write(pe,Ce){this._writableState.autoBatch(pe,Ce)}_final(pe){pe(null)}write(pe){return this._writableState.updateNextTick(),this._writableState.push(pe)}end(pe){return this._writableState.updateNextTick(),this._writableState.end(pe),this}}class fs extends on{constructor(pe){super(pe),this._transformState=new lr(this),pe&&(pe.transform&&(this._transform=pe.transform),pe.flush&&(this._flush=pe.flush))}_write(pe,Ce){this._readableState.buffered>=this._readableState.highWaterMark?this._transformState.data=pe:this._transform(pe,this._transformState.afterTransform)}_read(pe){if(this._transformState.data!==null){const Ce=this._transformState.data;this._transformState.data=null,pe(null),this._transform(Ce,this._transformState.afterTransform)}else pe(null)}destroy(pe){super.destroy(pe),this._transformState.data!==null&&(this._transformState.data=null,this._transformState.afterTransform())}_transform(pe,Ce){Ce(null,pe)}_flush(pe){pe(null)}_final(pe){this._transformState.afterFinal=pe,this._flush(ci.bind(this))}}class Do extends fs{}function ci(Me,pe){const Ce=this._transformState.afterFinal;if(Me)return Ce(Me);pe!=null&&this.push(pe),this.push(null),Ce(null)}function hr(...Me){return new Promise((pe,Ce)=>gs(...Me,He=>{if(He)return Ce(He);pe()}))}function gs(Me,...pe){const Ce=Array.isArray(Me)?[...Me,...pe]:[Me,...pe],He=Ce.length&&typeof Ce[Ce.length-1]=="function"?Ce.pop():null;if(Ce.length<2)throw new Error("Pipeline requires at least 2 streams");let Xe=Ce[0],gt=null,ht=null;for(let tt=1;tt<Ce.length;tt++)gt=Ce[tt],Nt(Xe)?Xe.pipe(gt,zi):(Dn(Xe,!0,tt>1,zi),Xe.pipe(gt)),Xe=gt;if(He){let tt=!1;const Yt=Nt(gt)||!!(gt._writableState&&gt._writableState.autoDestroy);gt.on("error",gn=>{ht===null&&(ht=gn)}),gt.on("finish",()=>{tt=!0,Yt||He(ht)}),Yt&&gt.on("close",()=>He(ht||(tt?null:p)))}return gt;function Dn(tt,Yt,gn,Hi){tt.on("error",Hi),tt.on("close",hi);function hi(){if(tt._readableState&&!tt._readableState.ended||gn&&tt._writableState&&!tt._writableState.ended)return Hi(p)}}function zi(tt){if(!(!tt||ht)){ht=tt;for(const Yt of Ce)Yt.destroy(tt)}}}function ul(Me){return Me}function ur(Me){return!!Me._readableState||!!Me._writableState}function Nt(Me){return typeof Me._duplexState=="number"&&ur(Me)}function Bo(Me){return!!Me._readableState&&Me._readableState.ended}function dl(Me){return!!Me._writableState&&Me._writableState.ended}function ps(Me,pe={}){const Ce=Me._readableState&&Me._readableState.error||Me._writableState&&Me._writableState.error;return!pe.all&&Ce===a?null:Ce}function No(Me){return Nt(Me)&&Me.readable}function ys(Me){return(Me._duplexState&o)!==o||(Me._duplexState&ze)!==0}function fl(Me){return typeof Me=="object"&&Me!==null&&typeof Me.byteLength=="number"}function Gt(Me){return fl(Me)?Me.byteLength:1024}function _s(){}function qo(){this.destroy(new Error("Stream aborted."))}function dr(Me){return Me._writev!==Ki.prototype._writev&&Me._writev!==on.prototype._writev}return Qh={pipeline:gs,pipelinePromise:hr,isStream:ur,isStreamx:Nt,isEnded:Bo,isFinished:dl,isDisturbed:ys,getStreamError:ps,Stream:cr,Writable:Ki,Readable:Tn,Duplex:on,Transform:fs,PassThrough:Do},Qh}var Xh,vm;function W1(){if(vm)return Xh;vm=1;const{Readable:n}=Sn(),a=et(),p=po(),l=Buffer.alloc(0);return Xh=class extends n{constructor(y,h={}){const{gt:o=null,gte:c=null,lt:s=null,lte:u=null,reverse:f=!1,values:m=!0,limit:E=1/0,capacity:b=8}=h;super(),y._ref(),this._db=y,this._gt=o?this._encodeKey(o):l,this._gte=c?this._encodeKey(c):l,this._lt=s?this._encodeKey(s):l,this._lte=u?this._encodeKey(u):l,this._reverse=f,this._values=m,this._limit=E<0?1/0:E,this._capacity=b,this._opened=!1,this._pendingOpen=null,this._pendingRead=null,this._pendingDestroy=null,this._buffer=null,this._handle=null,this._db._state.opened===!0&&this.ready()}_onopen(y){const h=this._pendingOpen;this._pendingOpen=null,this._opened=!0,this._db._state.io.dec(),h(y)}_onread(y,h,o){const c=this._pendingRead;if(this._pendingRead=null,this._db._state.io.dec(),y)return c(y);const s=h.length;this._limit-=s;for(let u=0;u<s;u++)this.push({key:this._decodeKey(Buffer.from(h[u])),value:this._values?this._decodeValue(Buffer.from(o[u])):null});s<this._capacity&&this.push(null),c(null)}_onclose(y){const h=this._pendingDestroy;this._pendingDestroy=null,this._db._state.io.dec(),this._db._unref(),h(y)}_resize(){this._handle!==null&&(this._buffer=p.iteratorBuffer(this._handle,this._capacity))}async ready(){this._handle===null&&(this._db._state.opened===!1&&await this._db._state.ready(),this._init())}_init(){this._handle=p.iteratorInit(),this._buffer=p.iteratorBuffer(this._handle,this._capacity)}async _open(y){if(await this.ready(),this._db._state.io.inc(),this._db._state.resumed!==null&&!await this._db._state.resumed.promise)return this._db._state.io.dec(),y(new Error("RocksDB session is closed"));this._pendingOpen=y;try{p.iteratorOpen(this._db._state._handle,this._handle,this._db._columnFamily._handle,this._gt,this._gte,this._lt,this._lte,this._reverse,!this._values,this._db._snapshot?this._db._snapshot._handle:null,this,this._onopen,this._onclose,this._onread)}catch(h){throw this._db._state.io.dec(),h}}async _read(y){if(this._db._state.io.inc(),this._db._state.resumed!==null&&!await this._db._state.resumed.promise)return this._db._state.io.dec(),y(new Error("RocksDB session is closed"));this._pendingRead=y;try{p.iteratorRead(this._handle,Math.min(this._capacity,this._limit))}catch(h){throw this._db._state.io.dec(),h}}async _destroy(y){if(await this.ready(),this._db._state.io.inc(),this._pendingDestroy=y,this._opened===!1)return this._db._state.io.dec(),this._onclose(null);try{p.iteratorClose(this._handle)}catch(h){throw this._db._state.io.dec(),h}}_encodeKey(y){return this._db._keyEncoding!==null?a.encode(this._db._keyEncoding,y):typeof y=="string"?Buffer.from(y):y}_decodeKey(y){return this._db._keyEncoding!==null?a.decode(this._db._keyEncoding,y):y}_decodeValue(y){return this._db._valueEncoding!==null?a.decode(this._db._valueEncoding,y):y}},Xh}var Zh,km;function Q1(){if(km)return Zh;km=1;const n=po();return Zh=class{constructor(p){this._state=p,this._handle=null,this._refs=0,p.deferSnapshotInit===!1&&this._init()}_init(){this._handle=n.snapshotCreate(this._state._handle)}ref(){this._refs++}unref(){--this._refs>0||this._handle!==null&&(n.snapshotDestroy(this._handle),this._handle=null)}},Zh}var $h,Sm;function X1(){return Sm||(Sm=1,$h=class{constructor(){this.count=0,this._onidle=null,this._idle=null}isIdle(){return this.count===0}idle(){return this.count===0?Promise.resolve():this._idle!==null?this._idle:(this._idle=new Promise(a=>{this._onidle=a}),this._idle)}inc(){this.count++}dec(){if(!(--this.count>0)&&this._onidle!==null){const a=this._onidle;this._idle=null,this._onidle=null,a()}}}),$h}var Za={},xm;function Z1(){if(xm)return Za;xm=1;const n=et(),a=po(),p=Buffer.alloc(0),l=Promise.resolve();class g{constructor(u,f={}){const{capacity:m=8,autoDestroy:E=!1}=f;u._ref(),this._db=u,this._destroyed=!1,this._capacity=m,this._operations=[],this._promises=[],this._enqueuePromise=this._enqueuePromise.bind(this),this._request=null,this._resolve=null,this._reject=null,this._handle=null,this._buffer=null,this._autoDestroy=E,u._state.opened===!0&&this.ready()}_reuse(u,f={}){const{autoDestroy:m=!1}=f;u._ref(),this._db=u,this._destroyed=!1,this._autoDestroy=m}_onfinished(u){const f=this._resolve,m=this._reject;this._request&&this._db._state.io.dec(),this._operations=[],this._promises=[],this._request=null,this._resolve=null,this._reject=null,this._autoDestroy===!0&&this.destroy(),m!==null&&u?m(u):f!==null&&f()}_resize(){if(this._operations.length<=this._capacity)return!1;for(;this._operations.length>this._capacity;)this._capacity*=2;return!0}async ready(){this._handle===null&&(this._db._state.opened===!1&&await this._db._state.ready(),this._init())}destroy(){if(this._request)throw new Error("Request in progress");this._destroyed||(this._destroyed=!0,this._promises.length&&this._abort(),this._db._unref(),this._onfree())}_onfree(){this._db._state.freeBatch(this,!1),this._db=null}_abort(){for(let u=0;u<this._promises.length;u++){const f=this._promises[u];f!==null&&f.reject(new Error("Batch is destroyed"))}this._onfinished(new Error("Batch is destroyed"))}async flush(){if(this._request)throw new Error("Request in progress");if(this._destroyed)throw new Error("Batch is destroyed");return this._request=new Promise((u,f)=>{this._resolve=u,this._reject=f}),this._flush(),this._request}tryFlush(){if(this._request)throw new Error("Request in progress");if(this._destroyed)throw new Error("Batch is destroyed");this._request=l,this._flush()}async _flush(){this._handle===null&&await this.ready(),this._db._state.io.inc(),this._db._state.resumed!==null&&(await this._db._state.resumed.promise||(this._destroyed?this._db._state.io.dec():(this._destroyed=!0,this._abort(),this._db._unref())))}_enqueuePromise(u,f){this._promises.push({resolve:u,reject:f})}_encodeKey(u){return this._db._keyEncoding?n.encode(this._db._keyEncoding,u):typeof u=="string"?Buffer.from(u):u}_encodeValue(u){return this._db._valueEncoding?n.encode(this._db._valueEncoding,u):u===null?p:typeof u=="string"?Buffer.from(u):u}_decodeValue(u){return this._db._valueEncoding?n.decode(this._db._valueEncoding,u):u}}Za.ReadBatch=class extends g{_init(){this._handle=a.readInit(),this._buffer=a.readBuffer(this._handle,this._capacity)}_resize(){super._resize()&&this._handle!==null&&(this._buffer=a.readBuffer(this._handle,this._capacity))}async _flush(){if(await super._flush(),!this._destroyed)try{a.read(this._db._state._handle,this._handle,this._operations,this._db._snapshot?this._db._snapshot._handle:null,this,this._onread)}catch(u){throw this._db._state.io.dec(),u}}_onread(u,f){let m=!0;for(let E=0,b=this._promises.length;E<b;E++){const _=this._promises[E];if(_===null)continue;const B=u[E];B?(m=!1,_.reject(new Error(B))):_.resolve(f[E]?this._decodeValue(Buffer.from(f[E])):null)}this._onfinished(m?null:new Error("Batch was not applied"))}get(u){if(this._request)throw new Error("Request already in progress");const f=new Promise(this._enqueuePromise);return this._operations.push(new y(this._encodeKey(u),this._db._columnFamily)),this._resize(),f}},Za.WriteBatch=class extends g{_init(){this._handle=a.writeInit(),this._buffer=a.writeBuffer(this._handle,this._capacity)}_resize(){super._resize()&&this._handle!==null&&(this._buffer=a.writeBuffer(this._handle,this._capacity))}_onfree(){this._db._state.freeBatch(this,!0)}async _flush(){if(await super._flush(),!this._destroyed)try{a.write(this._db._state._handle,this._handle,this._operations,this,this._onwrite)}catch(u){throw this._db._state.io.dec(),u}}_onwrite(u){let f=!0;for(let m=0,E=this._promises.length;m<E;m++){const b=this._promises[m];b!==null&&(u?(f=!1,b.reject(new Error(u))):b.resolve())}this._onfinished(f?null:new Error("Batch was not applied"))}put(u,f){if(this._request)throw new Error("Request already in progress");const m=new Promise(this._enqueuePromise);return this._operations.push(new h(this._encodeKey(u),this._encodeValue(f),this._db._columnFamily)),this._resize(),m}tryPut(u,f){if(this._request)throw new Error("Request already in progress");this._operations.push(new h(this._encodeKey(u),this._encodeValue(f),this._db._columnFamily)),this._promises.push(null),this._resize()}delete(u){if(this._request)throw new Error("Request already in progress");const f=new Promise(this._enqueuePromise);return this._operations.push(new o(this._encodeKey(u),this._db._columnFamily)),this._resize(),f}tryDelete(u){if(this._request)throw new Error("Request already in progress");this._operations.push(new o(this._encodeKey(u),this._db._columnFamily)),this._promises.push(null),this._resize()}deleteRange(u,f){if(this._request)throw new Error("Request already in progress");const m=new Promise(this._enqueuePromise);return this._operations.push(new c(this._encodeKey(u),this._encodeKey(f),this._db._columnFamily)),this._resize(),m}tryDeleteRange(u,f){if(this._request)throw new Error("Request already in progress");this._operations.push(new c(this._encodeKey(u),this._encodeKey(f),this._db._columnFamily)),this._promises.push(null),this._resize()}};class y{constructor(u,f){this.key=u,this.columnFamily=f._handle}get type(){return a.GET}}class h{constructor(u,f,m){this.key=u,this.value=f,this.columnFamily=m._handle}get type(){return a.PUT}}class o{constructor(u,f){this.key=u,this.columnFamily=f._handle}get type(){return a.DELETE}}class c{constructor(u,f,m){this.start=u,this.end=f,this.columnFamily=m._handle}get type(){return a.DELETE_RANGE}}return Za}var Jh,Em;function $1(){if(Em)return Jh;Em=1;const n=Rn(),a=X1(),p=go(),{ReadBatch:l,WriteBatch:g}=Z1(),y=Kv(),h=po(),o=64;return Jh=class extends n{constructor(s,u,f){super();const{columnFamily:m=new y("default",f),columnFamilies:E=[],readOnly:b=!1,createIfMissing:_=!0,createMissingColumnFamilies:B=!0,maxBackgroundJobs:M=6,bytesPerSync:z=1048576,maxOpenFiles:j=-1,useDirectReads:v=!1}=f;this.path=u,this.db=s,this.handles=new a,this.io=new a,this.sessions=[],this.columnFamilies=[m],this.deferSnapshotInit=!0,this.resumed=null,this._suspended=!1,this._suspending=null,this._resuming=null,this._columnsFlushed=!1,this._readBatches=[],this._writeBatches=[];for(const w of E)this.columnFamilies.push(typeof w=="string"?new y(w,f):w);this._handle=h.init(b,_,B,M,z,j,v)}createReadBatch(s,u){if(this._readBatches.length===0)return new l(s,u);const f=this._readBatches.pop();return f._reuse(s,u),f}createWriteBatch(s,u){if(this._writeBatches.length===0)return new g(s,u);const f=this._writeBatches.pop();return f._reuse(s,u),f}freeBatch(s,u){const f=u?this._writeBatches:this._readBatches;f.length>=o||f.push(s)}addSession(s){s._index=this.sessions.push(s)-1,s._snapshot&&s._snapshot.ref()}removeSession(s){const u=this.sessions.pop();u!==s&&(this.sessions[u._index=s._index]=u),s._index=-1,s._snapshot&&s._snapshot.unref()}upsertColumnFamily(s){if(typeof s=="string"){let u=this.getColumnFamilyByName(s);return u||(u=this.columnFamilies[0].cloneSettings(s),this.columnFamilies.push(u),u)}return this.columnFamilies.includes(s)||this.columnFamilies.push(s),s}getColumnFamily(s){if(!s)return this.columnFamilies[0];if(!this._columnsFlushed)return this.upsertColumnFamily(s);if(typeof s!="string")return s;const u=this.getColumnFamilyByName(s);if(u===null)throw new Error("Unknown column family");return u}getColumnFamilyByName(s){for(const u of this.columnFamilies)if(u.name===s)return u;return null}async _open(){await Promise.resolve();const s={resolve:null,reject:null,handle:null},u=new Promise((m,E)=>{s.resolve=m,s.reject=E});this._columnsFlushed=!0,s.handle=h.open(this._handle,this,this.path,this.columnFamilies.map(m=>m._handle),s,f),await u,this.deferSnapshotInit=!1;for(const m of this.sessions)m._snapshot&&m._snapshot._init();function f(m){m?s.reject(new Error(m)):s.resolve()}}async _close(){for(this.resumed&&this.resumed.resolve(!1);!this.io.isIdle();)await this.io.idle();for(;!this.handles.isIdle();)await this.handles.idle();for(;this.sessions.length>0;)await this.sessions[this.sessions.length-1].close();for(const m of this.columnFamilies)m.destroy();const s={resolve:null,reject:null,handle:null},u=new Promise((m,E)=>{s.resolve=m,s.reject=E});s.handle=h.close(this._handle,s,f),await u;function f(m){m?s.reject(new Error(m)):s.resolve()}}async flush(s,u){if(this.opened===!1&&await this.ready(),this.io.inc(),this.resumed!==null&&!await this.resumed.promise)throw this.io.dec(),new Error("RocksDB session is closed");const f={resolve:null,reject:null,handle:null},m=new Promise((b,_)=>{f.resolve=b,f.reject=_});try{f.handle=h.flush(this._handle,s._columnFamily._handle,f,E),await m}finally{this.io.dec()}function E(b){b?f.reject(new Error(b)):f.resolve()}}async suspend(){return this._suspending===null&&(this._suspending=this._suspend()),this._suspending}async _suspend(){if(this.opened===!1&&await this.ready(),this.io.inc(),this._resuming!==null&&await this._resuming,this.io.dec(),this._suspended===!0)return;for(;!this.io.isIdle();)await this.io.idle();this.io.inc(),this.resumed=p();const s={resolve:null,reject:null,handle:null},u=new Promise((m,E)=>{s.resolve=m,s.reject=E});try{s.handle=h.suspend(this._handle,s,f),await u,this._suspended=!0}finally{this.io.dec(),this._suspending=null}function f(m){m?s.reject(new Error(m)):s.resolve()}}resume(){return this._resuming===null&&(this._resuming=this._resume()),this._resuming}async _resume(){if(this.opened===!1&&await this.ready(),this.io.inc(),this._suspending!==null&&await this._suspending,this._suspended===!1)return this.io.dec();const s={resolve:null,reject:null,handle:null},u=new Promise((E,b)=>{s.resolve=E,s.reject=b});try{s.handle=h.resume(this._handle,s,m),await u,this._suspended=!1}finally{this.io.dec(),this._resuming=null}const f=this.resumed;this.resumed=null,f.resolve(!0);function m(E){E?s.reject(new Error(E)):s.resolve()}}},Jh}var Am;function J1(){return Am||(Am=1,function(n,a){const p=Kv(),l=W1(),g=Q1(),y=$1(),{BloomFilterPolicy:h,RibbonFilterPolicy:o}=Iv();class c{constructor(f,m={}){const{columnFamily:E,state:b=new y(this,f,m),snapshot:_=null,keyEncoding:B=null,valueEncoding:M=null}=m;this._state=b,this._snapshot=_,this._columnFamily=b.getColumnFamily(E),this._keyEncoding=B,this._valueEncoding=M,this._index=-1,this._state.addSession(this)}get opened(){return this._state.opened}get closed(){return this.isRoot()?this._state.closed:this._index===-1}get path(){return this._state.path}get snapshotted(){return this._snapshot!==null}get defaultColumnFamily(){return this._columnFamily}session({columnFamily:f=this._columnFamily,snapshot:m=this._snapshot!==null,keyEncoding:E=this._keyEncoding,valueEncoding:b=this._valueEncoding}={}){return s(this),new c(null,{state:this._state,columnFamily:f,snapshot:m?this._snapshot||new g(this._state):null,keyEncoding:E,valueEncoding:b})}columnFamily(f,m){return this.session({...m,columnFamily:f})}snapshot(){return this.session({snapshot:!0})}isRoot(){return this===this._state.db}ready(){return this._state.ready()}async close({force:f}={}){if(this._index!==-1&&this._state.removeSession(this),f)for(;this._state.sessions.length>0;)await this._state.sessions[this._state.sessions.length-1].close();return this.isRoot()?this._state.close():Promise.resolve()}suspend(){return s(this),this._state.suspend()}resume(){return s(this),this._state.resume()}isIdle(){return this._state.handles.isIdle()}idle(){return this._state.handles.idle()}iterator(f,m){return s(this),new l(this,{...f,...m})}async*keys(f,m){for await(const{key:E}of this.iterator(f,{...m,values:!1}))yield E}async peek(f,m){for await(const E of this.iterator({...f,...m,limit:1}))return E;return null}read(f){return s(this),this._state.createReadBatch(this,f)}write(f){return s(this),this._state.createWriteBatch(this,f)}flush(f){return s(this),this._state.flush(this,f)}async get(f,m){const E=this.read({...m,capacity:1,autoDestroy:!0}),b=E.get(f);return E.tryFlush(),b}async put(f,m,E){const b=this.write({...E,capacity:1,autoDestroy:!0});b.tryPut(f,m),await b.flush()}async delete(f,m){const E=this.write({...m,capacity:1,autoDestroy:!0});E.tryDelete(f),await E.flush()}async deleteRange(f,m,E){const b=this.write({...E,capacity:1,autoDestroy:!0});b.tryDeleteRange(f,m),await b.flush()}_ref(){this._snapshot&&this._snapshot.ref(),this._state.handles.inc()}_unref(){this._snapshot&&this._snapshot.unref(),this._state.handles.dec()}}n.exports=a=c,a.ColumnFamily=p,a.BloomFilterPolicy=h,a.RibbonFilterPolicy=o;function s(u){if(u._state.closing||u._index===-1)throw new Error("RocksDB session is closed")}}(Fa,Fa.exports)),Fa.exports}var eu,Rm;function eS(){if(Rm)return eu;Rm=1;let n=null;eu=class{constructor({debounce:l=!1}={}){this.debounce=l,this.waiting=[],this.locked=!1,this.skip=0,this.destroyed=!1}flush(){if(this.locked===!1&&this.waiting.length===0)return Promise.resolve(this.destroyed===!1);const l=new Promise(a),g=n;return n=null,this.waiting.push({lock:!1,resolve:g}),l}destroy(){this.destroyed=!0}lock(){const l=new Promise(a),g=n;return n=null,this.locked===!0?(this.waiting.push({lock:!0,resolve:g}),l):this.destroyed===!0?(g(!1),l):(this.locked=!0,g(!0),l)}unlock(){if(this.destroyed===!0){for(let g=0;g<this.waiting.length;g++)this.waiting[g].resolve(!1);this.waiting=[],this.skip=0,this.locked=!1;return}if(this.skip!==0){for(let g=0;g<this.skip;g++){const{lock:y,resolve:h}=this.waiting[g];h(y===!1)}this.waiting=this.waiting.slice(this.skip),this.skip=0}for(;this.waiting.length>0&&this.waiting[0].lock===!1;)this.waiting.shift().resolve(!0);if(this.waiting.length===0){this.locked=!1;return}const{resolve:l}=this.waiting.shift();this.debounce===!0&&(this.skip=this.waiting.length),l(!0)}};function a(p){n=p}return eu}var $a={},Ft={},tu={},Lm;function zv(){return Lm||(Lm=1,function(n){const{runtime:a,platform:p,arch:l}=typeof Bare<"u"?{runtime:"bare",platform:globalThis.Bare.platform,arch:globalThis.Bare.arch}:typeof process<"u"?{runtime:"node",platform:globalThis.process.platform,arch:globalThis.process.arch}:typeof Window<"u"?{runtime:"browser",platform:"unknown",arch:"unknown"}:{runtime:"unknown",platform:"unknown",arch:"unknown"};n.runtime=a,n.platform=p,n.arch=l,n.isBare=a==="bare",n.isBareKit=n.isBare&&typeof BareKit<"u",n.isPear=n.isBare&&typeof Pear<"u",n.isNode=a==="node",n.isBrowser=a==="browser",n.isWindows=p==="win32",n.isLinux=p==="linux",n.isMac=p==="darwin",n.isIOS=p==="ios"||p==="ios-simulator",n.isAndroid=p==="android",n.isElectron=typeof process<"u"&&!!globalThis.process.versions.electron,n.isElectronRenderer=n.isElectron&&globalThis.process.type==="renderer",n.isElectronWorker=n.isElectron&&globalThis.process.type==="worker"}(tu)),tu}var nu,Tm;function tS(){return Tm||(Tm=1,tn.addon=Pv(),nu=tn.addon(".",__filename)),nu}var Dm;function nS(){if(Dm)return Ft;Dm=1;const{isWindows:n}=zv(),a=tS();function p(l,g){l?this.reject(l):this.resolve(g)}return Ft.tryLock=function(g,y=0,h=0,o={}){typeof y=="object"&&(o=y,y=0),typeof h=="object"&&(o=h,h=0),typeof o!="object"&&(o={});try{a.fs_ext_napi_try_lock(g,y,h,o.shared?0:1)}catch(c){if(c.code==="EAGAIN")return!1;throw c}return!0},Ft.waitForLock=function(g,y=0,h=0,o={}){typeof y=="object"&&(o=y,y=0),typeof h=="object"&&(o=h,h=0),typeof o!="object"&&(o={});const c=Buffer.alloc(a.sizeof_fs_ext_napi_lock_t),s={req:c,resolve:null,reject:null},u=new Promise((f,m)=>{s.resolve=f,s.reject=m});try{a.fs_ext_napi_wait_for_lock(c,g,y,h,o.shared?0:1,s,p)}catch(f){return Promise.reject(f)}return u},Ft.tryDowngradeLock=function(g,y=0,h=0){try{a.fs_ext_napi_try_downgrade_lock(g,y,h)}catch(o){if(o.code==="EAGAIN")return!1;throw o}return!0},Ft.waitForDowngradeLock=function(g,y=0,h=0){const o=Buffer.alloc(a.sizeof_fs_ext_napi_lock_t),c={req:o,resolve:null,reject:null},s=new Promise((u,f)=>{c.resolve=u,c.reject=f});try{a.fs_ext_napi_wait_for_downgrade_lock(o,g,y,h,c,p)}catch(u){return Promise.reject(u)}return s},Ft.tryUpgradeLock=function(g,y=0,h=0){try{a.fs_ext_napi_try_upgrade_lock(g,y,h)}catch(o){if(o.code==="EAGAIN")return!1;throw o}return!0},Ft.waitForUpgradeLock=function(g,y=0,h=0){const o=Buffer.alloc(a.sizeof_fs_ext_napi_lock_t),c={req:o,resolve:null,reject:null},s=new Promise((u,f)=>{c.resolve=u,c.reject=f});try{a.fs_ext_napi_wait_for_upgrade_lock(o,g,y,h,c,p)}catch(u){return Promise.reject(u)}return s},Ft.unlock=function(g,y=0,h=0){a.fs_ext_napi_unlock(g,y,h)},Ft.trim=function(g,y,h){const o=Buffer.alloc(a.sizeof_fs_ext_napi_trim_t),c={req:o,resolve:null,reject:null},s=new Promise((u,f)=>{c.resolve=u,c.reject=f});try{a.fs_ext_napi_trim(o,g,y,h,c,p)}catch(u){return Promise.reject(u)}return s},Ft.sparse=function(g){if(!n)return Promise.resolve();const y=Buffer.alloc(a.sizeof_fs_ext_napi_sparse_t),h={req:y,resolve:null,reject:null},o=new Promise((c,s)=>{h.resolve=c,h.reject=s});try{a.fs_ext_napi_sparse(y,g,h,p)}catch(c){return Promise.reject(c)}return o},Ft.swap=function(g,y){const h=Buffer.alloc(a.sizeof_fs_ext_napi_swap_t),o={req:h,resolve:null,reject:null},c=new Promise((s,u)=>{o.resolve=s,o.reject=u});try{a.fs_ext_napi_swap(h,g,y,o,p)}catch(s){return Promise.reject(s)}return c},Ft.getAttr=function(g,y){const h=Buffer.alloc(a.sizeof_fs_ext_napi_get_attr_t),o={req:h,resolve:null,reject:null},c=new Promise((s,u)=>{o.resolve=s,o.reject=u});try{a.fs_ext_napi_get_attr(h,g,y,o,p)}catch(s){return Promise.reject(s)}return c.then(s=>s===null?null:Buffer.from(s))},Ft.setAttr=function(g,y,h,o){typeof h=="string"&&(h=Buffer.from(h,o));const c=Buffer.alloc(a.sizeof_fs_ext_napi_set_attr_t),s={req:c,value:h,resolve:null,reject:null},u=new Promise((f,m)=>{s.resolve=f,s.reject=m});try{a.fs_ext_napi_set_attr(c,g,y,h,s,p)}catch(f){return Promise.reject(f)}return u},Ft.removeAttr=function(g,y){const h=Buffer.alloc(a.sizeof_fs_ext_napi_remove_attr_t),o={req:h,resolve:null,reject:null},c=new Promise((s,u)=>{o.resolve=s,o.reject=u});try{a.fs_ext_napi_remove_attr(h,g,y,o,p)}catch(s){return Promise.reject(s)}return c},Ft.listAttrs=function(g){const y=Buffer.alloc(a.sizeof_fs_ext_napi_list_attrs_t),h={req:y,resolve:null,reject:null},o=new Promise((c,s)=>{h.resolve=c,h.reject=s});try{a.fs_ext_napi_list_attrs(y,g,h,p)}catch(c){return Promise.reject(c)}return o},Ft}var Bm;function iS(){if(Bm)return $a;Bm=1;const n=nn,a=nS(),p=Ue(),l=globalThis.Bare?globalThis.Bare.platform:globalThis.process.platform,g=l==="win32",y=l==="linux",h=5e3,o=p.alloc(0),c=y?"user.device-file":"device-file",s=g?`\r
`:`
`;$a.create=u,$a.resume=f;async function u(j,v={}){let w="";for(const[U,T]of Object.entries(v))T!==null&&(w+=U+"="+T+s);const R=await z(j,"w"),A=await b(R),q=Date.now();w+="device/platform="+l+s,w+="device/inode="+A.ino+s,w+="device/created="+q+s,await E(R,c,p.from("original"))&&(w+="device/attribute=original"+s),await B(R,p.from(w)),await _(R)}async function f(j,v={}){let w=0;try{w=await z(j,"r")}catch{w=0}if(w===0)return null;const R=await M(w),A={},q=p.toString(R).trim().split(`
`);let U=0,T=0,Q="",le="";for(const P of q){const Z=P.indexOf("=");if(Z===-1)continue;const he=P.slice(0,Z).trim(),se=P.slice(Z+1).trim();switch(he){case"device/platform":le=se;break;case"device/inode":U=Number(se);break;case"device/created":T=Number(se);break;case"device/attribute":Q=se;break;default:A[he]=se;break}}for(const[P,Z]of Object.entries(v))if(Z!==null&&A[P]!==void 0&&A[P]!==""+Z)throw new Error("Invalid device file, "+P+" has changed");const Y=await b(w),oe=await m(w,c);await _(w);const ue=p.toString(oe||o)===Q,O=Math.max(Y.mtime.getTime(),Y.birthtime.getTime());if(le&&le!==l)throw new Error("Invalid device file, was made on different platform");if(!ue)throw new Error("Invalid device file, was moved unsafely");if(Y.ino!==U||T&&Math.abs(O-T)>=h)throw new Error("Invalid device file, was modified");return A}async function m(j,v){try{return await a.getAttr(j,v)}catch{return null}}async function E(j,v,w){try{return await a.setAttr(j,v,w),!0}catch{return!1}}function b(j){return new Promise((v,w)=>{n.fstat(j,(R,A)=>{R&&w(R),v(A)})})}function _(j){return new Promise((v,w)=>{n.close(j,(R,A)=>{R&&w(R),v(A)})})}function B(j,v){return new Promise((w,R)=>{let A=0;q(null,0);function q(U,T){if(U)return R(U);if(A===v.byteLength)return w();A+=T,n.write(j,v,A,v.byteLength-A,A,q)}})}function M(j){const v=p.allocUnsafe(4096);return new Promise((w,R)=>{let A=0;n.read(j,v,0,v.byteLength,0,q);function q(U,T){if(U)return R(U);if(T===0)return w(v.subarray(0,A));A+=T,n.read(j,v,A,v.byteLength-A,A,q)}})}function z(j,v){return new Promise((w,R)=>{n.open(j,v,(A,q)=>{A&&R(A),w(q)})})}return $a}var iu,Nm;function sS(){if(Nm)return iu;Nm=1;const{Readable:n}=Sn();return iu=class extends n{constructor(p){super(),this.error=p}_open(p){p(this.error)}},iu}var su,qm;function Vf(){if(qm)return su;qm=1;const{Readable:n,getStreamError:a}=Sn(),p=sS(),l=Ue();class g extends n{constructor(E,b,_,B,M,z){super(),this.start=b,this.end=_,this.reverse=B,this.changes=M,this.cleared=z,this.change=0,this.range=0,this._stream=E,this._drained=!1,this._stream.on("readable",this._drainMaybe.bind(this)),this._stream.on("error",s),this._stream.on("close",this._onclose.bind(this))}_drainMaybe(){this._drained!==!0&&(this._drained=this._onreadable())}_onclose(){if(this.destroying)return;const E=a(this._stream);if(E!==null){this.destroy(E);return}for(;this.change<this.changes.length;){const b=this.changes[this.change++],_=b[0],B=b[1];B!==null&&this._inRange(_)&&this.push({key:_,value:B})}this.push(null),this._stream=null}_onreadable(){let E=this._stream.read();if(E===null)return!1;let b=!1;do this._push(E)===!0&&(b=!0),E=this._stream.read();while(E!==null);return b}_read(E){this._drained=this._onreadable(),E(null)}_predestroy(){this.stream.destroy()}_push(E){const b=E.key;for(;this.range<this.cleared.length;){const B=this.cleared[this.range];if(this.reverse?l.compare(b,B[0])<0:l.compare(B[2],b)<=0){this.range++;continue}if(l.compare(B[0],b)<=0&&l.compare(b,B[2])<0)return!1;break}let _=!1;for(;this.change<this.changes.length;){const B=this.changes[this.change],M=B[0],z=typeof B[1]=="string"?l.from(B[1]):B[1],j=l.compare(M,E.key);if(j===0)return this.change++,z===null||this._inRange(M)===!1?_:(this.push({key:M,value:z}),!0);if(this.reverse?j>0:j<0){if(this.change++,z===null||this._inRange(M)===!1)continue;this.push({key:M,value:z}),_=!0;continue}return this.push(E),!0}return this.push(E),!0}_inRange(E){return l.compare(this.start,E)<=0&&l.compare(E,this.end)<0}}class y{constructor(){this.indexed=0,this.changes=null,this.cleared=null,this.reverse=!1}update(E,b){if(E.indexed===this.indexed)return;const _=E.map===null?[]:[...E.map.values()],B=E.cleared===null?[]:E.cleared.slice(0),M=b?c:o;_.sort(M),B.sort(M),this.indexed=E.indexed,this.changes=_,this.cleared=B,this.reverse=b}createStream(E,b,_,B){return new g(E,b,_,B,this.reverse===B?this.changes:u(this.changes),this.reverse===B?this.cleared:u(this.cleared))}}class h{constructor(){this.map=null,this.indexed=0,this.changes=null,this.cleared=null,this.overlay=null,this.snap=null,this.readers=0}snapshot(){if(this._attached())return this.snap.snapshot();const E=new h;return E.map=this.map,E.indexed=this.indexed,E.changes=this.changes,E.cleared=this.cleared,this._frozen()||(this.readers++,E.snap=this),E}readStart(){this.snap!==null&&this.readers++}readStop(){this.snap!==null&&--this.readers===0&&this.snap.readers--}size(){return this.changes===null?0:this.changes.length}updated(){return this.changes===null}get(E,b){return this.changes===null?E.get(b):this._indexAndGet(E,b)}reset(){this.indexed=0,this.snap=this.map=this.changes=this.cleared=this.overlay=null}iterator(E,b,_,B){if(f(E))return new p(new Error("RocksDB session is closed"));const M=E.iterator({gte:b,lt:_,reverse:B});return this.changes===null?M:(this._index(),this.overlay===null&&(this.overlay=new y),this.overlay.update(this,B),this.overlay.createStream(M,b,_,B))}_indexAndGet(E,b){this._index();const _=this.map.get(l.toString(b,"hex"));return _===void 0?this.cleared===null?E.get(b):this._readAndMaybeDrop(E,b):Promise.resolve(_[1])}async _readAndMaybeDrop(E,b){const _=this.cleared,B=await E.get(b);if(B===null)return null;for(let M=0;M<_.length;M++){const z=_[M];if(l.compare(z[0],b)<=0&&l.compare(b,z[2])<0)return null}return B}_attached(){return this.snap!==null&&this.changes===this.snap.changes}_frozen(){return this.changes===null||this.snap!==null&&this.changes!==this.snap.changes}_index(){if(this._attached()){this.snap._index(),this.map=this.snap.map,this.cleared=this.snap.cleared,this.indexed=this.snap.indexed;return}if(this.map===null&&(this.map=new Map),this.changes.length!==this.indexed)for(;this.indexed<this.changes.length;){const E=this.changes[this.indexed++];E[2]===null?this.map.set(l.toString(E[0],"hex"),E):this._indexRange(E)}}_indexRange(E){const b=l.toString(E[0],"hex"),_=l.toString(E[2],"hex");for(const[B,M]of this.map)b<=B&&B<_&&this.map.set(B,[M[0],null,null]);this.cleared===null&&(this.cleared=[]),this.cleared.push(E)}apply(E){if(this.snap!==null)throw new Error("Illegal to push changes to a snapshot");if(this.readers!==0&&this.changes!==null&&(this.changes=this.changes.slice(0),this.cleared=this.cleared===null?null:this.cleared.slice(0),this.map=this.map===null?null:new Map([...this.map])),this.changes===null){this.changes=E;return}for(let b=0;b<E.length;b++)this.changes.push(E[b])}static async flush(E,b){if(E===null)return!0;const _=b.write({autoDestroy:!0});for(const[B,M,z]of E)z!==null?_.tryDeleteRange(B,z):M!==null?_.tryPut(B,M):_.tryDelete(B);return await _.flush(),!0}}su=h;function o(m,E){const b=l.compare(m[0],E[0]);return b===0?l.compare(m[2],E[2]):b}function c(m,E){return o(E,m)}function s(){}function u(m){const E=new Array(m.length);for(let b=0;b<m.length;b++)E[E.length-1-b]=m[b];return E}function f(m){return m._state.closing||m._index===-1}return su}var ru,Cm;function Hv(){if(Cm)return ru;Cm=1;const n=Ue(),a=n.alloc(0),p=n.from([255]),l={};l.preencode=function(u,f){f===null&&(f=a);let m=0,E=3;for(;(m=n.indexOf(f,0,m))>-1;)m++,E++;u.end+=f.byteLength+E},l.encode=function(u,f){f===null&&(f=a),u.buffer[u.start++]=0;let m=0,E=0;for(;(E=n.indexOf(f,0,E))>-1;){const _=f.subarray(m,++E);u.buffer.set(_,u.start),u.start+=_.byteLength,u.buffer[u.start++]=2,m=E}const b=f.subarray(m);u.buffer.set(b,u.start),u.start+=b.byteLength,u.buffer[u.start++]=0,u.buffer[u.start++]=1},l.decode=function(u){if(u.start>=u.end)throw new Error("Out of bounds");if(u.buffer[u.start++]!==0)throw new Error("Invalid start of string");let f=null,m=u.start,E=u.start;for(;(E=n.indexOf(u.buffer,0,E))>-1;){const _=++E<u.end?u.buffer[E]:0;if(E++,_===1)break;if(_===2){f===null&&(f=[]),f.push(u.buffer.subarray(m,E-1)),m=E;continue}throw new Error("Unknown value in terminator")}if(E===-1)throw new Error("No terminator found");u.start=E;const b=u.buffer.subarray(m,E-2);return f===null?b:(f.push(b),n.concat(f))};const g={};g.preencode=function(u,f){l.preencode(u,n.from(f||""))},g.encode=function(u,f){l.encode(u,n.from(f||""))},g.decode=function(u,f){return n.toString(l.decode(u))};const y={};y.preencode=function(u,f){u.end+=f<=251?1:f<=65535?3:f<=4294967295?5:f===1/0?1:9},y.encode=function(u,f){if(f===1/0){u.buffer[u.start++]=255;return}if(f<=251){u.buffer[u.start++]=f;return}if(f<=65535){u.buffer[u.start++]=252,u.buffer[u.start++]=f>>>8,u.buffer[u.start++]=f;return}if(f<=4294967295){u.buffer[u.start++]=253,c(u,f);return}if(Number.isSafeInteger(f)){u.buffer[u.start++]=254;const m=Math.floor(f/4294967296);c(u,m),c(u,f);return}throw new Error("Invalid number "+f)},y.decode=function(u){if(u.start>=u.end)throw new Error("Out of bounds");const f=u.buffer[u.start++];if(f<=251)return f;if(f===252){if(u.end-u.start<2)throw new Error("Out of bounds");return u.buffer[u.start++]*256+u.buffer[u.start++]}return f===253?s(u):f===254?s(u)*4294967296+s(u):1/0};const h={};h.preencode=(u,f)=>y.preencode(u,f?1:0),h.encode=(u,f)=>y.encode(u,f?1:0),h.decode=(u,f)=>!!y.decode(u),ru=class{constructor(f,{prefix:m=-1}={}){this.encodings=f,this.prefix=m}static BUFFER=l;static STRING=g;static UINT=y;static BOOL=h;static lookup(f){switch(f){case"uint":return y;case"uint8":return y;case"uint16":return y;case"uint24":return y;case"uint32":return y;case"uint40":return y;case"uint48":return y;case"uint56":return y;case"uint64":return y;case"string":return g;case"utf8":return g;case"ascii":return g;case"hex":return g;case"base64":return g;case"fixed32":return l;case"fixed64":return l;case"buffer":return l;case"bool":return h}throw new Error("Unknown type")}encode(f){return this._encode(f,!1)}_encode(f,m){if(n.isBuffer(f))return f;const E={start:0,end:0,buffer:null};this.prefix!==-1&&y.preencode(E,this.prefix);for(let b=0;b<f.length;b++)this.encodings[b].preencode(E,f[b]);m&&f.length<this.encodings.length&&E.end++,E.buffer=n.allocUnsafe(E.end),this.prefix!==-1&&y.encode(E,this.prefix);for(let b=0;b<f.length;b++)this.encodings[b].encode(E,f[b]);return m&&f.length<this.encodings.length&&(E.buffer[E.start++]=p[0]),E.buffer}decode(f){const m={start:0,end:f.byteLength,buffer:f},E=[];this.prefix!==-1&&y.decode(m);for(const b of this.encodings){const _=m.start<m.end?b.decode(m):b===y?0:null;E.push(_)}return E}encodeRange({gt:f,gte:m,lt:E,lte:b}){const _={gt:f&&this._encode(f,!0),gte:m&&this._encode(m,!1),lt:E&&this._encode(E,!1),lte:b&&this._encode(b,!0)};return this.prefix!==-1&&(!f&&!m&&(_.gte=o(this.prefix)),!E&&!b&&(_.lt=o(this.prefix+1))),_}};function o(u){const f={start:0,end:0,buffer:null};return y.preencode(f,u),f.buffer=n.allocUnsafe(f.end),y.encode(f,u),f.buffer}function c(u,f){u.buffer[u.start++]=f>>>24,u.buffer[u.start++]=f>>>16,u.buffer[u.start++]=f>>>8,u.buffer[u.start++]=f}function s(u,f){if(u.end-u.start<4)throw new Error("Out of bounds");return u.buffer[u.start++]*16777216+u.buffer[u.start++]*65536+u.buffer[u.start++]*256+u.buffer[u.start++]}return ru}var ou,Mm;function al(){if(Mm)return ou;Mm=1;const{UINT:n,STRING:a}=Hv(),p=et(),l=Ue(),g=0,y=1,h=2,o=3,c=4,s=c+1,u=0,f=1,m=0,E=1,b=2,_=3,B=4,M=5,z=6,j=7,v={buffer:l.allocUnsafe(65536),start:0,end:0},w={},R={};w.clear=function(){const q=A();let U=q.start;n.encode(q,0);const T=q.buffer.subarray(U,q.start);U=q.start,n.encode(q,s);const Q=q.buffer.subarray(U,q.start);return[T,Q]},w.head=function(){const q=A(),U=q.start;return n.encode(q,g),q.buffer.subarray(U,q.start)},w.core=function(q){const U=A(),T=U.start;return n.encode(U,y),p.fixed32.encode(U,q),U.buffer.subarray(T,U.start)},w.coreStart=function(){const q=A(),U=q.start;return n.encode(q,y),q.buffer.subarray(U,q.start)},w.coreEnd=function(){const q=A(),U=q.start;return n.encode(q,y+1),q.buffer.subarray(U,q.start)},w.coreByAlias=function({namespace:q,name:U}){const T=A(),Q=T.start;return n.encode(T,h),p.fixed32.encode(T,q),a.encode(T,U),T.buffer.subarray(Q,T.start)},w.coreByAliasStart=function(q){const U=A(),T=U.start;return n.encode(U,h),q&&p.fixed32.encode(U,q),U.buffer.subarray(T,U.start)},w.coreByAliasEnd=function(q){const U=A(),T=U.start;return q?(n.encode(U,h),p.fixed32.encode(U,q),U.buffer[U.start++]=255):n.encode(U,h+1),U.buffer.subarray(T,U.start)},w.alias=function(q){const U={buffer:q,start:0,end:q.byteLength};n.decode(U);const T=p.fixed32.decode(U),Q=a.decode(U);return{namespace:T,name:Q}},w.discoveryKey=function(q){const U={buffer:q,start:0,end:q.byteLength};return n.decode(U),p.fixed32.decode(U)},R.core=function(q){const U=A(),T=U.start;return n.encode(U,o),n.encode(U,q),U.buffer.subarray(T,U.start)},R.data=function(q){const U=A(),T=U.start;return n.encode(U,c),n.encode(U,q),U.buffer.subarray(T,U.start)},R.auth=function(q){const U=A(),T=U.start;return n.encode(U,o),n.encode(U,q),n.encode(U,u),U.buffer.subarray(T,U.start)},R.sessions=function(q){const U=A(),T=U.start;return n.encode(U,o),n.encode(U,q),n.encode(U,f),U.buffer.subarray(T,U.start)},R.head=function(q){const U=A(),T=U.start;return n.encode(U,c),n.encode(U,q),n.encode(U,m),U.buffer.subarray(T,U.start)},R.dependency=function(q){const U=A(),T=U.start;return n.encode(U,c),n.encode(U,q),n.encode(U,E),U.buffer.subarray(T,U.start)},R.hints=function(q){const U=A(),T=U.start;return n.encode(U,c),n.encode(U,q),n.encode(U,b),U.buffer.subarray(T,U.start)},R.block=function(q,U){const T=A(),Q=T.start;return n.encode(T,c),n.encode(T,q),n.encode(T,_),n.encode(T,U),T.buffer.subarray(Q,T.start)},R.tree=function(q,U){const T=A(),Q=T.start;return n.encode(T,c),n.encode(T,q),n.encode(T,B),n.encode(T,U),T.buffer.subarray(Q,T.start)},R.bitfield=function(q,U,T){const Q=A(),le=Q.start;return n.encode(Q,c),n.encode(Q,q),n.encode(Q,M),n.encode(Q,U),n.encode(Q,T),Q.buffer.subarray(le,Q.start)},R.userData=function(q,U){const T=A(),Q=T.start;return n.encode(T,c),n.encode(T,q),n.encode(T,z),a.encode(T,U),T.buffer.subarray(Q,T.start)},R.userDataEnd=function(q){const U=A(),T=U.start;return n.encode(U,c),n.encode(U,q),n.encode(U,z+1),U.buffer.subarray(T,U.start)},R.local=function(q,U){if(U.byteLength>2048)throw new Error("local keys has an upper limit of 2048 bytes atm");const T=A(),Q=T.start;return n.encode(T,c),n.encode(T,q),n.encode(T,j),T.buffer.set(U,T.start),T.start+=U.byteLength,T.buffer.subarray(Q,T.start)},R.localEnd=function(q){const U=A(),T=U.start;return n.encode(U,c),n.encode(U,q),n.encode(U,j+1),U.buffer.subarray(T,U.start)},R.blockIndex=function(q){const U={buffer:q,start:0,end:q.byteLength};return n.decode(U),n.decode(U),n.decode(U),n.decode(U)},R.bitfieldIndexAndType=function(q){const U={buffer:q,start:0,end:q.byteLength};return n.decode(U),n.decode(U),n.decode(U),[n.decode(U),n.decode(U)]},R.userDataKey=function(q){const U={buffer:q,start:0,end:q.byteLength};return n.decode(U),n.decode(U),n.decode(U),a.decode(U)},R.localKey=function(q){const U={buffer:q,start:0,end:q.byteLength};return n.decode(U),n.decode(U),n.decode(U),U.buffer.subarray(U.start,U.end)},ou={store:w,core:R};function A(){return v.buffer.byteLength-v.start<4096&&(v.buffer=l.allocUnsafe(v.buffer.byteLength),v.start=0),v}return ou}var au,Um;function Fv(){if(Um)return au;Um=1;const n=1,{c:a}=If();let p=n;const l={preencode(O,P){a.uint.preencode(O,P.cores),a.uint.preencode(O,P.datas)},encode(O,P){a.uint.encode(O,P.cores),a.uint.encode(O,P.datas)},decode(O){const P=a.uint.decode(O),Z=a.uint.decode(O);return{cores:P,datas:Z}}},g={preencode(O,P){a.uint.preencode(O,P.version),O.end++,P.allocated&&l.preencode(O,P.allocated),P.seed&&a.fixed32.preencode(O,P.seed),P.defaultDiscoveryKey&&a.fixed32.preencode(O,P.defaultDiscoveryKey)},encode(O,P){const Z=(P.allocated?1:0)|(P.seed?2:0)|(P.defaultDiscoveryKey?4:0);a.uint.encode(O,P.version),a.uint.encode(O,Z),P.allocated&&l.encode(O,P.allocated),P.seed&&a.fixed32.encode(O,P.seed),P.defaultDiscoveryKey&&a.fixed32.encode(O,P.defaultDiscoveryKey)},decode(O){const P=a.uint.decode(O),Z=a.uint.decode(O);return{version:P,allocated:(Z&1)!==0?l.decode(O):null,seed:(Z&2)!==0?a.fixed32.decode(O):null,defaultDiscoveryKey:(Z&4)!==0?a.fixed32.decode(O):null}}},y={preencode(O,P){a.string.preencode(O,P.name),a.fixed32.preencode(O,P.namespace)},encode(O,P){a.string.encode(O,P.name),a.fixed32.encode(O,P.namespace)},decode(O){const P=a.string.decode(O),Z=a.fixed32.decode(O);return{name:P,namespace:Z}}},h={preencode(O,P){a.uint.preencode(O,P.version),a.uint.preencode(O,P.corePointer),a.uint.preencode(O,P.dataPointer),O.end++,P.alias&&y.preencode(O,P.alias)},encode(O,P){const Z=P.alias?1:0;a.uint.encode(O,P.version),a.uint.encode(O,P.corePointer),a.uint.encode(O,P.dataPointer),a.uint.encode(O,Z),P.alias&&y.encode(O,P.alias)},decode(O){const P=a.uint.decode(O),Z=a.uint.decode(O),he=a.uint.decode(O),se=a.uint.decode(O);return{version:P,corePointer:Z,dataPointer:he,alias:(se&1)!==0?y.decode(O):null}}},o={blake2b:"blake2b"},c={preencode(O,P){O.end++},encode(O,P){switch(P){case"blake2b":a.uint.encode(O,0);break;default:throw new Error("Unknown enum")}},decode(O){switch(a.uint.decode(O)){case 0:return"blake2b";default:return null}}},s={ed25519:"ed25519"},u={preencode(O,P){O.end++},encode(O,P){switch(P){case"ed25519":a.uint.encode(O,0);break;default:throw new Error("Unknown enum")}},decode(O){switch(a.uint.decode(O)){case 0:return"ed25519";default:return null}}},f={preencode(O,P){a.uint.preencode(O,P.index),a.uint.preencode(O,P.size),a.fixed32.preencode(O,P.hash)},encode(O,P){a.uint.encode(O,P.index),a.uint.encode(O,P.size),a.fixed32.encode(O,P.hash)},decode(O){const P=a.uint.decode(O),Z=a.uint.decode(O),he=a.fixed32.decode(O);return{index:P,size:Z,hash:he}}},m={preencode(O,P){u.preencode(O,P.signature),a.fixed32.preencode(O,P.namespace),a.fixed32.preencode(O,P.publicKey)},encode(O,P){u.encode(O,P.signature),a.fixed32.encode(O,P.namespace),a.fixed32.encode(O,P.publicKey)},decode(O){const P=u.decode(O),Z=a.fixed32.decode(O),he=a.fixed32.decode(O);return{signature:P,namespace:Z,publicKey:he}}},E={preencode(O,P){a.fixed32.preencode(O,P.hash),a.uint.preencode(O,P.length)},encode(O,P){a.fixed32.encode(O,P.hash),a.uint.encode(O,P.length)},decode(O){const P=a.fixed32.decode(O),Z=a.uint.decode(O);return{hash:P,length:Z}}},b=a.array(m),_=a.array(a.fixed32),B={preencode(O,P){a.uint.preencode(O,P.version),O.end++,c.preencode(O,P.hash),a.uint.preencode(O,P.quorum),b.preencode(O,P.signers),P.prologue&&E.preencode(O,P.prologue),P.linked&&_.preencode(O,P.linked),P.userData&&a.buffer.preencode(O,P.userData)},encode(O,P){const Z=(P.allowPatch?1:0)|(P.prologue?2:0)|(P.linked?4:0)|(P.userData?8:0);a.uint.encode(O,P.version),a.uint.encode(O,Z),c.encode(O,P.hash),a.uint.encode(O,P.quorum),b.encode(O,P.signers),P.prologue&&E.encode(O,P.prologue),P.linked&&_.encode(O,P.linked),P.userData&&a.buffer.encode(O,P.userData)},decode(O){const P=a.uint.decode(O),Z=a.uint.decode(O);return{version:P,hash:c.decode(O),quorum:a.uint.decode(O),allowPatch:(Z&1)!==0,signers:b.decode(O),prologue:(Z&2)!==0?E.decode(O):null,linked:(Z&4)!==0?_.decode(O):null,userData:(Z&8)!==0?a.buffer.decode(O):null}}},M={preencode(O,P){a.buffer.preencode(O,P.publicKey),a.buffer.preencode(O,P.secretKey)},encode(O,P){a.buffer.encode(O,P.publicKey),a.buffer.encode(O,P.secretKey)},decode(O){const P=a.buffer.decode(O),Z=a.buffer.decode(O);return{publicKey:P,secretKey:Z}}},z=a.frame(B),j={preencode(O,P){a.fixed32.preencode(O,P.key),a.fixed32.preencode(O,P.discoveryKey),O.end++,P.manifest&&z.preencode(O,P.manifest),P.keyPair&&M.preencode(O,P.keyPair),P.encryptionKey&&a.buffer.preencode(O,P.encryptionKey)},encode(O,P){const Z=(P.manifest?1:0)|(P.keyPair?2:0)|(P.encryptionKey?4:0);a.fixed32.encode(O,P.key),a.fixed32.encode(O,P.discoveryKey),a.uint.encode(O,Z),P.manifest&&z.encode(O,P.manifest),P.keyPair&&M.encode(O,P.keyPair),P.encryptionKey&&a.buffer.encode(O,P.encryptionKey)},decode(O){const P=a.fixed32.decode(O),Z=a.fixed32.decode(O),he=a.uint.decode(O);return{key:P,discoveryKey:Z,manifest:(he&1)!==0?z.decode(O):null,keyPair:(he&2)!==0?M.decode(O):null,encryptionKey:(he&4)!==0?a.buffer.decode(O):null}}},v={preencode(O,P){a.uint.preencode(O,P.fork),a.uint.preencode(O,P.length),a.fixed32.preencode(O,P.rootHash),a.buffer.preencode(O,P.signature)},encode(O,P){a.uint.encode(O,P.fork),a.uint.encode(O,P.length),a.fixed32.encode(O,P.rootHash),a.buffer.encode(O,P.signature)},decode(O){const P=a.uint.decode(O),Z=a.uint.decode(O),he=a.fixed32.decode(O),se=a.buffer.decode(O);return{fork:P,length:Z,rootHash:he,signature:se}}},w={preencode(O,P){O.end++,P.contiguousLength&&a.uint.preencode(O,P.contiguousLength)},encode(O,P){const Z=P.contiguousLength?1:0;a.uint.encode(O,Z),P.contiguousLength&&a.uint.encode(O,P.contiguousLength)},decode(O){return{contiguousLength:(a.uint.decode(O)&1)!==0?a.uint.decode(O):0}}},R={preencode(O,P){a.string.preencode(O,P.name),a.uint.preencode(O,P.dataPointer)},encode(O,P){a.string.encode(O,P.name),a.uint.encode(O,P.dataPointer)},decode(O){const P=a.string.decode(O),Z=a.uint.decode(O);return{name:P,dataPointer:Z}}},A=a.array(R),q={preencode(O,P){a.uint.preencode(O,P.dataPointer),a.uint.preencode(O,P.length)},encode(O,P){a.uint.encode(O,P.dataPointer),a.uint.encode(O,P.length)},decode(O){const P=a.uint.decode(O),Z=a.uint.decode(O);return{dataPointer:P,length:Z}}};function U(O){p=O}function T(O,P,Z=n){return p=Z,a.encode(Y(O),P)}function Q(O,P,Z=n){return p=Z,a.decode(Y(O),P)}function le(O){switch(O){case"@core/hashes":return o;case"@core/signatures":return s;default:throw new Error("Enum not found "+O)}}function Y(O){switch(O){case"@corestore/allocated":return l;case"@corestore/head":return g;case"@corestore/alias":return y;case"@corestore/core":return h;case"@core/hashes":return c;case"@core/signatures":return u;case"@core/tree-node":return f;case"@core/signer":return m;case"@core/prologue":return E;case"@core/manifest":return B;case"@core/keyPair":return M;case"@core/auth":return j;case"@core/head":return v;case"@core/hints":return w;case"@core/session":return R;case"@core/sessions":return A;case"@core/dependency":return q;default:throw new Error("Encoder not found "+O)}}function oe(O,P=n){const Z=Y(O);return{preencode(he,se){p=P,Z.preencode(he,se)},encode(he,se){p=P,Z.encode(he,se)},decode(he){return p=P,Z.decode(he)}}}return au={resolveStruct:oe,getStruct:oe,getEnum:le,getEncoding:Y,encode:T,decode:Q,setVersion:U,version:p},au}var lu={},Om;function rn(){return Om||(Om=1,function(n){n.fullRoots=function(g,y){if(g&1)throw new Error("You can only look up roots for depth(0) blocks");y||(y=[]),g/=2;let h=0,o=1;for(;;){if(!g)return y;for(;o*2<=g;)o*=2;y.push(h+o-1),h=h+2*o,g-=o,o=1}},n.futureRoots=function(g,y){if(g&1)throw new Error("You can only look up future roots for depth(0) blocks");y||(y=[]);let h=1;for(;h*2<=g;)h*=2;if(h*2-2===g)return y;let o=h/2-1;for(;o+h/2-1!==g;){for(o+=h;o+h/2-1>g;)h/=2,o-=h/2;y.push(o-h/2)}return y},n.patch=function(g,y){if(g===0||g>=y)return[];const h=n.fullRoots(g),o=n.fullRoots(y);let c=0;for(;c<o.length&&!(c>=h.length||h[c]!==o[c]);c++);const s=[];if(c<h.length){let u=h.length-1;const f=n.iterator(h[u--]);for(;f.index!==o[c];)f.sibling(),u>=0&&f.index===h[u]?u--:s.push(f.index),s.push(f.parent());c++}for(;c<o.length;c++)s.push(o[c]);return s},n.depth=function(g){let y=0;for(g+=1;!(g&1);)y++,g=p(g);return y},n.sibling=function(g,y){y||(y=n.depth(g));const h=n.offset(g,y);return n.index(y,h&1?h-1:h+1)},n.parent=function(g,y){y||(y=n.depth(g));const h=n.offset(g,y);return n.index(y+1,p(h))},n.leftChild=function(g,y){return g&1?(y||(y=n.depth(g)),n.index(y-1,n.offset(g,y)*2)):-1},n.rightChild=function(g,y){return g&1?(y||(y=n.depth(g)),n.index(y-1,1+n.offset(g,y)*2)):-1},n.children=function(g,y){if(!(g&1))return null;y||(y=n.depth(g));const h=n.offset(g,y)*2;return[n.index(y-1,h),n.index(y-1,h+1)]},n.leftSpan=function(g,y){return g&1?(y||(y=n.depth(g)),n.offset(g,y)*a(y+1)):g},n.rightSpan=function(g,y){return g&1?(y||(y=n.depth(g)),(n.offset(g,y)+1)*a(y+1)-2):g},n.nextLeaf=function(g){let y=1,h=g;for(;(h&1)===1;)h=(h-1)/2,y*=2;return g+y+1},n.count=function(g,y){return g&1?(y||(y=n.depth(g)),a(y+1)-1):1},n.countLeaves=function(g){return(n.count(g)+1)/2},n.spans=function(g,y){if(!(g&1))return[g,g];y||(y=n.depth(g));const h=n.offset(g,y),o=a(y+1);return[h*o,(h+1)*o-2]},n.index=function(g,y){return(1+2*y)*a(g)-1},n.offset=function(g,y){return g&1?(y||(y=n.depth(g)),((g+1)/a(y)-1)/2):g/2},n.iterator=function(g){const y=new l;return y.seek(g||0),y};function a(g){return g<31?1<<g:(1<<30)*(1<<g-30)}function p(g){return(g-(g&1))/2}function l(){this.index=0,this.offset=0,this.factor=0}l.prototype.seek=function(g){this.index=g,this.index&1?(this.offset=n.offset(g),this.factor=a(n.depth(g)+1)):(this.offset=g/2,this.factor=2)},l.prototype.isLeft=function(){return(this.offset&1)===0},l.prototype.isRight=function(){return(this.offset&1)===1},l.prototype.contains=function(g){return g>this.index?g<this.index+this.factor/2:g<this.index?g>this.index-this.factor/2:!0},l.prototype.prev=function(){return this.offset?(this.offset--,this.index-=this.factor,this.index):this.index},l.prototype.next=function(){return this.offset++,this.index+=this.factor,this.index},l.prototype.count=function(){return this.index&1?this.factor-1:1},l.prototype.countLeaves=function(){return(this.count()+1)/2},l.prototype.sibling=function(){return this.isLeft()?this.next():this.prev()},l.prototype.parent=function(){return this.offset&1?(this.index-=this.factor/2,this.offset=(this.offset-1)/2):(this.index+=this.factor/2,this.offset/=2),this.factor*=2,this.index},l.prototype.leftSpan=function(){return this.index=this.index-this.factor/2+1,this.offset=this.index/2,this.factor=2,this.index},l.prototype.rightSpan=function(){return this.index=this.index+this.factor/2-1,this.offset=this.index/2,this.factor=2,this.index},l.prototype.leftChild=function(){return this.factor===2?this.index:(this.factor/=2,this.index-=this.factor/2,this.offset*=2,this.index)},l.prototype.rightChild=function(){return this.factor===2?this.index:(this.factor/=2,this.index+=this.factor/2,this.offset=2*this.offset+1,this.index)},l.prototype.nextTree=function(){return this.index=this.index+this.factor/2+1,this.offset=this.index/2,this.factor=2,this.index},l.prototype.prevTree=function(){return this.offset?(this.index=this.index-this.factor/2-1,this.offset=this.index/2,this.factor=2):(this.index=0,this.factor=2),this.index},l.prototype.fullRoot=function(g){if(g<=this.index||(this.index&1)>0)return!1;for(;g>this.index+this.factor+this.factor/2;)this.index+=this.factor/2,this.factor*=2,this.offset/=2;return!0}}(lu)),lu}var cu,Pm;function Vv(){if(Pm)return cu;Pm=1;const n=Fv(),{store:a,core:p}=al(),l=Vf(),g=Ue(),y=rn(),h=n.getEncoding("@corestore/head"),o=n.getEncoding("@corestore/core"),c=n.getEncoding("@core/auth"),s=n.getEncoding("@core/sessions"),u=n.getEncoding("@core/head"),f=n.getEncoding("@core/tree-node"),m=n.getEncoding("@core/dependency"),E=n.getEncoding("@core/hints");class b{constructor(A,q,U,T){if(q.snapshotted)throw new Error("Cannot open core tx on snapshot");this.core=A,this.db=q,this.view=U,this.changes=T}setAuth(A){this.changes.push([p.auth(this.core.corePointer),w(c,A),null])}setSessions(A){this.changes.push([p.sessions(this.core.corePointer),w(s,A),null])}setHead(A){this.changes.push([p.head(this.core.dataPointer),w(u,A),null])}deleteHead(){this.changes.push([p.head(this.core.dataPointer),null,null])}setDependency(A){this.changes.push([p.dependency(this.core.dataPointer),w(m,A),null])}setHints(A){this.changes.push([p.hints(this.core.dataPointer),w(E,A),null])}putBlock(A,q){this.changes.push([p.block(this.core.dataPointer,A),q,null])}deleteBlock(A){this.changes.push([p.block(this.core.dataPointer,A),null,null])}deleteBlockRange(A,q){this.changes.push([p.block(this.core.dataPointer,A),null,p.block(this.core.dataPointer,q===-1?1/0:q)])}putBitfieldPage(A,q){this.changes.push([p.bitfield(this.core.dataPointer,A,0),q,null])}deleteBitfieldPage(A){this.changes.push([p.bitfield(this.core.dataPointer,A,0),null,null])}deleteBitfieldPageRange(A,q){this.changes.push([p.bitfield(this.core.dataPointer,A,0),null,p.bitfield(this.core.dataPointer,q===-1?1/0:q,0)])}putTreeNode(A){this.changes.push([p.tree(this.core.dataPointer,A.index),w(f,A),null])}deleteTreeNode(A){this.changes.push([p.tree(this.core.dataPointer,A),null,null])}deleteTreeNodeRange(A,q){this.changes.push([p.tree(this.core.dataPointer,A),null,p.tree(this.core.dataPointer,q===-1?1/0:q)])}putUserData(A,q){const U=typeof q=="string"?g.from(q):q;this.changes.push([p.userData(this.core.dataPointer,A),U,null])}deleteUserData(A){this.changes.push([p.userData(this.core.dataPointer,A),null,null])}putLocal(A,q){this.changes.push([p.local(this.core.dataPointer,A),q,null])}deleteLocal(A){this.changes.push([p.local(this.core.dataPointer,A),null,null])}deleteLocalRange(A,q){this.changes.push([p.local(this.core.dataPointer,A),null,q===null?p.localEnd(this.core.dataPointer):p.local(this.core.dataPointer,q)])}flush(){const A=this.changes;return A===null?Promise.resolve(!this.view):(this.changes=null,this.view?(this.view.apply(A),Promise.resolve(!1)):l.flush(A,this.db))}}class _{constructor(A,q,U){this.core=A,this.read=q.read({autoDestroy:!0}),this.view=U,U.readStart()}async getAuth(){return await v(c,await this.view.get(this.read,p.auth(this.core.corePointer)))}async getSessions(){return await v(s,await this.view.get(this.read,p.sessions(this.core.corePointer)))}async getHead(){return await v(u,await this.view.get(this.read,p.head(this.core.dataPointer)))}async getDependency(){return await v(m,await this.view.get(this.read,p.dependency(this.core.dataPointer)))}async getHints(){return await v(E,await this.view.get(this.read,p.hints(this.core.dataPointer)))}getBlock(A){const q=z(this.core.dependencies,A),U=q===null?this.core.dataPointer:q.dataPointer;return this.view.get(this.read,p.block(U,A))}getBitfieldPage(A){return this.view.get(this.read,p.bitfield(this.core.dataPointer,A,0))}async getTreeNode(A){const q=j(this.core.dependencies,A),U=q===null?this.core.dataPointer:q.dataPointer;return v(f,await this.view.get(this.read,p.tree(U,A)))}async hasTreeNode(A){return await this.getTreeNode(A)!==null}getUserData(A){return this.view.get(this.read,p.userData(this.core.dataPointer,A))}getLocal(A){return this.view.get(this.read,p.local(this.core.dataPointer,A))}tryFlush(){this.read.tryFlush(),this._free()}destroy(){this.read.destroy(),this._free()}_free(){this.view!==null&&(this.view.readStop(),this.view=null)}}class B{constructor(A){this.view=A,this.changes=[]}setHead(A){this.changes.push([a.head(),w(h,A),null])}putCore(A,q){this.changes.push([a.core(A),w(o,q),null])}putCoreByAlias(A,q){this.changes.push([a.coreByAlias(A),q,null])}clear(){const[A,q]=a.clear();this.changes.push([A,null,q])}apply(){this.changes!==null&&(this.view.apply(this.changes),this.changes=null)}}class M{constructor(A,q){this.read=A.read({autoDestroy:!0}),this.view=q,q.readStart()}async getHead(){return v(h,await this.view.get(this.read,a.head()))}async getCore(A){return v(o,await this.view.get(this.read,a.core(A)))}getCoreByAlias(A){return this.view.get(this.read,a.coreByAlias(A))}tryFlush(){this.read.tryFlush(),this._free()}destroy(){this.read.destroy(),this._free()}_free(){this.view!==null&&(this.view.readStop(),this.view=null)}}cu={CorestoreTX:B,CorestoreRX:M,CoreTX:b,CoreRX:_};function z(R,A){for(let q=0;q<R.length;q++){const U=R[q];if(A<U.length)return U}return null}function j(R,A){for(let q=0;q<R.length;q++){const U=R[q];if(y.rightSpan(A)<=(U.length-1)*2)return U}return null}function v(R,A){return A===null?null:R.decode({start:0,end:A.byteLength,buffer:A})}function w(R,A){const q={start:0,end:0,buffer:null};return R.preencode(q,A),q.buffer=g.allocUnsafe(q.end),R.encode(q,A),q.buffer}return cu}var hu,Im;function rS(){if(Im)return hu;Im=1;const{Readable:n,getStreamError:a}=Sn(),{core:p}=al();hu=class extends n{constructor(y,h,o,c,s,u){super(),this.core=y,this.db=h,this.updates=o,this.start=c,this.end=s,this.reverse=u===!0,this._drained=!0,this._consumed=0,this._stream=null,this._oncloseBound=this._onclose.bind(this),this._maybeDrainBound=this._maybeDrain.bind(this),this._update()}_update(){if(this._consumed>this.core.dependencies.length)return;const y=this.core.dependencies,h=this._findDependencyIndex(y),o=h<y.length?y[h]:null,c=h>0&&h-1<y.length?y[h-1]:null,s=c&&c.length>this.start?c.length:this.start,u=o&&(this.end===-1||o.length<this.end)?o.length:this.end,f=o?o.dataPointer:this.core.dataPointer;this._makeStream(p.block(f,s),p.block(f,u))}_findDependencyIndex(y){if(!this.reverse)return this._consumed++;let h=y.length-this._consumed++;for(;h>0;){if(y[h-1].length<=this.end)return h;h--,this._consumed++}return 0}_predestroy(){this._stream!==null&&this._stream.destroy()}_read(y){this._drained=this._onreadable(),y(null)}_maybeDrain(){this._drained!==!0&&(this._drained=this._onreadable())}_onreadable(){if(this._stream===null)return this.push(null),!0;let y=this._stream.read();if(y===null)return!1;do this.push(y),y=this._stream.read();while(y!==null);return!0}_onclose(){if(this.destroying)return;const y=a(this._stream);if(y!==null){this.destroy(y);return}this._onreadable()===!0&&(this._drained=!0),this._stream=null,this._update(),this._maybeDrain()}_makeStream(y,h){this._stream=this.updates.iterator(this.db,y,h,this.reverse),this._stream.on("readable",this._maybeDrainBound),this._stream.on("error",l),this._stream.on("close",this._oncloseBound)}};function l(){}return hu}var uu,Km;function oS(){if(Km)return uu;Km=1;const n=Ue(),a=rS(),{core:p,store:l}=al(),g=Fv(),y=g.getEncoding("@corestore/core"),h=g.getEncoding("@core/tree-node"),o=n.alloc(0);uu={createBlockStream:m,createBitfieldStream:E,createUserDataStream:_,createCoreStream:c,createAliasStream:u,createDiscoveryKeyStream:s,createTreeNodeStream:b,createLocalStream:B};function c(T,Q){const le=l.coreStart(),Y=l.coreEnd(),oe=Q.iterator(T,le,Y,!1);return oe._readableState.map=v,oe}function s(T,Q,le){const Y=le?l.coreByAliasStart(le):l.coreStart(),oe=le?l.coreByAliasEnd(le):l.coreEnd(),ue=Q.iterator(T,Y,oe,!1);return ue._readableState.map=le?R:w,ue}function u(T,Q,le){const Y=l.coreByAliasStart(le),oe=l.coreByAliasEnd(le),ue=Q.iterator(T,Y,oe,!1);return ue._readableState.map=A,ue}function f(T,Q,le,Y,oe,ue){if(T.dependencies.length>0)return new a(T,Q,le,Y,oe,ue);const O=p.block(T.dataPointer,Y),P=p.block(T.dataPointer,oe===-1?1/0:oe);return le.iterator(Q,O,P,ue)}function m(T,Q,le,{gt:Y=-1,gte:oe=Y+1,lte:ue=-1,lt:O=ue===-1?-1:ue+1,reverse:P=!1}={}){const Z=f(T,Q,le,oe,O,P);return Z._readableState.map=q,Z}function E(T,Q,le,{gt:Y=-1,gte:oe=Y+1,lte:ue=-1,lt:O=ue===-1?-1:ue+1,reverse:P=!1}={}){const Z=p.bitfield(T.dataPointer,oe,0),he=p.bitfield(T.dataPointer,O===-1?1/0:O,0),se=le.iterator(Q,Z,he,!1);return se._readableState.map=M,se}function b(T,Q,le,{gt:Y=-1,gte:oe=Y+1,lte:ue=-1,lt:O=ue===-1?-1:ue+1,reverse:P=!1}={}){const Z=p.tree(T.dataPointer,oe,0),he=p.tree(T.dataPointer,O===-1?1/0:O,0),se=le.iterator(Q,Z,he,!1);return se._readableState.map=U,se}function _(T,Q,le,{gt:Y=null,gte:oe="",lte:ue=null,lt:O=null,reverse:P=!1}={}){if(Y!==null||ue!==null)throw new Error("gt and lte not yet supported for user data streams");const Z=p.userData(T.dataPointer,oe),he=O===null?p.userDataEnd(T.dataPointer):p.userData(T.dataPointer,O),se=le.iterator(Q,Z,he,!1);return se._readableState.map=j,se}function B(T,Q,le,{gt:Y=null,gte:oe=o,lte:ue=null,lt:O=null,reverse:P=!1}={}){if(Y!==null||ue!==null)throw new Error("gt and lte not yet supported for local streams");const Z=p.local(T.dataPointer,oe),he=O===null?p.localEnd(T.dataPointer):p.local(T.dataPointer,O),se=le.iterator(Q,Z,he,!1);return se._readableState.map=z,se}function M(T){const[Q,le]=p.bitfieldIndexAndType(T.key);return le!==0?null:{index:Q,page:T.value}}function z(T){return{key:p.localKey(T.key),value:T.value}}function j(T){return{key:p.userDataKey(T.key),value:T.value}}function v(T){const Q=l.discoveryKey(T.key),le=y.decode({start:0,end:T.value.byteLength,buffer:T.value});return{discoveryKey:Q,core:le}}function w(T){return l.discoveryKey(T.key)}function R(T){return T.value}function A(T){return{alias:l.alias(T.key),discoveryKey:T.value}}function q(T){return{index:p.blockIndex(T.key),value:T.value}}function U(T){return h.decode({start:0,end:T.value.byteLength,buffer:T.value})}return uu}var rs={},zm;function aS(){if(zm)return rs;zm=1;const n=et(),a=Ue(),p=a.alloc(0),l=a.from("4144eea531e483d54e0c14f4ca68e0644f355343ff6fcb0f005200e12cd747cb","hex"),g={preencode(S,N){S.end++},encode(S,N){if(N==="blake2b"){n.uint.encode(S,0);return}throw new Error("Unknown hash: "+N)},decode(S){const N=n.uint.decode(S);if(N===0)return"blake2b";throw new Error("Unknown hash id: "+N)}},y={preencode(S,N){S.end++},encode(S,N){if(N==="ed25519"){n.uint.encode(S,0);return}throw new Error("Unknown signature: "+N)},decode(S){const N=n.uint.decode(S);if(N===0)return"ed25519";throw new Error("Unknown signature id: "+N)}},h={preencode(S,N){y.preencode(S,N.signature),n.fixed32.preencode(S,N.namespace),n.fixed32.preencode(S,N.publicKey)},encode(S,N){y.encode(S,N.signature),n.fixed32.encode(S,N.namespace),n.fixed32.encode(S,N.publicKey)},decode(S){return{signature:y.decode(S),namespace:n.fixed32.decode(S),publicKey:n.fixed32.decode(S)}}},o=n.array(h),c={preencode(S,N){n.fixed32.preencode(S,N.hash),n.uint.preencode(S,N.length)},encode(S,N){n.fixed32.encode(S,N.hash),n.uint.encode(S,N.length)},decode(S){return{hash:n.fixed32.decode(S),length:n.uint.decode(S)}}},s={preencode(S,N){if(g.preencode(S,N.hash),S.end++,N.prologue&&N.signers.length===0){n.fixed32.preencode(S,N.prologue.hash);return}N.quorum===1&&N.signers.length===1&&!N.allowPatch?h.preencode(S,N.signers[0]):(S.end++,n.uint.preencode(S,N.quorum),o.preencode(S,N.signers))},encode(S,N){if(g.encode(S,N.hash),N.prologue&&N.signers.length===0){n.uint.encode(S,0),n.fixed32.encode(S,N.prologue.hash);return}N.quorum===1&&N.signers.length===1&&!N.allowPatch?(n.uint.encode(S,1),h.encode(S,N.signers[0])):(n.uint.encode(S,2),n.uint.encode(S,N.allowPatch?1:0),n.uint.encode(S,N.quorum),o.encode(S,N.signers))},decode(S){const N=g.decode(S),D=n.uint.decode(S);if(D>2)throw new Error("Unknown type: "+D);if(D===0)return{version:0,hash:N,allowPatch:!1,quorum:0,signers:[],prologue:{hash:n.fixed32.decode(S),length:0}};if(D===1)return{version:0,hash:N,allowPatch:!1,quorum:1,signers:[h.decode(S)],prologue:null};const H=n.uint.decode(S);return{version:0,hash:N,allowPatch:(H&1)!==0,quorum:n.uint.decode(S),signers:o.decode(S),prologue:null}}},u=rs.manifest={preencode(S,N){if(S.end++,N.version===0)return s.preencode(S,N);S.end++,g.preencode(S,N.hash),n.uint.preencode(S,N.quorum),o.preencode(S,N.signers),N.prologue&&c.preencode(S,N.prologue)},encode(S,N){if(n.uint.encode(S,N.version),N.version===0)return s.encode(S,N);n.uint.encode(S,(N.allowPatch?1:0)|(N.prologue?2:0)|(N.unencrypted?4:0)),g.encode(S,N.hash),n.uint.encode(S,N.quorum),o.encode(S,N.signers),N.prologue&&c.encode(S,N.prologue)},decode(S){const N=n.uint.decode(S);if(N===0)return s.decode(S);if(N!==1)throw new Error("Unknown version: "+N);const D=n.uint.decode(S),H=g.decode(S),_e=n.uint.decode(S),ce=o.decode(S),J=(D&4)!==0;return{version:1,hash:H,allowPatch:(D&1)!==0,quorum:_e,signers:ce,prologue:(D&2)===0?null:c.decode(S),unencrypted:J}}},f={preencode(S,N){n.uint.preencode(S,N.index),n.uint.preencode(S,N.size),n.fixed32.preencode(S,N.hash)},encode(S,N){n.uint.encode(S,N.index),n.uint.encode(S,N.size),n.fixed32.encode(S,N.hash)},decode(S){return{index:n.uint.decode(S),size:n.uint.decode(S),hash:n.fixed32.decode(S)}}},m=n.array(f),E=rs.wire={};E.handshake={preencode(S,N){n.uint.preencode(S,1),n.fixed32.preencode(S,N.capability)},encode(S,N){n.uint.encode(S,N.seeks?1:0),n.fixed32.encode(S,N.capability)},decode(S){return{seeks:(n.uint.decode(S)&1)!==0,capability:n.fixed32.decode(S)}}};const b={preencode(S,N){n.uint.preencode(S,N.index),n.uint.preencode(S,N.nodes)},encode(S,N){n.uint.encode(S,N.index),n.uint.encode(S,N.nodes)},decode(S){return{index:n.uint.decode(S),nodes:n.uint.decode(S)}}},_={preencode(S,N){n.uint.preencode(S,N.bytes),n.uint.preencode(S,N.padding)},encode(S,N){n.uint.encode(S,N.bytes),n.uint.encode(S,N.padding)},decode(S){return{bytes:n.uint.decode(S),padding:n.uint.decode(S)}}},B={preencode(S,N){n.uint.preencode(S,N.start),n.uint.preencode(S,N.length)},encode(S,N){n.uint.encode(S,N.start),n.uint.encode(S,N.length)},decode(S){return{start:n.uint.decode(S),length:n.uint.decode(S)}}};E.request={preencode(S,N){S.end++,n.uint.preencode(S,N.id),n.uint.preencode(S,N.fork),N.block&&b.preencode(S,N.block),N.hash&&b.preencode(S,N.hash),N.seek&&_.preencode(S,N.seek),N.upgrade&&B.preencode(S,N.upgrade),N.priority&&n.uint.preencode(S,N.priority)},encode(S,N){const D=(N.block?1:0)|(N.hash?2:0)|(N.seek?4:0)|(N.upgrade?8:0)|(N.manifest?16:0)|(N.priority?32:0);n.uint.encode(S,D),n.uint.encode(S,N.id),n.uint.encode(S,N.fork),N.block&&b.encode(S,N.block),N.hash&&b.encode(S,N.hash),N.seek&&_.encode(S,N.seek),N.upgrade&&B.encode(S,N.upgrade),N.priority&&n.uint.encode(S,N.priority)},decode(S){const N=n.uint.decode(S);return{id:n.uint.decode(S),fork:n.uint.decode(S),block:N&1?b.decode(S):null,hash:N&2?b.decode(S):null,seek:N&4?_.decode(S):null,upgrade:N&8?B.decode(S):null,manifest:(N&16)!==0,priority:N&32?n.uint.decode(S):0}}},E.cancel={preencode(S,N){n.uint.preencode(S,N.request)},encode(S,N){n.uint.encode(S,N.request)},decode(S,N){return{request:n.uint.decode(S)}}};const M={preencode(S,N){n.uint.preencode(S,N.start),n.uint.preencode(S,N.length),m.preencode(S,N.nodes),m.preencode(S,N.additionalNodes),n.buffer.preencode(S,N.signature)},encode(S,N){n.uint.encode(S,N.start),n.uint.encode(S,N.length),m.encode(S,N.nodes),m.encode(S,N.additionalNodes),n.buffer.encode(S,N.signature)},decode(S){return{start:n.uint.decode(S),length:n.uint.decode(S),nodes:m.decode(S),additionalNodes:m.decode(S),signature:n.buffer.decode(S)}}},z={preencode(S,N){n.uint.preencode(S,N.bytes),m.preencode(S,N.nodes)},encode(S,N){n.uint.encode(S,N.bytes),m.encode(S,N.nodes)},decode(S){return{bytes:n.uint.decode(S),nodes:m.decode(S)}}},j={preencode(S,N){n.uint.preencode(S,N.index),n.buffer.preencode(S,N.value),m.preencode(S,N.nodes)},encode(S,N){n.uint.encode(S,N.index),n.buffer.encode(S,N.value),m.encode(S,N.nodes)},decode(S){return{index:n.uint.decode(S),value:n.buffer.decode(S)||p,nodes:m.decode(S)}}},v={preencode(S,N){n.uint.preencode(S,N.index),m.preencode(S,N.nodes)},encode(S,N){n.uint.encode(S,N.index),m.encode(S,N.nodes)},decode(S){return{index:n.uint.decode(S),nodes:m.decode(S)}}};E.data={preencode(S,N){S.end++,n.uint.preencode(S,N.request),n.uint.preencode(S,N.fork),N.block&&j.preencode(S,N.block),N.hash&&v.preencode(S,N.hash),N.seek&&z.preencode(S,N.seek),N.upgrade&&M.preencode(S,N.upgrade),N.manifest&&u.preencode(S,N.manifest)},encode(S,N){const D=(N.block?1:0)|(N.hash?2:0)|(N.seek?4:0)|(N.upgrade?8:0)|(N.manifest?16:0);n.uint.encode(S,D),n.uint.encode(S,N.request),n.uint.encode(S,N.fork),N.block&&j.encode(S,N.block),N.hash&&v.encode(S,N.hash),N.seek&&z.encode(S,N.seek),N.upgrade&&M.encode(S,N.upgrade),N.manifest&&u.encode(S,N.manifest)},decode(S){const N=n.uint.decode(S);return{request:n.uint.decode(S),fork:n.uint.decode(S),block:N&1?j.decode(S):null,hash:N&2?v.decode(S):null,seek:N&4?z.decode(S):null,upgrade:N&8?M.decode(S):null,manifest:N&16?u.decode(S):null}}},E.noData={preencode(S,N){n.uint.preencode(S,N.request)},encode(S,N){n.uint.encode(S,N.request)},decode(S,N){return{request:n.uint.decode(S)}}},E.want={preencode(S,N){n.uint.preencode(S,N.start),n.uint.preencode(S,N.length)},encode(S,N){n.uint.encode(S,N.start),n.uint.encode(S,N.length)},decode(S){return{start:n.uint.decode(S),length:n.uint.decode(S)}}},E.unwant={preencode(S,N){n.uint.preencode(S,N.start),n.uint.preencode(S,N.length)},encode(S,N){n.uint.encode(S,N.start),n.uint.encode(S,N.length)},decode(S,N){return{start:n.uint.decode(S),length:n.uint.decode(S)}}},E.range={preencode(S,N){S.end++,n.uint.preencode(S,N.start),N.length!==1&&n.uint.preencode(S,N.length)},encode(S,N){n.uint.encode(S,(N.drop?1:0)|(N.length===1?2:0)),n.uint.encode(S,N.start),N.length!==1&&n.uint.encode(S,N.length)},decode(S){const N=n.uint.decode(S);return{drop:(N&1)!==0,start:n.uint.decode(S),length:(N&2)!==0?1:n.uint.decode(S)}}},E.bitfield={preencode(S,N){n.uint.preencode(S,N.start),n.uint32array.preencode(S,N.bitfield)},encode(S,N){n.uint.encode(S,N.start),n.uint32array.encode(S,N.bitfield)},decode(S,N){return{start:n.uint.decode(S),bitfield:n.uint32array.decode(S)}}},E.sync={preencode(S,N){S.end++,n.uint.preencode(S,N.fork),n.uint.preencode(S,N.length),n.uint.preencode(S,N.remoteLength)},encode(S,N){n.uint.encode(S,(N.canUpgrade?1:0)|(N.uploading?2:0)|(N.downloading?4:0)|(N.hasManifest?8:0)),n.uint.encode(S,N.fork),n.uint.encode(S,N.length),n.uint.encode(S,N.remoteLength)},decode(S){const N=n.uint.decode(S);return{fork:n.uint.decode(S),length:n.uint.decode(S),remoteLength:n.uint.decode(S),canUpgrade:(N&1)!==0,uploading:(N&2)!==0,downloading:(N&4)!==0,hasManifest:(N&8)!==0}}},E.reorgHint={preencode(S,N){n.uint.preencode(S,N.from),n.uint.preencode(S,N.to),n.uint.preencode(S,N.ancestors)},encode(S,N){n.uint.encode(S,N.from),n.uint.encode(S,N.to),n.uint.encode(S,N.ancestors)},decode(S){return{from:n.uint.encode(S),to:n.uint.encode(S),ancestors:n.uint.encode(S)}}},E.extension={preencode(S,N){n.string.preencode(S,N.name),n.raw.preencode(S,N.message)},encode(S,N){n.string.encode(S,N.name),n.raw.encode(S,N.message)},decode(S){return{name:n.string.decode(S),message:n.raw.decode(S)}}};const w={preencode(S,N){n.string.preencode(S,N.key),n.buffer.preencode(S,N.value)},encode(S,N){n.string.encode(S,N.key),n.buffer.encode(S,N.value)},decode(S){return{key:n.string.decode(S),value:n.buffer.decode(S)}}},R={preencode(S,N){n.uint.preencode(S,N.fork),n.uint.preencode(S,N.ancestors),n.uint.preencode(S,N.length),n.buffer.preencode(S,N.signature)},encode(S,N){n.uint.encode(S,N.fork),n.uint.encode(S,N.ancestors),n.uint.encode(S,N.length),n.buffer.encode(S,N.signature)},decode(S){return{fork:n.uint.decode(S),ancestors:n.uint.decode(S),length:n.uint.decode(S),signature:n.buffer.decode(S)}}},A={preencode(S,N){S.end++,n.uint.preencode(S,N.start),n.uint.preencode(S,N.length)},encode(S,N){S.buffer[S.start++]=N.drop?1:0,n.uint.encode(S,N.start),n.uint.encode(S,N.length)},decode(S){return{drop:(n.uint.decode(S)&1)!==0,start:n.uint.decode(S),length:n.uint.decode(S)}}},q=rs.oplog={};q.entry={preencode(S,N){S.end++,N.userData&&w.preencode(S,N.userData),N.treeNodes&&m.preencode(S,N.treeNodes),N.treeUpgrade&&R.preencode(S,N.treeUpgrade),N.bitfield&&A.preencode(S,N.bitfield)},encode(S,N){const D=S.start++;let H=0;N.userData&&(H|=1,w.encode(S,N.userData)),N.treeNodes&&(H|=2,m.encode(S,N.treeNodes)),N.treeUpgrade&&(H|=4,R.encode(S,N.treeUpgrade)),N.bitfield&&(H|=8,A.encode(S,N.bitfield)),S.buffer[D]=H},decode(S){const N=n.uint.decode(S);return{userData:(N&1)!==0?w.decode(S):null,treeNodes:(N&2)!==0?m.decode(S):null,treeUpgrade:(N&4)!==0?R.decode(S):null,bitfield:(N&8)!==0?A.decode(S):null}}};const U={preencode(S,N){n.buffer.preencode(S,N.publicKey),n.buffer.preencode(S,N.secretKey)},encode(S,N){n.buffer.encode(S,N.publicKey),n.buffer.encode(S,N.secretKey)},decode(S){return{publicKey:n.buffer.decode(S),secretKey:n.buffer.decode(S)}}},T={preencode(S,N){n.uint.preencode(S,N.from),n.uint.preencode(S,N.to),n.uint.preencode(S,N.ancestors)},encode(S,N){n.uint.encode(S,N.from),n.uint.encode(S,N.to),n.uint.encode(S,N.ancestors)},decode(S){return{from:n.uint.decode(S),to:n.uint.decode(S),ancestors:n.uint.decode(S)}}},Q=n.array(T),le={preencode(S,N){Q.preencode(S,N.reorgs),n.uint.preencode(S,N.contiguousLength)},encode(S,N){Q.encode(S,N.reorgs),n.uint.encode(S,N.contiguousLength)},decode(S){return{reorgs:Q.decode(S),contiguousLength:S.start<S.end?n.uint.decode(S):0}}},Y={preencode(S,N){n.uint.preencode(S,N.fork),n.uint.preencode(S,N.length),n.buffer.preencode(S,N.rootHash),n.buffer.preencode(S,N.signature)},encode(S,N){n.uint.encode(S,N.fork),n.uint.encode(S,N.length),n.buffer.encode(S,N.rootHash),n.buffer.encode(S,N.signature)},decode(S){return{fork:n.uint.decode(S),length:n.uint.decode(S),rootHash:n.buffer.decode(S),signature:n.buffer.decode(S)}}},oe={preencode(S,N){n.string.preencode(S,N.tree),n.string.preencode(S,N.bitfield),n.string.preencode(S,N.signer)},encode(S,N){n.string.encode(S,N.tree),n.string.encode(S,N.bitfield),n.string.encode(S,N.signer)},decode(S){return{tree:n.string.decode(S),bitfield:n.string.decode(S),signer:n.string.decode(S)}}},ue={preencode(S,N){n.uint.preencode(S,N.start),n.uint.preencode(S,N.length)},encode(S,N){n.uint.encode(S,N.start),n.uint.encode(S,N.length)},decode(S){return{start:n.uint.decode(S),length:n.uint.decode(S)}}},O=n.array(w);q.header={preencode(S,N){if(S.end+=2,N.external){ue.preencode(S,N.external);return}n.fixed32.preencode(S,N.key),N.manifest&&u.preencode(S,N.manifest),N.keyPair&&U.preencode(S,N.keyPair),O.preencode(S,N.userData),Y.preencode(S,N.tree),le.preencode(S,N.hints)},encode(S,N){if(n.uint.encode(S,1),N.external){n.uint.encode(S,1),ue.encode(S,N.external);return}n.uint.encode(S,(N.manifest?2:0)|(N.keyPair?4:0)),n.fixed32.encode(S,N.key),N.manifest&&u.encode(S,N.manifest),N.keyPair&&U.encode(S,N.keyPair),O.encode(S,N.userData),Y.encode(S,N.tree),le.encode(S,N.hints)},decode(S){const N=n.uint.decode(S);if(N>1)throw new Error("Invalid header version. Expected <= 1, got "+N);if(N===0){const H={types:oe.decode(S),userData:O.decode(S),tree:Y.decode(S),signer:U.decode(S),hints:le.decode(S)};return{external:null,key:H.signer.publicKey,manifest:{version:0,hash:H.types.tree,allowPatch:!1,quorum:1,signers:[{signature:H.types.signer,namespace:l,publicKey:H.signer.publicKey}],prologue:null},keyPair:H.signer.secretKey?H.signer:null,userData:H.userData,tree:H.tree,hints:H.hints}}const D=n.uint.decode(S);return D&1?{external:ue.decode(S),key:null,manifest:null,keyPair:null,userData:null,tree:null,hints:null}:{external:null,key:n.fixed32.decode(S),manifest:(D&2)!==0?u.decode(S):null,keyPair:(D&4)!==0?U.decode(S):null,userData:O.decode(S),tree:Y.decode(S),hints:le.decode(S)}}};const P=n.array(n.uint),Z={preencode(S,N){n.uint.preencode(S,N.signer),n.fixed64.preencode(S,N.signature),n.uint.preencode(S,N.patch)},encode(S,N){n.uint.encode(S,N.signer),n.fixed64.encode(S,N.signature),n.uint.encode(S,N.patch)},decode(S){return{signer:n.uint.decode(S),signature:n.fixed64.decode(S),patch:n.uint.decode(S)}}},he={preencode(S,N){n.uint.preencode(S,N.start),n.uint.preencode(S,N.length),P.preencode(S,N.nodes)},encode(S,N){n.uint.encode(S,N.start),n.uint.encode(S,N.length),P.encode(S,N.nodes)},decode(S){return{start:n.uint.decode(S),length:n.uint.decode(S),nodes:P.decode(S)}}},se={preencode(S,N){S.end++,n.uint.preencode(S,N.signer),n.fixed64.preencode(S,N.signature),N.patch&&he.preencode(S,N.patch)},encode(S,N){n.uint.encode(S,N.patch?1:0),n.uint.encode(S,N.signer),n.fixed64.encode(S,N.signature),N.patch&&he.encode(S,N.patch)},decode(S){const N=n.uint.decode(S);return{signer:n.uint.decode(S),signature:n.fixed64.decode(S),patch:N&1?he.decode(S):null}}},G=n.array(se),re=n.array(Z),W={preencode(S,N){n.uint.preencode(S,N.index),n.uint.preencode(S,N.size),n.fixed32.preencode(S,N.hash)},encode(S,N){n.uint.encode(S,N.index),n.uint.encode(S,N.size),n.fixed32.encode(S,N.hash)},decode(S){return{index:n.uint.decode(S),size:n.uint.decode(S),hash:n.fixed32.decode(S)}}},$=n.array(W);return rs.multiSignaturev0={preencode(S,N){G.preencode(S,N.proofs),$.preencode(S,N.patch)},encode(S,N){G.encode(S,N.proofs),$.encode(S,N.patch)},decode(S){return{proofs:G.decode(S),patch:$.decode(S)}}},rs.multiSignature={preencode(S,N){re.preencode(S,N.proofs),$.preencode(S,N.patch)},encode(S,N){re.encode(S,N.proofs),$.encode(S,N.patch)},decode(S){return{proofs:re.decode(S),patch:$.decode(S)}}},rs}var du,Hm;function Fm(){if(Hm)return du;Hm=1;const n=nn,a=nn,{Readable:p}=Sn(),l=Ue(),g=rn(),y=_t(),h=et(),o=aS(),c=Vf(),{CorestoreTX:s,CoreTX:u,CorestoreRX:f}=Vv(),m=l.alloc(40),E=l.alloc(4096);let b=null,_=null,B=null;class M extends p{constructor(H){super(),this.storage=H,this.stack=[]}async _open(H){for(const _e of await he(a.join(this.storage,"cores")))for(const ce of await he(a.join(this.storage,"cores",_e)))for(const J of await he(a.join(this.storage,"cores",_e,ce)))this.stack.push(a.join(this.storage,"cores",_e,ce,J));H(null)}async _read(H){for(;;){const _e=this.stack.pop();if(!_e){this.push(null);break}const ce=a.join(_e,"oplog"),J=await S(ce);if(J){this.push(J);break}}H(null)}}function z(D){h.uint32.decode(D);const H=h.uint32.decode(D),_e=H>>2,ce=H&1,J=H&2;if(D.end-D.start<_e)return null;const d=D.start+_e,k={header:ce,partial:J!==0,byteLength:_e+8,message:null};try{k.message=o.oplog.header.decode({start:D.start,end:d,buffer:D.buffer})}catch{return null}return D.start=d,k}function j(D){if(D.end-D.start<8)return null;h.uint32.decode(D);const H=h.uint32.decode(D),_e=H>>>2,ce=H&1,J=H&2;if(D.end-D.start<_e)return null;const d=D.start+_e,k={header:ce,partial:J!==0,byteLength:_e+8,message:null};try{k.message=o.oplog.entry.decode({start:D.start,end:d,buffer:D.buffer})}catch{return null}return D.start=d,k}du={store:v,core:A};async function v(D,{version:H,dryRun:_e=!0,gc:ce=!0}){const J=new M(D.path),d=new c,k=new s(d),X=await D._getHead(d),ie=a.join(D.path,"primary-key"),I=await G(ie);X.seed||(X.seed=I);for await(const L of J){const V=L.header.key,te=y.discoveryKey(L.header.key),de=T(L.path);X.defaultDiscoveryKey===null&&(X.defaultDiscoveryKey=te);const C={version:0,corePointer:X.allocated.cores++,dataPointer:X.allocated.datas++,alias:null},ee={version:0,corePointer:C.corePointer,dataPointer:C.dataPointer,dependencies:[]},fe=new u(ee,D.db,d,[]),ve=new Map,we=new Map,F={key:V,discoveryKey:te,manifest:L.header.manifest,keyPair:L.header.keyPair,encryptionKey:null},ne={length:0,fork:0,rootHash:null,signature:null};L.header.tree&&L.header.tree.length&&(ne.length=L.header.tree.length,ne.fork=L.header.tree.fork,ne.rootHash=L.header.tree.rootHash,ne.signature=L.header.tree.signature);for(const{key:me,value:Ee}of L.header.userData)ve.set(me,Ee);for(const me of L.entries){if(me.userData&&ve.set(me.userData.key,me.userData.value),me.treeNodes)for(const Ee of me.treeNodes)we.set(Ee.index,Ee),fe.putTreeNode(Ee);if(me.treeUpgrade){if(me.treeUpgrade.ancestors!==ne.length)throw new Error("Unflushed truncations not migrate-able atm");ne.length=me.treeUpgrade.length,ne.fork=me.treeUpgrade.fork,ne.rootHash=null,ne.signature=me.treeUpgrade.signature}}ve.has("corestore/name")&&ve.has("corestore/namespace")&&(C.alias={name:l.toString(ve.get("corestore/name")),namespace:ve.get("corestore/namespace")},ve.delete("corestore/name"),ve.delete("corestore/namespace"));for(const[me,Ee]of ve)fe.putUserData(me,Ee);fe.setAuth(F);const ye=me=>we.get(me)||P(de.tree,me);ne.length&&(ne.rootHash===null&&(ne.rootHash=y.tree(await le(ne.length,ye))),fe.setHead(ne)),k.putCore(te,C),C.alias&&k.putCoreByAlias(C.alias,te),await fe.flush()}X.version=H,k.setHead(X),k.apply(),!_e&&(await c.flush(d.changes,D.db),ce&&await re(ie))}class w{constructor(H){this.stream=n.createReadStream(H),this.closed=new Promise(_e=>this.stream.once("close",_e)),this.offset=0,this.overflow=null}async take(H,_e){let ce=null;if(H<this.offset)throw new Error("overread");for(;;){let J=null;if(this.overflow)J=this.overflow,this.overflow=null;else if(J=this.stream.read(),!J){await new Promise(X=>this.stream.once("readable",X));continue}let d=null;if(this.offset===H||ce?d=J:this.offset+J.byteLength>H&&(d=J.subarray(H-this.offset)),this.offset+=J.byteLength,!d||(ce?ce=l.concat([ce,d]):ce=d,ce.byteLength<_e))continue;const k=ce.subarray(0,_e);return this.overflow=_e===ce.byteLength?null:ce.subarray(k.byteLength),this.offset-=this.overflow?this.overflow.byteLength:0,k}}close(){return this.stream.on("error",N),this.stream.destroy(),this.closed}}class R{constructor(){this.buffer=null,this.offset=0}get size(){return this.buffer===null?0:this.buffer.byteLength}push(H){this.buffer===null?this.buffer=H:this.buffer=l.concat([this.buffer,H]),this.offset+=H.byteLength}skip(){let H=0;for(b===null&&(B=l.alloc(16*40*100),_=B.subarray(0,4*40*100),b=B.subarray(0,1*40*100));;){if(this.buffer.byteLength>=B.byteLength&&l.equals(this.buffer.subarray(0,B.byteLength),B)){this.buffer=this.buffer.subarray(B.byteLength),H+=1600;continue}if(this.buffer.byteLength>=_.byteLength&&l.equals(this.buffer.subarray(0,_.byteLength),_)){this.buffer=this.buffer.subarray(_.byteLength),H+=400;continue}if(this.buffer.byteLength>=b.byteLength&&l.equals(this.buffer.subarray(0,b.byteLength),b)){this.buffer=this.buffer.subarray(b.byteLength),H+=100;continue}break}return H}take(){if(40<=this.size){const _e=this.buffer.subarray(0,40);return this.buffer=this.buffer.subarray(40),_e}return null}}async function A(D,{version:H,dryRun:_e=!0,gc:ce=!0}){if(_e)return;const J=D.read(),d=[J.getAuth(),J.getHead()];J.tryFlush();const[k,X]=await Promise.all(d);if(!k)return;const ie=l.toString(k.discoveryKey,"hex"),I=T(a.join(D.store.path,"cores",ie.slice(0,2),ie.slice(2,4),ie));if(X===null||X.length===0){await q(k,D,H),ce&&await Ee();return}const L=await S(I.oplog);if(!L){if(!!k.keyPair)throw new Error("No oplog available writable core for "+I.oplog+", length = "+(X?X.length:0));const ze=D.write();ze.deleteBlockRange(0,-1),ze.deleteTreeNodeRange(0,-1),ze.deleteBitfieldPageRange(0,-1),ze.deleteHead(),await ze.flush(),await q(k,D,H),ce&&await Ee();return}const V=new R;let te=0;if(await se(I.tree))for await(const Pe of n.createReadStream(I.tree)){V.push(Pe);let ze=null;for(;;){const it=V.skip();te+=it;const at=V.take();if(at===null)break;const xt=te++;l.equals(at,m)||(ze===null&&(ze=D.write()),ze.putTreeNode(O(xt,at)))}ze!==null&&await ze.flush()}const de=[];if(await se(I.bitfield))for await(const Pe of n.createReadStream(I.bitfield))de.push(Pe);let C=l.concat(de);C.byteLength&4095&&(C=l.concat([C,l.alloc(4096-(C.byteLength&4095))]));const ee=new Map,fe=new Map,ve=await Q(D,X.length);for(const Pe of L.entries)if(Pe.bitfield)for(let ze=0;ze<Pe.bitfield.length;ze++)fe.set(ze+Pe.bitfield.start,!Pe.bitfield.drop);let we=[];const F=new Map,ne=new w(I.data);for(const Pe of $(C))fe.get(Pe)!==!1&&(Pe>=X.length||(qe(Pe),we.push(Pe),!(we.length<1024)&&await Oe()));we.length&&await Oe(),await ne.close();const ye=D.write();for(const[Pe,ze]of fe){if(!ze||Pe>=X.length)continue;qe(Pe);const it=await U(I.data,D,Pe,ve,F);ye.putBlock(Pe,it)}for(const[Pe,ze]of ee)ye.putBitfieldPage(Pe,l.from(ze.buffer,ze.byteOffset,ze.byteLength));await ye.flush();let me=0;for await(const Pe of D.createBlockStream())if(Pe.index===me)me++;else break;if(me){const Pe=D.write();Pe.setHints({contiguousLength:me}),await Pe.flush()}await q(k,D,H),ce&&await Ee();async function Ee(){await re(I.path),await W(a.join(I.path,"..")),await W(a.join(I.path,"../..")),await W(a.join(D.store.path,"cores"))}function qe(Pe){const ze=Pe&32767,it=(Pe-ze)/32768;let at=ee.get(it);at||(at=new Uint32Array(1024),ee.set(it,at));const xt=ze&31,ii=(ze-xt)/32,si=1<<xt;at[ii]|=si}async function Oe(){const Pe=D.read(),ze=[];for(const xt of we)ze.push(oe(Pe,2*xt,ve,F));Pe.tryFlush();const it=await Promise.all(ze),at=D.write();for(let xt=0;xt<it.length;xt++){const ii=we[xt],[si,hs]=it[xt],Ui=await ne.take(si,hs);at.putBlock(ii,Ui)}we=[],F.size>16384&&F.clear(),await at.flush()}}async function q(D,H,_e){const ce=new c,J=new f(H.db,ce),d=J.getCore(D.discoveryKey);J.tryFlush();const k=await d;k.version=_e;const X=new s(ce);X.putCore(D.discoveryKey,k),X.apply(),await c.flush(ce.changes,H.db)}async function U(D,H,_e,ce,J){const d=H.read(),k=oe(d,2*_e,ce,J);d.tryFlush();const[X,ie]=await k;return new Promise(function(I){Z(D,ie,X,function(L,V){if(L)return I(null);I(V)})})}function T(D){return{path:D,oplog:a.join(D,"oplog"),data:a.join(D,"data"),tree:a.join(D,"tree"),bitfield:a.join(D,"bitfield")}}async function Q(D,H){const _e=[],ce=D.read();for(const J of g.fullRoots(2*H))_e.push(ce.getTreeNode(J));return ce.tryFlush(),Promise.all(_e)}async function le(D,H){const _e=[];for(const ce of g.fullRoots(2*D))_e.push(await H(ce));return _e}function Y(D,H,_e){if(H.has(_e))return H.get(_e);const ce=D.getTreeNode(_e);return H.set(_e,ce),ce}async function oe(D,H,_e,ce){const J=[Y(D,ce,H),ue(D,H,_e,ce)],[d,k]=await Promise.all(J);return[k,d.size]}async function ue(D,H,_e,ce){if(H===0)return 0;(H&1)===1&&(H=g.leftSpan(H));let J=0,d=0;for(const k of _e){if(J+=2*(k.index-J+1),H>=J){d+=k.size;continue}const X=g.iterator(k.index),ie=[];for(;X.index!==H;)H<X.index?X.leftChild():(ie.push(Y(D,ce,X.leftChild())),X.sibling());const I=await Promise.all(ie);for(const L of I)d+=L.size;return d}throw new Error("Failed to find offset")}function O(D,H){return{index:D,size:h.decode(h.uint64,H),hash:H.subarray(8)}}async function P(D,H){return new Promise(function(_e){Z(D,40,H*40,function(ce,J){if(ce)return _e(null);_e(O(H,J))})})}function Z(D,H,_e,ce){const J=l.alloc(H);n.open(D,"r",function(d,k){if(d)return ce(d);let X=0;n.read(k,J,X,J.byteLength,_e,function I(L,V){if(L)return ie(L);if(V===0)return ie(new Error("Partial read"));if(X+=V,X===J.byteLength)return ie(null,J);n.read(k,X,J.byteLength-X,J,_e+X,I)});function ie(I,L){n.close(k,()=>ce(I,L))}})}async function he(D){try{return await n.promises.readdir(D)}catch{return[]}}async function se(D){try{return await n.promises.stat(D),!0}catch{return!1}}async function G(D){try{return await n.promises.readFile(D)}catch{return null}}async function re(D){try{await n.promises.rm(D,{recursive:!0})}catch{}}async function W(D){try{await n.promises.rmdir(D)}catch{}}function*$(D){for(let H=0;H<D.byteLength;H+=E.byteLength){const _e=D.subarray(H,H+m.byteLength);if(l.equals(_e,E))continue;const ce=new Uint32Array(_e.buffer,_e.byteOffset,E.byteLength/4);for(let J=0;J<ce.length;J++){const d=ce[J];if(d!==0)for(let k=0;k<32;k++){const X=1<<k;d&X&&(yield H*8+J*32+k)}}}}function S(D){return new Promise(function(H){n.readFile(D,function(_e,ce){if(_e)return H(null);const J={start:0,end:ce.byteLength,buffer:ce},d=[1,0],k=z(J);J.start=4096;const X=z(J);if(J.start=4096*2,!k&&!X)return H(null);k&&!X?(d[0]=k.header,d[1]=k.header):!k&&X?(d[0]=X.header+1&1,d[1]=X.header):(d[0]=k.header,d[1]=X.header);const ie=d[0]+d[1]&1,I={path:a.dirname(D),header:null,entries:[]},L=[];if(I.header=ie?X.message:k.message,I.header.external){n.readFile(a.join(D,"../header"),function(te,de){if(te)return H(null);const C=I.header.external.start,ee=C+I.header.external.length;I.header=o.oplog.header.decode({buffer:de,start:C,end:ee}),V()});return}V();function V(){for(;;){const te=j(J);if(!te||te.header!==ie)break;L.push(te)}for(;L.length>0&&L[L.length-1].partial;)L.pop();for(const te of L)I.entries.push(te.message);H(I)}})})}function N(){}return du}var fu,Vm;function lS(){if(Vm)return fu;Vm=1;const n=J1(),a=go(),p=eS(),l=iS(),g=nn,y=nn,h=Vf(),o=1,c="corestore",{store:s,core:u}=al(),{CorestoreRX:f,CorestoreTX:m,CoreTX:E,CoreRX:b}=Vv(),{createCoreStream:_,createAliasStream:B,createDiscoveryKeyStream:M,createBlockStream:z,createBitfieldStream:j,createUserDataStream:v,createTreeNodeStream:w,createLocalStream:R}=oS(),A=new h;class q{constructor(P){this.db=P,this.view=new h,this.flushedPromise=null,this.flushing=!1,this.flushes=[]}onflush(P){this.flushes.push(P)}flushed(){return this.flushing?this.flushedPromise!==null?this.flushedPromise.promise:(this.flushedPromise=a(),this.flushedPromise.promise):Promise.resolve()}_resolve(){const P=this.flushedPromise;this.flushedPromise=null,P.resolve()}async flush(){if(this.flushing)throw new Error("Atom already flushing");this.flushing=!0;try{await h.flush(this.view.changes,this.db),this.view.reset();const P=[],Z=this.flushes.length;for(let he=0;he<Z;he++)P.push(this.flushes[he]());await Promise.all(P)}finally{this.flushing=!1,this.flushedPromise!==null&&this._resolve()}}}class U{constructor(P,Z,he,se,G){this.store=P,this.db=Z,this.core=he,this.view=se,this.atom=G,this.view.readStart()}get dependencies(){return this.core.dependencies}getDependencyLength(){return this.core.dependencies.length?this.core.dependencies[this.core.dependencies.length-1].length:-1}getDependency(P){for(let Z=this.core.dependencies.length-1;Z>=0;Z--){const he=this.core.dependencies[Z];if(he.length<P)return he}return null}setDependencyHead(P){const Z=this.core.dependencies;for(let he=Z.length-1;he>=0;he--){const se=Z[he];if(se.dataPointer===P.dataPointer){if(se.length===P.length&&he===Z.length-1)return;this.core={corePointer:this.core.corePointer,dataPointer:this.core.dataPointer,dependencies:Z.slice(0,he+1)},this.core.dependencies[he]={dataPointer:P.dataPointer,length:P.length}}}this.core.dependencies=[{dataPointer:P.dataPointer,length:P.length}]}updateDependencyLength(P,Z){const he=this.core.dependencies,se=this.findDependencyIndex(P,Z);if(se===-1)throw new Error("Dependency not found");this.core={corePointer:this.core.corePointer,dataPointer:this.core.dataPointer,dependencies:he.slice(0,se+1)},this.core.dependencies[se].length!==P&&(this.core.dependencies[se]={dataPointer:he[se].dataPointer,length:P})}findDependencyIndex(P,Z){const he=this.core.dependencies;if(Z){for(let se=0;se<he.length;se++)if(he[se].length>=P)return se;return-1}for(let se=he.length-1;se>=0;se--)if(he[se].length<=P)return se;return-1}get snapshotted(){return this.db._snapshot!==null}snapshot(){return new U(this.store,this.db.snapshot(),this.core,this.view.snapshot(),this.atom)}atomize(P){if(this.atom&&this.atom!==P)throw new Error("Cannot atomize and atomized session with a new atom");return new U(this.store,this.db.session(),this.core,P.view,P)}createAtom(){return this.store.createAtom()}createBlockStream(P){return z(this.core,this.db,this.view,P)}createTreeNodeStream(P){return w(this.core,this.db,this.view,P)}createBitfieldStream(P){return j(this.core,this.db,this.view,P)}createUserDataStream(P){return v(this.core,this.db,this.view,P)}createLocalStream(P){return R(this.core,this.db,this.view,P)}async resumeSession(P){const Z=this.read(),he=Z.getSessions();Z.tryFlush();const G=await he||[],re=le(G,P,!1);if(re===null)return null;const W={corePointer:this.core.corePointer,dataPointer:re.dataPointer,dependencies:[]},$=new b(W,this.db,this.view),S=$.getDependency();$.tryFlush();const N=await S;return N&&(W.dependencies=this._addDependency(N)),new U(this.store,this.db.session(),W,this.atom?this.view:new h,this.atom)}async createSession(P,Z){const he=this.read(),se=he.getSessions(),G=he.getHead();he.tryFlush();const[re,W]=await Promise.all([se,G]);if(Z===null&&(Z=W),W!==null&&Z.length>W.length)throw new Error("Invalid head passed, ahead of core");const $=re||[],S=le($,P,!0),N=S.dataPointer===-1;N&&(S.dataPointer=await this.store._allocData());const D=this.write();D.setSessions($);const H=Z===null?0:Z.length,_e={corePointer:this.core.corePointer,dataPointer:S.dataPointer,dependencies:this._addDependency({dataPointer:this.core.dataPointer,length:H})},ce=new E(_e,this.db,D.view,D.changes);return H>0&&ce.setHead(Z),ce.setDependency(_e.dependencies[_e.dependencies.length-1]),N||(ce.deleteBlockRange(0,-1),ce.deleteTreeNodeRange(0,-1),ce.deleteBitfieldPageRange(0,-1)),await D.flush(),new U(this.store,this.db.session(),_e,this.atom?this.view:new h,this.atom)}async createAtomicSession(P,Z){const he=Z===null?0:Z.length,se={corePointer:this.core.corePointer,dataPointer:this.core.dataPointer,dependencies:this._addDependency(null)},G=new E(se,this.db,P.view,[]);return he>0&&G.setHead(Z),await G.flush(),this.atomize(P)}_addDependency(P){const Z=[];for(let he=0;he<this.core.dependencies.length;he++){const se=this.core.dependencies[he];if(P!==null&&se.length>P.length)return se.dataPointer!==P.dataPointer&&Z.push({dataPointer:se.dataPointer,length:P.length}),Z;Z.push(se)}return P!==null&&(Z.length===0||Z[Z.length-1].dataPointer!==P.dataPointer)&&Z.push(P),Z}read(){return new b(this.core,this.db,this.view)}write(){return new E(this.core,this.db,this.atom?this.view:null,[])}close(){return this.view!==null&&(this.view.readStop(),this.view=null),this.db.close()}}class T{constructor(P,Z={}){const he=typeof P=="string"?P:null;this.bootstrap=he!==null,this.path=he!==null?he:g.join(P.path,".."),this.readOnly=!!Z.readOnly,this.allowBackup=!!Z.allowBackup,this.bootstrap&&!this.readOnly&&ue(this.path),this.rocks=he===null?P:new n(g.join(this.path,"db"),Z),this.db=oe(this.rocks,Z),this.id=Z.id||null,this.view=null,this.enters=0,this.lock=new p,this.flushing=null,this.version=0,this.migrating=null}get opened(){return this.db.opened}get closed(){return this.db.closed}async ready(){return this.version===0&&await this._migrateStore(),this.db.ready()}async audit(){for await(const{core:P}of this.createCoreStream()){const Z=new b(P,this.db,A),he=Z.getAuth();Z.tryFlush();const se=await he;if(!se.manifest||se.manifest.version>0||se.manifest.linked===null)continue;se.manifest.linked=null;const G=new E(P,this.db,null,[]);G.setAuth(se),await G.flush()}}async deleteCore(P){const Z=new b(P,this.db,A),he=Z.getAuth(),se=Z.getSessions();Z.tryFlush();const G=await he,re=await se;if(!G)return;const W=this.db.write({autoDestroy:!0});W.tryDelete(s.core(G.discoveryKey));const $=u.core(P.corePointer),S=u.core(P.corePointer+1);if(W.tryDeleteRange($,S),re)for(const{dataPointer:N}of re){const D=u.data(N),H=u.data(N+1);W.tryDeleteRange(D,H)}return W.flush()}static isCoreStorage(P){return Y(P)}static from(P){return Y(P)?P:new this(P)}async _flush(){for(;this.enters>0;)await this.lock.lock(),await this.lock.unlock()}async _migrateStore(){const P=await this._enter();try{if(this.version===o)return;if(await this.db.ready(),this.bootstrap&&!this.readOnly&&!this.allowBackup){const W=g.join(this.path,"CORESTORE");await l.resume(W,{id:this.id})||await l.create(W,{id:this.id})}const Z=new f(this.db,P),he=Z.getHead();Z.tryFlush();const se=await he,G=se===null?0:se.version;if(G===o){this.version=o;return}const re={version:o,dryRun:!1};switch(G){case 0:{await Fm().store(this,re);break}default:throw new Error("Unsupported version: "+G+" - you should probably upgrade your dependencies")}this.version=o}finally{await this._exit()}}async _migrateCore(P,Z,he,se){const G=se?this.view:await this._enter();try{if(he===o)return;const re={version:o,dryRun:!1};switch(he){case 0:{await Fm().core(P,re);break}default:throw new Error("Unsupported version: "+he+" - you should probably upgrade your dependencies")}if(se===!1)return;const W=new f(this.db,A),$=new m(G),S=W.getCore(Z);W.tryFlush(),$.putCore(Z,await S),$.apply()}finally{se||await this._exit()}}async _enter(){return this.enters++,await this.lock.lock(),this.view===null&&(this.view=new h),this.view}async _exit(){this.enters--,this.flushing===null&&(this.flushing=a());const P=this.flushing.promise;if(this.enters===0||this.view.size()>128)try{await h.flush(this.view.changes,this.db),this.flushing.resolve()}catch(Z){this.flushing.reject(Z)}finally{this.flushing=null,this.view=null}return this.lock.unlock(),P}async _allocData(){let P=0;const Z=await this._enter(),he=new m(Z);try{const se=await this._getHead(Z);P=se.allocated.datas++,he.setHead(se),he.apply()}finally{await this._exit()}return P}async _getHead(P){const Z=new f(this.db,P),he=Z.getHead();Z.tryFlush();const se=await he;return se===null?Q():se}createAtom(){return new q(this.db)}async flush(){await this.rocks.flush()}async close(){this.db.closed||(await this._flush(),await this.db.close(),await this.rocks.close())}async clear(){this.version===0&&await this._migrateStore();const P=await this._enter(),Z=new m(P);Z.clear(),Z.apply(),await this._exit()}createCoreStream(){return _(this.db,A)}createAliasStream(P){return B(this.db,A,P)}createDiscoveryKeyStream(P){return M(this.db,A,P)}async getAlias(P){this.version===0&&await this._migrateStore();const Z=new f(this.db,A),he=Z.getCoreByAlias(P);return Z.tryFlush(),he}async getSeed(){this.version===0&&await this._migrateStore();const P=new f(this.db,A),Z=P.getHead();P.tryFlush();const he=await Z;return he===null?null:he.seed}async setSeed(P,{overwrite:Z=!0}={}){this.version===0&&await this._migrateStore();const he=await this._enter(),se=new m(he);try{const G=new f(this.db,he),re=G.getHead();G.tryFlush();const W=await re||Q();return(W.seed===null||Z)&&(W.seed=P),se.setHead(W),se.apply(),W.seed}finally{await this._exit()}}async getDefaultDiscoveryKey(){this.version===0&&await this._migrateStore();const P=new f(this.db,A),Z=P.getHead();P.tryFlush();const he=await Z;return he===null?null:he.defaultDiscoveryKey}async setDefaultDiscoveryKey(P,{overwrite:Z=!0}={}){this.version===0&&await this._migrateStore();const he=await this._enter(),se=new m(he);try{const G=new f(this.db,he),re=G.getHead();G.tryFlush();const W=await re||Q();return(W.defaultDiscoveryKey===null||Z)&&(W.defaultDiscoveryKey=P),se.setHead(W),se.apply(),W.defaultDiscoveryKey}finally{await this._exit()}}async has(P,{ifMigrated:Z=!1}={}){this.version===0&&await this._migrateStore();const he=new f(this.db,A),se=he.getCore(P);he.tryFlush();const G=await se;return!(G===null||G.version!==o&&Z)}async getAuth(P){this.version===0&&await this._migrateStore();const Z=new f(this.db,A),he=Z.getCore(P);Z.tryFlush();const se=await he;if(se===null)return null;const G=new b(se,this.db,A),re=G.getAuth();return G.tryFlush(),re}async resume(P){if(this.version===0&&await this._migrateStore(),!P&&(P=await this.getDefaultDiscoveryKey(),!P))return null;const Z=new f(this.db,A),he=Z.getCore(P);Z.tryFlush();const se=await he;return se===null?null:this._resumeFromPointers(A,P,!1,se)}async _resumeFromPointers(P,Z,he,{version:se,corePointer:G,dataPointer:re}){const W={corePointer:G,dataPointer:re,dependencies:[]};for(;;){const S=new b({dataPointer:re,corePointer:0,dependencies:[]},this.db,P),N=S.getDependency();S.tryFlush();const D=await N;if(!D)break;W.dependencies.push(D),re=D.dataPointer}const $=new U(this,this.db.session(),W,A,null);return se<o&&await this._migrateCore($,Z,se,he),$}async _create(P,{key:Z,manifest:he,keyPair:se,encryptionKey:G,discoveryKey:re,alias:W,userData:$}){const S=new f(this.db,P),N=new m(P),D=S.getCore(re),H=S.getHead();S.tryFlush();let[_e,ce]=await Promise.all([D,H]);if(_e)return this._resumeFromPointers(P,re,!0,_e);ce===null&&(ce=Q()),ce.defaultDiscoveryKey===null&&(ce.defaultDiscoveryKey=re);const J=ce.allocated.cores++,d=ce.allocated.datas++;_e={version:o,corePointer:J,dataPointer:d,alias:W},N.setHead(ce),N.putCore(re,_e),W&&N.putCoreByAlias(W,re);const k={corePointer:J,dataPointer:d,dependencies:[]},X=new E(k,this.db,P,N.changes);if(X.setAuth({key:Z,discoveryKey:re,manifest:he,keyPair:se,encryptionKey:G}),$)for(const{key:ie,value:I}of $)X.putUserData(ie,I);return N.apply(),new U(this,this.db.session(),k,A,null)}async create(P){this.version===0&&await this._migrateStore();const Z=await this._enter();try{return await this._create(Z,P)}finally{await this._exit()}}}fu=T;function Q(){return{version:0,allocated:{datas:0,cores:0},seed:null,defaultDiscoveryKey:null}}function le(O,P,Z){for(let se=0;se<O.length;se++)if(O[se].name===P)return O[se];if(!Z)return null;const he={name:P,dataPointer:-1};return O.push(he),he}function Y(O){return typeof O=="object"&&!!O&&typeof O.setDefaultDiscoveryKey=="function"}function oe(O,P={}){const{tableCacheIndexAndFilterBlocks:Z=!0,blockCache:he=!0,optimizeFiltersForMemory:se=!1}=P,G=new n.ColumnFamily(c,{enableBlobFiles:!0,minBlobSize:4096,blobFileSize:256*1024*1024,enableBlobGarbageCollection:!0,tableBlockSize:8192,tableCacheIndexAndFilterBlocks:Z,tableFormatVersion:6,optimizeFiltersForMemory:se,blockCache:he});return O.columnFamily(G)}function ue(O){if(y.existsSync(g.join(O,"CORESTORE")))return;let P=[];try{P=y.readdirSync(O)}catch{}const Z=new Set(["CORESTORE","primary-key","cores","app-preferences","cache","preferences.json","db","clone","core","notifications"]);for(const he of P)if(!Z.has(he)){try{y.mkdirSync(g.join(O,"db"))}catch{}y.renameSync(g.join(O,he),g.join(O,"db",he))}}return fu}var gu,jm;function cS(){if(jm)return gu;jm=1;const n=sn(),a=Ue(),p=n.crypto_secretstream_xchacha20poly1305_ABYTES,l=n.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,g=n.crypto_secretstream_xchacha20poly1305_TAG_FINAL,y=n.crypto_secretstream_xchacha20poly1305_STATEBYTES,h=n.crypto_secretstream_xchacha20poly1305_HEADERBYTES,o=n.crypto_secretstream_xchacha20poly1305_KEYBYTES,c=a.isBuffer(g)?g[0]:g,s=a.alloc(0),u=a.alloc(1);class f{constructor(_,B=a.allocUnsafeSlow(y),M=a.allocUnsafeSlow(h)){if(!g)throw new Error("JavaScript sodium version needs to support crypto_secretstream_xchacha20poly");this.key=_,this.state=B,this.header=M,n.crypto_secretstream_xchacha20poly1305_init_push(this.state,this.header,this.key)}next(_,B=a.allocUnsafe(_.byteLength+p)){return n.crypto_secretstream_xchacha20poly1305_push(this.state,B,_,null,l),B}final(_=s,B=a.allocUnsafe(p)){return n.crypto_secretstream_xchacha20poly1305_push(this.state,B,_,null,g),B}}class m{constructor(_,B=a.allocUnsafeSlow(y)){if(!g)throw new Error("JavaScript sodium version needs to support crypto_secretstream_xchacha20poly");this.key=_,this.state=B,this.final=!1}init(_){n.crypto_secretstream_xchacha20poly1305_init_pull(this.state,_,this.key)}next(_,B=a.allocUnsafe(_.byteLength-p)){return n.crypto_secretstream_xchacha20poly1305_pull(this.state,B,u,_,null),this.final=u[0]===c,B}}function E(b=a.alloc(o)){return n.crypto_secretstream_xchacha20poly1305_keygen(b),b}return gu={keygen:E,KEYBYTES:o,ABYTES:p,STATEBYTES:y,HEADERBYTES:h,Push:f,Pull:m},gu}var pu,Gm;function hS(){if(Gm)return pu;Gm=1,pu=class{constructor(l,g,y=null,h=!1){this.ms=l,this.ontimeout=g,this.context=y||null,this.interval=h,this.done=!1,this._timer=h?setInterval(a,l,this):setTimeout(n,l,this)}unref(){}ref(){}refresh(){this.done||(this.interval?(clearInterval(this._timer),this._timer=setInterval(a,this.ms,this)):(clearTimeout(this._timer),this._timer=setTimeout(n,this.ms,this)))}destroy(){this.done=!0,this.ontimeout=null,this.interval?clearInterval(this._timer):clearTimeout(this._timer)}static once(l,g,y){return new this(l,g,y,!1)}static on(l,g,y){return new this(l,g,y,!0)}};function n(p){p.done=!0,p.ontimeout.call(p.context)}function a(p){p.ontimeout.call(p.context)}return pu}var yu,Ym;function uS(){if(Ym)return yu;Ym=1;const{Duplex:n,Writable:a}=Sn();class p extends n{constructor(g){super(),this._stream=g,this._ondrain=null}_write(g,y){this._stream.push(g)===!1?this._stream._ondrain=y:y(null)}_final(g){this._stream.push(null),g(null)}_read(g){const y=this._ondrain;this._ondrain=null,y&&y(),g(null)}}return yu=class extends n{constructor(g){super(),this.noiseStream=g,this._ondrain=null,this.reverse=new p(this)}get publicKey(){return this.noiseStream.publicKey}get remotePublicKey(){return this.noiseStream.remotePublicKey}get handshakeHash(){return this.noiseStream.handshakeHash}flush(){return a.drained(this)}_read(g){const y=this._ondrain;this._ondrain=null,y&&y(),g(null)}_write(g,y){this.reverse.push(g)===!1?this.reverse._ondrain=y:y(null)}_final(g){this.reverse.push(null),g(null)}},yu}var _u,Wm;function dS(){if(Wm)return _u;Wm=1;const n=sn(),a=On(),p=Ue(),l=n.crypto_scalarmult_ed25519_BYTES,g=n.crypto_scalarmult_ed25519_BYTES,y=n.crypto_scalarmult_ed25519_BYTES,h=n.crypto_sign_SECRETKEYBYTES,o="Ed25519";_u={DHLEN:l,PKLEN:g,SCALARLEN:y,SKLEN:h,ALG:o,name:o,generateKeyPair:c,dh:u};function c(f){if(f)return s(f.subarray(0,32));const m={};return m.secretKey=p.alloc(h),m.publicKey=p.alloc(g),n.crypto_sign_keypair(m.publicKey,m.secretKey),m}function s(f){const m={};return m.secretKey=p.alloc(h),m.publicKey=p.alloc(g),n.crypto_sign_seed_keypair(m.publicKey,m.secretKey,f),m}function u(f,{scalar:m,secretKey:E}){if(!m){a(E.byteLength===h);const _=p.alloc(64);n.crypto_hash_sha512(_,E.subarray(0,32)),_[0]&=248,_[31]&=127,_[31]|=64,m=_.subarray(0,32)}a(m.byteLength===y),a(f.byteLength===g);const b=p.alloc(l);return n.crypto_scalarmult_ed25519_noclamp(b,m,f),b}return _u}var mu,Qm;function fS(){if(Qm)return mu;Qm=1;const n=sn(),a=Ue();mu=class{constructor(y){this.key=y||null,this.nonce=0,this.CIPHER_ALG="ChaChaPoly"}initialiseKey(y){this.key=y,this.nonce=0}setNonce(y){this.nonce=y}encrypt(y,h){if(!this.hasKey)return y;h||(h=a.alloc(0));const o=p(this.key,this.nonce,h,y);if(o.length>65535)throw new Error(`ciphertext length of ${o.length} exceeds maximum Noise message length of 65535`);return this.nonce++,o}decrypt(y,h){if(!this.hasKey)return y;if(h||(h=a.alloc(0)),y.length>65535)throw new Error(`ciphertext length of ${y.length} exceeds maximum Noise message length of 65535`);const o=l(this.key,this.nonce,h,y);return this.nonce++,o}get hasKey(){return this.key!==null}_clear(){n.sodium_memzero(this.key),this.key=null,this.nonce=null}static get MACBYTES(){return 16}static get NONCEBYTES(){return 8}static get KEYBYTES(){return 32}};function p(g,y,h,o){a.isBuffer(h)||(h=a.from(h,"hex")),a.isBuffer(o)||(o=a.from(o,"hex"));const c=a.alloc(n.crypto_aead_chacha20poly1305_ietf_NPUBBYTES);new DataView(c.buffer,c.byteOffset,c.byteLength).setUint32(4,y,!0);const u=a.alloc(o.byteLength+n.crypto_aead_chacha20poly1305_ietf_ABYTES);return n.crypto_aead_chacha20poly1305_ietf_encrypt(u,o,h,null,c,g),u}function l(g,y,h,o){a.isBuffer(h)||(h=a.from(h,"hex")),a.isBuffer(o)||(o=a.from(o,"hex"));const c=a.alloc(n.crypto_aead_chacha20poly1305_ietf_NPUBBYTES);new DataView(c.buffer,c.byteOffset,c.byteLength).setUint32(4,y,!0);const u=a.alloc(o.byteLength-n.crypto_aead_chacha20poly1305_ietf_ABYTES);return n.crypto_aead_chacha20poly1305_ietf_decrypt(u,null,o,h,c,g),u}return mu}var wu,Xm;function gS(){if(Xm)return wu;Xm=1;const{crypto_kx_SEEDBYTES:n,crypto_kx_keypair:a,crypto_kx_seed_keypair:p,crypto_scalarmult_BYTES:l,crypto_scalarmult_SCALARBYTES:g,crypto_scalarmult:y,crypto_scalarmult_base:h}=sn(),o=On(),c=Ue(),s=l,u=l,f=g;wu={DHLEN:s,PKLEN:u,SKLEN:f,SEEDLEN:n,ALG:"25519",generateKeyPair:b,generateSeedKeyPair:_,dh:B};function b(M){const z={};return z.secretKey=M||c.alloc(f),z.publicKey=c.alloc(u),M?h(z.publicKey,z.secretKey):a(z.publicKey,z.secretKey),z}function _(M){o(M.byteLength===f);const z={};return z.secretKey=c.alloc(f),z.publicKey=c.alloc(u),p(z.publicKey,z.secretKey,M),z}function B(M,{secretKey:z}){o(z.byteLength===f),o(M.byteLength===u);const j=c.alloc(s);return y(j,z,M),j}return wu}var ao={exports:{}},Zm;function pS(){if(Zm)return ao.exports;Zm=1;const n=Ue(),{sodium_memzero:a,crypto_generichash:p,crypto_generichash_batch:l}=sn(),g=64,y=128,h=n.alloc(y*3),o=h.subarray(y*0,y*1),c=h.subarray(y*1,y*2),s=h.subarray(y*2,y*3);return ao.exports=function(f,m,E){E.byteLength>y?(p(o.subarray(0,g),E),a(o.subarray(g))):(o.set(E),a(o.subarray(E.byteLength)));for(let b=0;b<o.byteLength;b++)c[b]=92^o[b],s[b]=54^o[b];a(o),l(f,[s].concat(m)),a(s),l(f,[c,f]),a(c)},ao.exports.BYTES=g,ao.exports.KEYBYTES=y,ao.exports}var bu,$m;function jv(){if($m)return bu;$m=1;const n=pS(),a=Ue(),p=64;bu={hkdf:l,HASHLEN:p};function l(o,c,s="",u=2*p){const f=g(o,c);return y(f,s,u)}function g(o,c){const s=a.alloc(p);return h(s,o,c)}function y(o,c,s){const u=a.allocUnsafeSlow(s),f=a.from(c);let m=f;const E=[];for(let b=0;b<s;b+=p){const _=a.from([b/p+1]),B=u.subarray(b,b+p);E.push(B),m=h(B,o,[m,f,_])}return E}function h(o,c,s){return n(o,s,c),o}return bu}var vu,Jm;function yS(){if(Jm)return vu;Jm=1;const n=sn(),a=On(),p=Ue(),l=fS(),g=gS(),{HASHLEN:y,hkdf:h}=jv();vu=class extends l{constructor(s={}){super(),this.curve=s.curve||g,this.digest=p.alloc(y),this.chainingKey=null,this.offset=0,this.DH_ALG=this.curve.ALG}mixHash(s){o(this.digest,s)}mixKeyAndHash(s){const[u,f,m]=h(this.chainingKey,s,"",3*y);this.chainingKey=u,this.mixHash(f),this.initialiseKey(m.subarray(0,32))}mixKeyNormal(s){const[u,f]=h(this.chainingKey,s);this.chainingKey=u,this.initialiseKey(f.subarray(0,32))}mixKey(s,u){const f=this.curve.dh(s,u),m=h(this.chainingKey,f);this.chainingKey=m[0],this.initialiseKey(m[1].subarray(0,32))}encryptAndHash(s){const u=this.encrypt(s,this.digest);return o(this.digest,u),u}decryptAndHash(s){const u=this.decrypt(s,this.digest);return o(this.digest,s),u}getHandshakeHash(s){return s?(a(s.byteLength===y,`output must be ${y} bytes`),s.set(this.digest),s):this.getHandshakeHash(p.alloc(y))}split(){return h(this.chainingKey,p.alloc(0)).map(u=>u.subarray(0,32))}_clear(){super._clear(),n.sodium_memzero(this.digest),n.sodium_memzero(this.chainingKey),this.digest=null,this.chainingKey=null,this.offset=null,this.curve=null}static get alg(){return l.alg+"_BLAKE2b"}};function o(c,s){const u=p.concat([c,s]);n.crypto_generichash(c,u)}return vu}var ku,ew;function _S(){if(ew)return ku;ew=1;const n=On(),a=Ue(),p=yS(),{HASHLEN:l}=jv(),g=Symbol("initiator static key preshared"),y=Symbol("responder static key preshared"),h=Symbol("psk"),o=Symbol("s"),c=Symbol("e"),s=Symbol("es"),u=Symbol("se"),f=Symbol("ee"),m=Symbol("ss"),E=Object.freeze({NN:[[c],[c,f]],NNpsk0:[[h,c],[c,f]],XX:[[c],[c,f,o,s],[o,u]],XXpsk0:[[h,c],[c,f,o,s],[o,u]],IK:[y,[c,s,o,m],[c,f,u]]});class b{constructor(){this.size=0,this.buffers=[]}push(j){this.size+=j.byteLength,this.buffers.push(j)}end(){const j=a.alloc(this.size);let v=0;for(const w of this.buffers)j.set(w,v),v+=w.byteLength;return j}}class _{constructor(j){this.offset=0,this.buffer=j}shift(j){const v=this.offset,w=this.offset+=j;if(w>this.buffer.byteLength)throw new Error("Insufficient bytes");return this.buffer.subarray(v,w)}end(){return this.shift(this.buffer.byteLength-this.offset)}}ku=class extends p{constructor(j,v,w,R={}){super(R),this.s=w||this.curve.generateKeyPair(),this.e=null,this.psk=null,R&&R.psk&&(this.psk=R.psk),this.re=null,this.rs=null,this.pattern=j,this.handshake=E[this.pattern].slice(),this.isPskHandshake=!!this.psk&&M(this.handshake),this.protocol=a.from(["Noise",this.pattern,this.DH_ALG,this.CIPHER_ALG,"BLAKE2b"].join("_")),this.initiator=v,this.complete=!1,this.rx=null,this.tx=null,this.hash=null}initialise(j,v){for(this.protocol.byteLength<=l?this.digest.set(this.protocol):this.mixHash(this.protocol),this.chainingKey=a.from(this.digest),this.mixHash(j);!Array.isArray(this.handshake[0]);){const w=this.handshake.shift();n(w===y||w===g,"Unexpected pattern");const R=this.initiator?w===y:w===g;R&&(this.rs=v);const A=R?this.rs:this.s.publicKey;n(A!=null,"Remote pubkey required"),this.mixHash(A)}}final(){const[j,v]=this.split();this.tx=this.initiator?j:v,this.rx=this.initiator?v:j,this.complete=!0,this.hash=this.getHandshakeHash(),this._clear()}recv(j){const v=new _(j);for(const R of this.handshake.shift())switch(R){case h:this.mixKeyAndHash(this.psk);break;case c:this.re=v.shift(this.curve.PKLEN),this.mixHash(this.re),this.isPskHandshake&&this.mixKeyNormal(this.re);break;case o:{const A=this.hasKey?this.curve.PKLEN+16:this.curve.PKLEN;this.rs=this.decryptAndHash(v.shift(A));break}case f:case s:case u:case m:{const A=B(R,this.initiator),q=A.local?this.s:this.e,U=A.remote?this.rs:this.re;this.mixKey(U,q);break}default:throw new Error("Unexpected message")}const w=this.decryptAndHash(v.end());return this.handshake.length||this.final(),w}send(j=a.alloc(0)){const v=new b;for(const R of this.handshake.shift())switch(R){case h:this.mixKeyAndHash(this.psk);break;case c:this.e===null&&(this.e=this.curve.generateKeyPair()),this.mixHash(this.e.publicKey),this.isPskHandshake&&this.mixKeyNormal(this.e.publicKey),v.push(this.e.publicKey);break;case o:v.push(this.encryptAndHash(this.s.publicKey));break;case s:case u:case f:case m:{const A=B(R,this.initiator),q=A.local?this.s:this.e,U=A.remote?this.rs:this.re;this.mixKey(U,q);break}default:throw new Error("Unexpected message")}v.push(this.encryptAndHash(j));const w=v.end();return this.handshake.length||this.final(),w}_clear(){super._clear(),this.e.secretKey.fill(0),this.e.publicKey.fill(0),this.re.fill(0),this.e=null,this.re=null}};function B(z,j){const v={local:!1,remote:!1};switch(z){case f:return v;case s:return v.local^=!j,v.remote^=j,v;case u:return v.local^=j,v.remote^=!j,v;case m:return v.local^=1,v.remote^=1,v}}function M(z){return z.some(j=>Array.isArray(j)&&j.indexOf(h)!==-1)}return ku}var Su,tw;function mS(){if(tw)return Su;tw=1;const n=sn(),a=dS(),p=_S(),l=Ue(),g=l.alloc(0);Su=class{constructor(o,c,s,u){this.isInitiator=o,this.keyPair=c,this.noise=new p(u,o,c,{curve:a}),this.noise.initialise(g,s),this.destroyed=!1}static keyPair(o){const c=l.alloc(32),s=l.alloc(64);return o?n.crypto_sign_seed_keypair(c,s,o):n.crypto_sign_keypair(c,s),{publicKey:c,secretKey:s}}recv(o){try{return this.noise.recv(o),this.noise.complete?this._return(null):this.send()}catch{return this.destroy(),null}}send(){try{const o=this.noise.send(),c=l.allocUnsafe(o.byteLength+3);return y(o.byteLength,c),c.set(o,3),this._return(c)}catch{return this.destroy(),null}}destroy(){this.destroyed||(this.destroyed=!0)}_return(o){const c=this.noise.complete?l.toBuffer(this.noise.tx):null,s=this.noise.complete?l.toBuffer(this.noise.rx):null,u=this.noise.complete?l.toBuffer(this.noise.hash):null,f=this.noise.complete?l.toBuffer(this.noise.rs):null;return{data:o,remotePublicKey:f,hash:u,tx:c,rx:s}}};function y(h,o){o[0]=h&255,o[1]=h>>>8&255,o[2]=h>>>16&255}return Su}var xu,nw;function Gv(){if(nw)return xu;nw=1;const{Pull:n,Push:a,HEADERBYTES:p,KEYBYTES:l,ABYTES:g}=cS(),y=sn(),h=_t(),{Duplex:o,Writable:c,getStreamError:s}=Sn(),u=Ue(),f=hS(),m=Xt(),E=uS(),b=mS(),_=p+32,[B,M,z]=h.namespace("hyperswarm/secret-stream",3),j=256*256*256-1;xu=class extends o{constructor(T,Q,le={}){if(super({mapWritable:R}),typeof T!="boolean")throw new Error("isInitiator should be a boolean");this.noiseStream=this,this.isInitiator=T,this.rawStream=null,this.publicKey=le.publicKey||null,this.remotePublicKey=le.remotePublicKey||null,this.handshakeHash=null,this.connected=!1,this.keepAlive=le.keepAlive||0,this.timeout=0,this.enableSend=le.enableSend!==!1,this.userData=null;let Y=null;this.opened=new Promise(oe=>{Y=oe}),this.rawBytesWritten=0,this.rawBytesRead=0,this.relay=null,this.puncher=null,this._rawStream=null,this._handshake=null,this._handshakePattern=le.pattern||null,this._handshakeDone=null,this._state=0,this._len=0,this._tmp=1,this._message=null,this._openedDone=Y,this._startDone=null,this._drainDone=null,this._outgoingPlain=null,this._outgoingWrapped=null,this._utp=null,this._setup=!0,this._ended=2,this._encrypt=null,this._decrypt=null,this._timeoutTimer=null,this._keepAliveTimer=null,this._sendState=null,le.autoStart!==!1&&this.start(Q,le),this.resume(),this.pause()}static keyPair(T){return b.keyPair(T)}static id(T,Q,le){return w(T,Q,le)}setTimeout(T){T||(T=0),this._clearTimeout(),this.timeout=T,!(!T||this.rawStream===null)&&(this._timeoutTimer=f.once(T,A,this),this._timeoutTimer.unref())}setKeepAlive(T){T||(T=0),this._clearKeepAlive(),this.keepAlive=T,!(!T||this.rawStream===null)&&(this._keepAliveTimer=f.on(T,q,this),this._keepAliveTimer.unref())}sendKeepAlive(){const T=this.alloc(0);this.write(T)}start(T,Q={}){T?(this.rawStream=T,this._rawStream=T,typeof this.rawStream.setContentSize=="function"&&(this._utp=T)):(this.rawStream=new E(this),this._rawStream=this.rawStream.reverse),this.rawStream.on("error",this._onrawerror.bind(this)),this.rawStream.on("close",this._onrawclose.bind(this)),this._startHandshake(Q.handshake,Q.keyPair||null),this._continueOpen(null),!this.destroying&&(Q.data&&this._onrawdata(Q.data),Q.ended&&this._onrawend(),this.keepAlive>0&&this._keepAliveTimer===null&&this.setKeepAlive(this.keepAlive),this.timeout>0&&this._timeoutTimer===null&&this.setTimeout(this.timeout))}async flush(){return await this.opened===!1||await c.drained(this)===!1||this.destroying?!1:this.rawStream!==null&&this.rawStream.flush?await this.rawStream.flush():!0}_continueOpen(T){if(T&&this.destroy(T),this._startDone===null)return;const Q=this._startDone;this._startDone=null,this._open(Q)}_onkeypairpromise(T){const Q=this,le=this._continueOpen.bind(this);T.then(Y,le);function Y(oe){Q._onkeypair(oe),le(null)}}_onkeypair(T){const Q=this._handshakePattern||"XX",le=this.remotePublicKey;this._handshake=new b(this.isInitiator,T,le,Q),this.publicKey=this._handshake.keyPair.publicKey}_startHandshake(T,Q){if(T){const{tx:le,rx:Y,hash:oe,publicKey:ue,remotePublicKey:O}=T;this._setupSecretStream(le,Y,oe,ue,O);return}Q||(Q=b.keyPair()),typeof Q.then=="function"?this._onkeypairpromise(Q):this._onkeypair(Q)}_onrawerror(T){this.destroy(T)}_onrawclose(){this._ended!==0&&this.destroy()}_onrawdata(T){let Q=0;this._timeoutTimer!==null&&this._timeoutTimer.refresh();do switch(this._state){case 0:{for(;this._tmp!==16777216&&Q<T.byteLength;){const le=T[Q++];this._len+=this._tmp*le,this._tmp*=256}if(this._tmp===16777216){this._tmp=0,this._state=1;const le=T.byteLength-Q;le<this._len&&this._utp!==null&&this._utp.setContentSize(this._len-le)}break}case 1:{const le=this._len-this._tmp,Y=le+Q;if(this._message===null&&Y<=T.byteLength){this._message=T.subarray(Q,Y),Q+=le,this._incoming();break}const oe=T.byteLength-Q;this._message===null&&(this._message=u.allocUnsafe(this._len)),u.copy(T,this._message,this._tmp,Q),this._tmp+=oe,Y<=T.byteLength?(Q+=le,this._incoming()):Q+=oe;break}}while(Q<T.byteLength&&!this.destroying)}_onrawend(){this._ended--,this.push(null)}_onrawdrain(){const T=this._drainDone;T!==null&&(this._drainDone=null,T())}_read(T){this.rawStream.resume(),T(null)}_incoming(){const T=this._message;if(this._state=0,this._len=0,this._tmp=1,this._message=null,this._setup===!0){if(this._handshake)this._onhandshakert(this._handshake.recv(T));else{if(T.byteLength!==_){this.destroy(new Error("Invalid header message received"));return}const le=T.subarray(0,32),Y=w(this.handshakeHash,!this.isInitiator),oe=T.subarray(32);if(!u.equals(Y,le)){this.destroy(new Error("Invalid header received"));return}this._decrypt.init(oe),this._setup=!1}return}if(T.byteLength<g){this.destroy(new Error("Invalid message received"));return}this.rawBytesRead+=T.byteLength;const Q=T.subarray(1,T.byteLength-g+1);try{this._decrypt.next(T,Q)}catch(le){this.destroy(le);return}Q.byteLength===0&&this.keepAlive!==0||this.push(Q)===!1&&this.rawStream.pause()}_onhandshakert(T){if(this._handshakeDone===null||T!==null&&(T.data&&this._rawStream.write(T.data),!T.tx))return;const Q=this._handshakeDone,le=this._handshake.keyPair.publicKey;if(this._handshakeDone=null,this._handshake=null,T===null)return Q(new Error("Noise handshake failed"));this._setupSecretStream(T.tx,T.rx,T.hash,le,T.remotePublicKey),this._resolveOpened(!0),Q(null)}_setupSecretStream(T,Q,le,Y,oe){const ue=u.allocUnsafeSlow(3+_);v(_,ue),this._encrypt=new a(m(T.subarray(0,l)),void 0,ue.subarray(35)),this._decrypt=new n(m(Q.subarray(0,l))),this.publicKey=Y,this.remotePublicKey=oe,this.handshakeHash=le;const O=ue.subarray(3,35);w(le,this.isInitiator,O),this._setupSecretSend(le),this.emit("handshake"),this.rawStream!==this._rawStream&&this.rawStream.emit("handshake"),!this.destroying&&this._rawStream.write(ue)}_setupSecretSend(T){this._sendState=u.allocUnsafeSlow(80);const Q=this._sendState.subarray(0,32),le=this._sendState.subarray(32,64),Y=this._sendState.subarray(64,72),oe=this._sendState.subarray(72),ue=this.isInitiator?[[B,z],[M,z]]:[[M,z],[B,z]];y.crypto_generichash_batch(Q,ue[0],T),y.crypto_generichash_batch(le,ue[1],T),y.randombytes_buf(oe),Y.set(oe)}_open(T){if(this._rawStream===null||this._handshake===null&&this._encrypt===null){this._startDone=T;return}if(this._rawStream.on("data",this._onrawdata.bind(this)),this._rawStream.on("end",this._onrawend.bind(this)),this._rawStream.on("drain",this._onrawdrain.bind(this)),this.enableSend&&this._rawStream.on("message",this._onmessage.bind(this)),this._encrypt!==null)return this._resolveOpened(!0),T(null);this._handshakeDone=T,this.isInitiator&&this._onhandshakert(this._handshake.send())}_predestroy(){if(this.rawStream){const T=s(this);this.rawStream.destroy(T)}if(this._startDone!==null){const T=this._startDone;this._startDone=null,T(new Error("Stream destroyed"))}if(this._handshakeDone!==null){const T=this._handshakeDone;this._handshakeDone=null,T(new Error("Stream destroyed"))}if(this._drainDone!==null){const T=this._drainDone;this._drainDone=null,T(new Error("Stream destroyed"))}}_write(T,Q){let le=this._outgoingWrapped;if(T!==this._outgoingPlain?(le=u.allocUnsafe(T.byteLength+3+g),le.set(T,4)):this._outgoingWrapped=this._outgoingPlain=null,le.byteLength-3>j)return Q(new Error("Message is too large for an atomic write. Max size is "+j+" bytes."));this.rawBytesWritten+=le.byteLength,v(le.byteLength-3,le),this._encrypt.next(le.subarray(4,4+T.byteLength),le.subarray(3)),this._keepAliveTimer!==null&&this._keepAliveTimer.refresh(),this._rawStream.write(le)===!1?this._drainDone=Q:Q(null)}_final(T){this._clearKeepAlive(),this._ended--,this._rawStream.end(),T(null)}_resolveOpened(T){if(this._openedDone===null)return;const Q=this._openedDone;this._openedDone=null,Q(T),T&&(this.connected=!0,this.emit("connect"))}_clearTimeout(){this._timeoutTimer!==null&&(this._timeoutTimer.destroy(),this._timeoutTimer=null,this.timeout=0)}_clearKeepAlive(){this._keepAliveTimer!==null&&(this._keepAliveTimer.destroy(),this._keepAliveTimer=null,this.keepAlive=0)}_destroy(T){this._clearKeepAlive(),this._clearTimeout(),this._resolveOpened(!1),T(null)}_boxMessage(T){const Q=y.crypto_secretbox_MACBYTES,le=y.crypto_secretbox_NONCEBYTES,Y=this._sendState.subarray(64,72);if(y.sodium_increment(Y),u.equals(Y,this._sendState.subarray(72))){this.destroy(new Error("udp send nonce exchausted"));return}const oe=this._sendState.subarray(0,32),ue=u.allocUnsafe(8+Q+T.byteLength),O=ue.subarray(0,le),P=ue.subarray(8);return u.fill(O,0),O.set(Y),y.crypto_secretbox_easy(P,T,O,oe),ue}send(T){if(!this._sendState||!this.rawStream?.send)return;const Q=this._boxMessage(T);return this.rawStream.send(Q)}trySend(T){if(!this._sendState||!this.rawStream?.trySend)return;const Q=this._boxMessage(T);this.rawStream.trySend(Q)}_onmessage(T){if(!this._sendState)return;const Q=y.crypto_secretbox_MACBYTES,le=y.crypto_secretbox_NONCEBYTES;if(T.byteLength<le)return;const Y=u.allocUnsafe(le);u.fill(Y,0),Y.set(T.subarray(0,8));const oe=this._sendState.subarray(32,64),ue=T.subarray(8),O=T.subarray(8,T.byteLength-Q);if(ue.byteLength<Q)return;y.crypto_secretbox_open_easy(O,ue,Y,oe)&&this.emit("message",O)}alloc(T){const Q=u.allocUnsafe(T+3+g);return this._outgoingWrapped=Q,this._outgoingPlain=Q.subarray(4,Q.byteLength-g+1),this._outgoingPlain}toJSON(){return{isInitiator:this.isInitiator,publicKey:this.publicKey&&u.toString(this.publicKey,"hex"),remotePublicKey:this.remotePublicKey&&u.toString(this.remotePublicKey,"hex"),connected:this.connected,destroying:this.destroying,destroyed:this.destroyed,rawStream:this.rawStream&&this.rawStream.toJSON?this.rawStream.toJSON():null}}};function v(U,T){T[0]=U&255,T[1]=U>>>8&255,T[2]=U>>>16&255}function w(U,T,Q=u.allocUnsafe(32)){return y.crypto_generichash(Q,T?B:M,U),Q}function R(U){return typeof U=="string"?u.from(U):U}function A(){this.destroy(new Error("Stream timed out"))}function q(){const U=this.alloc(0);this.write(U)}return xu}var Eu,iw;function Yv(){return iw||(iw=1,Eu=class{constructor(){this.locked=!1,this.destroyed=!1,this._destroying=null,this._destroyError=null,this._queue=[],this._enqueue=(a,p)=>this._queue.push([a,p])}idle(){return this._queue.length===0&&this.locked===!1}lock(){return this.destroyed?Promise.reject(this._destroyError||new Error("Mutex has been destroyed")):this.locked?new Promise(this._enqueue):(this.locked=!0,Promise.resolve())}unlock(){if(!this._queue.length){this.locked=!1;return}this._queue.shift()[0]()}destroy(a){if(this._destroying||(this._destroying=this.locked?this.lock().catch(()=>{}):Promise.resolve()),this.destroyed=!0,a&&(this._destroyError=a),a)for(;this._queue.length;)this._queue.shift()[1](a);return this._destroying}}),Eu}var Ci={},sw;function tr(){if(sw)return Ci;sw=1;const n=_t(),a=sn(),p=Ue(),l=et(),[g,y,h,o,c,s]=n.namespace("hypercore",6);return Ci.MANIFEST=o,Ci.DEFAULT_NAMESPACE=c,Ci.DEFAULT_ENCRYPTION=s,Ci.replicate=function(u,f,m){const E=p.allocUnsafe(32);return a.crypto_generichash_batch(E,[u?y:h,f],m),E},Ci.treeSignable=function(u,f,m,E){const b={start:0,end:112,buffer:p.allocUnsafe(112)};return l.fixed32.encode(b,g),l.fixed32.encode(b,u),l.fixed32.encode(b,f),l.uint64.encode(b,m),l.uint64.encode(b,E),b.buffer},Ci.treeSignableCompat=function(u,f,m,E){const b=E?48:80,_={start:0,end:b,buffer:p.allocUnsafe(b)};return E||l.fixed32.encode(_,g),l.fixed32.encode(_,u),l.uint64.encode(_,f),l.uint64.encode(_,m),_.buffer},Ci}var Au,rw;function Lt(){return rw||(rw=1,Au=class je extends Error{constructor(a,p,l=je){super(`${p}: ${a}`),this.code=p,Error.captureStackTrace&&Error.captureStackTrace(this,l)}get name(){return"HypercoreError"}static ASSERTION(a){return new je(a,"ERR_ASSERTION",je.ASSERT)}static BAD_ARGUMENT(a){return new je(a,"BAD_ARGUMENT",je.BAD_ARGUMENT)}static STORAGE_EMPTY(a){return new je(a,"STORAGE_EMPTY",je.STORAGE_EMPTY)}static STORAGE_CONFLICT(a){return new je(a,"STORAGE_CONFLICT",je.STORAGE_CONFLICT)}static INVALID_SIGNATURE(a){return new je(a,"INVALID_SIGNATURE",je.INVALID_SIGNATURE)}static INVALID_CAPABILITY(a){return new je(a,"INVALID_CAPABILITY",je.INVALID_CAPABILITY)}static INVALID_CHECKSUM(a="Invalid checksum"){return new je(a,"INVALID_CHECKSUM",je.INVALID_CHECKSUM)}static INVALID_OPERATION(a){return new je(a,"INVALID_OPERATION",je.INVALID_OPERATION)}static INVALID_PROOF(a="Proof not verifiable"){return new je(a,"INVALID_PROOF",je.INVALID_PROOF)}static BLOCK_NOT_AVAILABLE(a="Block is not available"){return new je(a,"BLOCK_NOT_AVAILABLE",je.BLOCK_NOT_AVAILABLE)}static SNAPSHOT_NOT_AVAILABLE(a="Snapshot is not available"){return new je(a,"SNAPSHOT_NOT_AVAILABLE",je.SNAPSHOT_NOT_AVAILABLE)}static REQUEST_CANCELLED(a="Request was cancelled"){return new je(a,"REQUEST_CANCELLED",je.REQUEST_CANCELLED)}static REQUEST_TIMEOUT(a="Request timed out"){return new je(a,"REQUEST_TIMEOUT",je.REQUEST_TIMEOUT)}static SESSION_NOT_WRITABLE(a="Session is not writable"){return new je(a,"SESSION_NOT_WRITABLE",je.SESSION_NOT_WRITABLE)}static SESSION_CLOSED(a="Session is closed"){return new je(a,"SESSION_CLOSED",je.SESSION_CLOSED)}static BATCH_UNFLUSHED(a="Batch not yet flushed"){return new je(a,"BATCH_UNFLUSHED",je.BATCH_UNFLUSHED)}static BATCH_ALREADY_EXISTS(a="Batch already exists"){return new je(a,"BATCH_ALREADY_EXISTS",je.BATCH_ALREADY_EXISTS)}static BATCH_ALREADY_FLUSHED(a="Batch has already been flushed"){return new je(a,"BATCH_ALREADY_FLUSHED",je.BATCH_ALREADY_FLUSHED)}static OPLOG_CORRUPT(a="Oplog file appears corrupt or out of date"){return new je(a,"OPLOG_CORRUPT",je.OPLOG_CORRUPT)}static OPLOG_HEADER_OVERFLOW(a="Oplog header exceeds page size"){return new je(a,"OPLOG_HEADER_OVERFLOW",je.OPLOG_HEADER_OVERFLOW)}static INVALID_OPLOG_VERSION(a="Invalid header version"){return new je(a,"INVALID_OPLOG_VERSION",je.INVALID_OPLOG_VERSION)}static WRITE_FAILED(a="Write to storage failed"){return new je(a,"WRITE_FAILED",je.WRITE_FAILED)}static DECODING_ERROR(a="Decoding error"){return new je(a,"DECODING_ERROR",je.DECODING_ERROR)}static SESSION_MOVED(a="Session moved"){return new je(a,"SESSION_MOVED",je.SESSION_MOVED)}}),Au}var Ru,ow;function nr(){if(ow)return Ru;ow=1;const n=rn(),a=_t(),p=Ue(),l=Xt(),g=tr(),{INVALID_PROOF:y,INVALID_CHECKSUM:h,INVALID_OPERATION:o,BAD_ARGUMENT:c,ASSERTION:s}=Lt();class u{constructor(d,k=null){this.i=0,this.nodes=d,this.extra=k,this.length=d.length+(this.extra===null?0:1)}shift(d){if(this.extra!==null&&this.extra.index===d){const X=this.extra;return this.extra=null,this.length--,X}if(this.i>=this.nodes.length)throw o("Expected node "+d+", got (nil)");const k=this.nodes[this.i++];if(k.index!==d)throw o("Expected node "+d+", got node "+k.index);return this.length--,k}}class f{constructor(d){this.fork=d.fork,this.roots=[...d.roots],this.length=d.length,this.signature=d.signature,this.ancestors=d.length,this.byteLength=d.byteLength,this.prologue=d.prologue,this.hashCached=null,this.committed=!1,this.truncated=!1,this.treeLength=d.length,this.treeFork=d.fork,this.storage=d.storage,this.session=d,this.nodes=[],this.upgraded=!1}checkout(d,k){const X=[];let ie=0;const I=2*d-2,L=new Set,V=new Map;if(k)for(const te of k)V.set(te.index,te);for(const te of this.nodes)V.set(te.index,te);for(const te of n.fullRoots(I+2)){const de=n.leftSpan(te);if(de!==0&&L.add(de-1),ie<this.roots.length&&this.roots[ie].index===te){X.push(this.roots[ie++]);continue}const C=V.get(te);if(!C)throw new c("root missing for given length");X.push(C)}this.roots=X,this.length=d,this.byteLength=O(X),this.hashCached=null,this.signature=null;for(let te=0;te<this.nodes.length;te++){const de=this.nodes[te].index;if(de<=I&&!L.has(de))continue;const C=this.nodes.pop();te<this.nodes.length&&(this.nodes[te--]=C)}}prune(d){if(d===0)return;const k=2*d-2,X=new Set;for(const ie of n.fullRoots(k+2)){const I=n.leftSpan(ie);I!==0&&X.add(I-1)}for(let ie=0;ie<this.nodes.length;ie++){const I=this.nodes[ie].index;if(I>k||X.has(I))continue;const L=this.nodes.pop();ie<this.nodes.length&&(this.nodes[ie--]=L)}}clone(){const d=new f(this.session);return d.fork=this.fork,d.roots=[...this.roots],d.length=this.length,d.byteLength=this.byteLength,d.signature=this.signature,d.treeLength=this.treeLength,d.treeFork=this.treeFork,d.tree=this.tree,d.nodes=[...this.nodes],d.upgraded=this.upgraded,d}hash(){return this.hashCached===null&&(this.hashCached=l(a.tree(this.roots))),this.hashCached}signable(d){return g.treeSignable(d,this.hash(),this.length,this.fork)}signableCompat(d){return g.treeSignableCompat(this.hash(),this.length,this.fork,d)}get(d){if(d>=this.length*2)return null;for(const k of this.nodes)if(k.index===d)return k;return $(this.session.storage,d)}proof(d,{block:k,hash:X,seek:ie,upgrade:I}){return D(this.session,d,k,X,ie,I)}verifyUpgrade(d){const k=R(d,this.nodes);if(!d.upgrade)throw o("Expected upgrade proof");return A(d,k,this)}addNodesUnsafe(d){for(let k=0;k<d.length;k++)this.nodes.push(d[k])}append(d){const k=this.length*2,X=n.iterator(k),ie=Z(k,d);this.appendRoot(ie,X)}appendRoot(d,k){for(d=ce(d),this.hashCached=null,this.upgraded=!0,this.length+=k.factor/2,this.byteLength+=d.size,this.roots.push(d),this.nodes.push(d);this.roots.length>1;){const X=this.roots[this.roots.length-1],ie=this.roots[this.roots.length-2];if(k.sibling()!==ie.index){k.sibling();break}const I=ce(he(k.parent(),X,ie));this.nodes.push(I),this.roots.pop(),this.roots.pop(),this.roots.push(I)}}commitable(){return this.treeFork===this.session.fork&&(this.upgraded?this.treeLength===this.session.length:this.treeLength<=this.session.length)}commit(d){if(d===void 0)throw o("No database batch was passed");if(!this.commitable())throw o("Tree was modified during batch, refusing to commit");this.upgraded&&this._commitUpgrade(d);for(let k=0;k<this.nodes.length;k++){const X=this.nodes[k];d.putTreeNode(X)}return this.committed=!0,this}_commitUpgrade(d){if(this.ancestors<this.treeLength&&(d.deleteTreeNodeRange(this.ancestors*2,this.treeLength*2),this.ancestors>0)){const k=this.ancestors*2,X=n.iterator(k-2);for(;X.contains(k)&&X.index<k&&d.deleteTreeNode(X.index),X.offset!==0;)X.parent();this.truncated=!0}}seek(d,k){return new E(this,this,d,k)}byteRange(d){const k=this.storage.read(),X=w(this,d,k);return k.tryFlush(),X}byteOffset(d){if(d===2*this.length)return this.byteLength;const k=this.storage.read(),X=z(this,d,k);return k.tryFlush(),X}async restore(d){if(d===this.length)return this;const k=_e(await _.getRootsFromStorage(this.storage,d));this.roots=k,this.length=d,this.byteLength=O(k),this.ancestors=d;for(const X of k)this.byteLength+=X.size;return this}}class m extends f{constructor(d){super(d),this.roots=[],this.length=0,this.byteLength=0,this.diff=null,this.ancestors=0,this.upgraded=!0,this.want={nodes:0,start:0,end:0}}get finished(){return this.want===null}update(d){if(this.want===null)return!0;const k=[],X=R(d,k);return X===null||!p.equals(X.hash,this.diff.hash)?!1:(this.nodes.push(...k),this._update(k))}async _update(d){const k=new Map;for(const L of d)k.set(L.index,L);let X=null;const ie=n.iterator(this.diff.index),I=this.diff;for(;(ie.index&1)!==0;){const L=k.get(ie.leftChild());if(!L)break;const V=await $(this.session.storage,L.index);!V||!p.equals(V.hash,L.hash)?X=L:X=k.get(ie.sibling())}return(this.diff.index&1)===0?!0:X===null||I!==this.diff?!1:this._updateDiffRoot(X)}_updateDiffRoot(d){if(this.want===null)return!0;const k=n.spans(d.index),X=k[0]/2,ie=Math.min(this.treeLength,k[1]/2+1),I=ie-X;return this.ancestors=X,this.diff=d,(d.index&1)===0||this.want.start>=this.treeLength||I<=0?(this.want=null,!0):(this.want.start=X,this.want.end=ie,this.want.nodes=se(k[1]-k[0]+2)-1,!1)}}class E{constructor(d,k,X=0){this.session=d,this.bytes=k,this.padding=X;const ie=d.byteLength-d.length*X;this.start=k>=ie?d.length:0,this.end=k<ie?d.length:0}async _seek(d){if(!d)return[0,0];for(const k of this.session.roots){const X=H(k,this.padding,null);if(d===X)return[n.rightSpan(k.index)+2,0];if(d>X){d-=X;continue}const ie=n.iterator(k.index);for(;(ie.index&1)!==0;){const I=await $(this.session.storage,ie.leftChild());if(I){const L=H(I,this.padding,ie);if(L===d)return[ie.rightSpan()+2,0];if(L>d)continue;d-=L,ie.sibling()}else return ie.parent(),[ie.index,d]}return[ie.index,d]}return null}async update(){const d=await this._seek(this.bytes);if(!d)return null;if((d[0]&1)===0)return[d[0]/2,d[1]];const k=n.spans(d[0]);return this.start=k[0]/2,this.end=k[1]/2+1,null}}class b{constructor(d,k,X,ie,I){this.fork=d.fork,this.signature=d.signature,this.block=k,this.hash=X,this.seek=ie,this.upgrade=I,this.pending={node:null,seek:null,upgrade:null,additionalUpgrade:null}}async settle(){const d={fork:this.fork,block:null,hash:null,seek:null,upgrade:null,manifest:null},[k,X,ie,I]=await N(this.pending);if(this.block){if(k===null)throw o("Invalid block request");d.block={index:this.block.index,value:null,nodes:k}}else if(this.hash){if(k===null)throw o("Invalid block request");d.hash={index:this.hash.index,nodes:k}}return this.seek&&X!==null&&(d.seek={bytes:this.seek.bytes,nodes:X}),this.upgrade&&(d.upgrade={start:this.upgrade.start,length:this.upgrade.length,nodes:ie,additionalNodes:I||[],signature:this.signature}),d}}class _{static hash(d){return l(a.tree(d.roots))}static signable(d,k){return g.treeSignable(k,_.hash(d),d.length,d.fork)}static size(d){return O(d)}static span(d){return P(d)}static getRoots(d,k){return _.getRootsFromStorage(d.storage,k)}static getRootsFromStorage(d,k){const X=n.fullRoots(2*k),ie=new Array(X.length),I=d.read();for(let L=0;L<X.length;L++)ie[L]=re(I,X[L]);return I.tryFlush(),Promise.all(ie)}static async upgradeable(d,k){const X=n.fullRoots(2*k),ie=new Array(X.length),I=d.storage.read();for(let L=0;L<X.length;L++)ie[L]=I.getTreeNode(X[L]);I.tryFlush();for(const L of await Promise.all(ie))if(L===null)return!1;return!0}static seek(d,k,X){return new E(d,k,X)}static get(d,k){return $(d.storage,k)}static async truncate(d,k,X,ie=X.fork){const I=k*2,L=n.fullRoots(I);for(let V=0;V<L.length;V++){const te=L[V];if(!(V<X.roots.length&&X.roots[V].index===te)){for(;X.roots.length>V;)X.roots.pop();X.roots.push(ce(await W(d.storage,te)))}}for(;X.roots.length>L.length;)X.roots.pop();return X.fork=ie,X.length=k,X.ancestors=k,X.byteLength=O(X.roots),X.upgraded=!0,X}static async reorg(d,k,X){let ie=null;if((k.block||k.hash||k.seek)&&(ie=R(k,X.nodes)),!A(k,ie,X))throw y("Fork proof not verifiable");for(const I of X.roots){const L=await $(d.storage,I.index);if(!(L&&p.equals(L.hash,I.hash))){X._updateDiffRoot(I);break}}return X.diff!==null?await X._update(X.nodes):(X.want=null,X.ancestors=X.length),X}static verifyFullyRemote(d,k){const X=new f(d);X.fork=k.fork,X.roots=[],X.length=0,X.ancestors=0,X.byteLength=0;let ie=R(k,X.nodes);return k.upgrade&&A(k,ie,X)&&(ie=null),X}static async verify(d,k){const X=new f(d);let ie=R(k,X.nodes);if(k.upgrade&&A(k,ie,X)&&(ie=null),ie){const I=await W(d.storage,ie.index);if(!p.equals(I.hash,ie.hash))throw h("Invalid checksum at node "+ie.index)}return X}static proof(d,k,{block:X,hash:ie,seek:I,upgrade:L}){return D(d,k,X,ie,I,L)}static async missingNodes(d,k,X){const ie=2*X,I=n.iterator(k);if(I.index+I.factor/2-1>=ie)return 0;let V=0;for(;!I.contains(ie)&&!await S(d.storage,I.index);)V++,I.parent();return V}static byteOffset(d,k){return M(d,k,null)}static byteRange(d,k){const X=d.storage.read(),ie=M(d,k,X),I=B(k,X);return X.tryFlush(),Promise.all([ie,I])}}Ru={MerkleTreeBatch:f,ReorgBatch:m,MerkleTree:_};async function B(J,d){return(await re(d,J)).size}async function M(J,d,k){if(d===2*J.length)return J.byteLength;const X=k===null?await j(J.roots,d,J.storage.read()):await v(J.roots,d,k);let ie=0;for(const I of X)ie+=I.size;return ie}async function z(J,d,k){if(d===2*J.length)return J.byteLength;const X=await v(J.roots,d,k);let ie=0;for(const I of X)ie+=I.size;return ie}function j(J,d,k){const X=v(J,d,k);return k.tryFlush(),X}function v(J,d,k){(d&1)===1&&(d=n.leftSpan(d));let X=0;const ie=[];for(const I of J){if(X+=2*(I.index-X+1),d>=X){ie.push(I.size);continue}const L=n.iterator(I.index);for(;L.index!==d;)d<L.index?L.leftChild():(ie.push(re(k,L.leftChild())),L.sibling());return Promise.all(ie)}throw s("Failed to find offset")}function w(J,d,k){const X=2*J.length;if(((d&1)===0?d:n.rightSpan(d))>=X)throw c("Index is out of bounds");const ie=z(J,d,k),I=B(d,k);return Promise.all([ie,I])}function R({block:J,hash:d,seek:k},X){const ie=J?{index:2*J.index,value:J.value,nodes:J.nodes}:d?{index:d.index,value:null,nodes:d.nodes}:null;if(ie===null&&(!k||!k.nodes.length))return null;let I=null;if(k&&k.nodes.length){const de=n.iterator(k.nodes[0].index),C=new u(k.nodes);for(I=C.shift(de.index),X.push(I);C.length>0;){const ee=C.shift(de.sibling());I=he(de.parent(),I,ee),X.push(ee),X.push(I)}}if(ie===null)return I;const L=n.iterator(ie.index),V=ie.value&&Z(L.index,ie.value),te=new u(ie.nodes,I);for(I=V||te.shift(L.index),X.push(I);te.length>0;){const de=te.shift(L.sibling());I=he(L.parent(),I,de),X.push(de),X.push(I)}return I}function A({fork:J,upgrade:d},k,X){const ie=X.prologue;if(ie){const{start:ee,length:fe}=d;if(ee<ie.length&&(ee!==0||fe<ie.length))throw y("Upgrade does not satisfy prologue")}const I=new u(d.nodes,k);let L=X.roots.length>0,V=0;const te=2*(d.start+d.length),de=n.iterator(0);for(;de.fullRoot(te);de.nextTree()){if(V<X.roots.length&&X.roots[V].index===de.index){V++;continue}if(L){L=!1;const ee=de.index;if(V<X.roots.length){for(de.seek(X.roots[X.roots.length-1].index);de.index!==ee;)X.appendRoot(I.shift(de.sibling()),de);continue}}X.appendRoot(I.shift(de.index),de)}if(ie&&X.length===ie.length&&!p.equals(ie.hash,X.hash()))throw y("Invalid hash");const C=d.additionalNodes;for(de.seek(X.roots[X.roots.length-1].index),V=0;V<C.length&&C[V].index===de.sibling();)X.appendRoot(C[V++],de);for(;V<C.length;){const ee=C[V++];for(;ee.index!==de.index;){if(de.factor===2)throw o("Unexpected node: "+ee.index);de.leftChild()}X.appendRoot(ee,de),de.sibling()}return X.signature=l(d.signature),X.fork=J,I.extra===null}async function q(J,d,k,X){const ie=n.fullRoots(d);for(let I=0;I<ie.length;I++){const L=ie[I],V=await $(J.storage,L),te=H(V,X,null);if(k===te)return L;if(k>te){k-=te;continue}return U(J,L,k,X)}return d}async function U(J,d,k,X){if(!k)return d;const ie=n.iterator(d);for(;(ie.index&1)!==0;){const I=await $(J.storage,ie.leftChild());if(I){const L=H(I,X,ie);if(L===k)return ie.index;if(L>k)continue;k-=L,ie.sibling()}else return ie.parent(),ie.index}return ie.index}async function T(J,d,k,X){const ie=await M(J,d,null)-(X?X*n.leftSpan(d)/2:0);if(ie>k)throw o("Invalid seek");if(ie===k)return d;k-=ie;const I=await W(J.storage,d);if(H(I,X,null)<=k)throw o("Invalid seek");return U(J,d,k,X)}function Q(J,d,k,X,ie){const I=n.iterator(k);for(ie.seek=[],ie.seek.push(re(d,I.index));I.index!==X;)I.sibling(),ie.seek.push(re(d,I.index)),I.parent()}function le(J,d,k,X,ie,I,L){if(!k)return Q(J,d,ie,I,L);const V=n.iterator(k.index);for(L.node=[],k.value||L.node.push(re(d,V.index));V.index!==I;)V.sibling(),X&&V.contains(ie)&&V.index!==ie?Q(J,d,ie,V.index,L):L.node.push(re(d,V.index)),V.parent()}function Y(J,d,k,X,ie,I,L,V){ie===0&&(V.upgrade=[]);for(const te=n.iterator(0);te.fullRoot(I);te.nextTree())if(!(te.index+te.factor/2<ie)){if(V.upgrade===null&&te.contains(ie-2)){V.upgrade=[];const de=te.index,C=ie-2;for(te.seek(C);te.index!==de;)te.sibling(),te.index>C&&(V.node===null&&V.seek===null&&te.contains(L)?le(J,d,k,X,L,te.index,V):V.upgrade.push(re(d,te.index))),te.parent();continue}if(V.upgrade===null&&(V.upgrade=[]),V.node===null&&V.seek===null&&te.contains(L)){le(J,d,k,X,L,te.index,V);continue}V.upgrade.push(re(d,te.index))}}function oe(J,d,k,X,ie){k===0&&(ie.additionalUpgrade=[]);for(const I=n.iterator(0);I.fullRoot(X);I.nextTree())if(!(I.index+I.factor/2<k)){if(ie.additionalUpgrade===null&&I.contains(k-2)){ie.additionalUpgrade=[];const L=I.index,V=k-2;for(I.seek(V);I.index!==L;)I.sibling(),I.index>V&&ie.additionalUpgrade.push(re(d,I.index)),I.parent();continue}ie.additionalUpgrade===null&&(ie.additionalUpgrade=[]),ie.additionalUpgrade.push(re(d,I.index))}}function ue(J,d,k){const X=n.iterator(J);for(let ie=0;ie<d;ie++)if(X.parent(),X.contains(k))throw c("Nodes is out of bounds");return X.index}function O(J){let d=0;for(const k of J)d+=k.size;return d}function P(J){let d=0;for(const k of J)d+=2*(k.index-d+1);return d}function Z(J,d){return{index:J,size:d.byteLength,hash:a.data(d)}}function he(J,d,k){return{index:J,size:d.size+k.size,hash:a.parent(d,k)}}function se(J){let d=1;for(;J>2;)J/=2,d++;return d}function G(J,d){return J?{value:!0,index:J.index*2,nodes:J.nodes,lastIndex:J.index}:d?{value:!1,index:d.index,nodes:d.nodes,lastIndex:n.rightSpan(d.index)/2}:null}async function re(J,d){const k=await J.getTreeNode(d);if(k===null)throw o("Expected tree node "+d+" from storage, got (nil)");return k}function W(J,d){const k=J.read(),X=re(k,d);return k.tryFlush(),X}function $(J,d){const k=J.read(),X=k.getTreeNode(d);return k.tryFlush(),X}function S(J,d){const k=J.read(),X=k.hasTreeNode(d);return k.tryFlush(),X}async function N(J){const d=[J.node&&Promise.all(J.node),J.seek&&Promise.all(J.seek),J.upgrade&&Promise.all(J.upgrade),J.additionalUpgrade&&Promise.all(J.additionalUpgrade)];try{return await Promise.all(d)}catch(k){throw J.node&&await Promise.allSettled(J.node),J.seek&&await Promise.allSettled(J.seek),J.upgrade&&await Promise.allSettled(J.upgrade),J.additionalUpgrade&&await Promise.allSettled(J.additionalUpgrade),k}}async function D(J,d,k,X,ie,I){J.prologue&&I&&(I.start=I.start<J.prologue.length?0:I.start,I.length=I.start<J.prologue.length?J.prologue.length:I.length);const L=2*J.length,V=I?I.start*2:0,te=I?V+I.length*2:L,de=G(k,X);if(L===0)return new b(J,null,null,null,null);if(V>=te||te>L)throw o("Invalid upgrade");if(ie&&I&&de!==null&&de.index>=V)throw o("Cannot both do a seek and block/hash request when upgrading");let C=L;const ee=new b(J,k,X,ie,I);if(de!==null&&(!I||de.lastIndex<I.start)){C=ue(de.index,de.nodes,te);const fe=ie?await T(J,C,ie.bytes,ie.padding):L;le(J,d,de,ie,fe,C,ee.pending)}else(de||ie)&&I&&(C=ie?await q(J,te,ie.bytes,ie.padding):de.index);return I&&(Y(J,d,de,ie,V,te,C,ee.pending),L>te&&oe(J,d,te,L,ee.pending)),ee}function H(J,d,k){return d===0?J.size:J.size-d*(k?k.countLeaves():n.countLeaves(J.index))}function _e(J){for(const d of J)ce(d);return J}function ce(J){return J===null||(J.hash=l(J.hash)),J}return Ru}var Lu={},ei={},Qt={},os={},aw;function wS(){if(aw)return os;aw=1;const n=os.clz=function(l){return Math.clz32(l)};os.clo=function(l){return n(~l)};const a=os.ctz=function(l){return 32-(l===0?0:n(l&-l)+1)};return os.cto=function(l){return a(~l)},os.cnt=function(l){return l=l-(l>>>1&1431655765),l=(l&858993459)+(l>>>2&858993459),l=l+(l>>>4)&252645135,l=l*16843009>>>24,l},os}var lw;function bS(){if(lw)return Qt;lw=1;const n=Ue(),a=wS();function p(h,o){if(o===h.BYTES_PER_ELEMENT)return h;let c;return o===1?c=Uint8Array:o===2?c=Uint16Array:c=Uint32Array,new c(h.buffer,h.byteOffset,h.byteLength/o)}function l(h,o=h,c=o){return function(u,f=n.allocUnsafe(u.byteLength)){if(u.byteLength%16!==0)throw new Error("Buffer length must be a multiple of 16");if(u.byteLength!==f.byteLength)throw new Error("Length of result buffer is insufficient");const m=u.BYTES_PER_ELEMENT;return m===1?h(u,p(f,m)):m===2?o(u,p(f,m)):c(u,p(f,m)),f}}function g(h,o=h,c=o){return function(u,f,m=n.allocUnsafe(u.byteLength)){if(u.byteLength%16!==0)throw new Error("Buffer length must be a multiple of 16");if(u.byteLength!==f.byteLength||u.byteLength!==m.byteLength)throw new Error("Buffers must be the same length");const E=u.BYTES_PER_ELEMENT;return E===1?h(u,f,p(m,E)):E===2?o(u,f,p(m,E)):c(u,f,p(m,E)),m}}function y(h,o=h,c=o){return function(u){if(u.byteLength%16!==0)throw new Error("Buffer length must be a multiple of 16");const f=u.BYTES_PER_ELEMENT;return f===1?h(u):f===2?o(u):c(u)}}return Qt.allo=function(o){if(o.byteLength%16!==0)throw new Error("Buffer length must be a multiple of 16");const c=2**(o.BYTES_PER_ELEMENT*8)-1;for(let s=0,u=o.length;s<u;s++)if(o[s]!==c)return!1;return!0},Qt.allz=function(o){if(o.byteLength%16!==0)throw new Error("Buffer length must be a multiple of 16");for(let c=0,s=o.length;c<s;c++)if(o[c]!==0)return!1;return!0},Qt.and=g((h,o,c)=>{for(let s=0,u=c.length;s<u;s++)c[s]=h[s]&o[s]}),Qt.clear=g((h,o,c)=>{for(let s=0,u=c.length;s<u;s++)c[s]=h[s]&~o[s]}),Qt.clo=l((h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=24-a.clo(h[c])},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=16-a.clo(h[c])},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=a.clo(h[c])}),Qt.clz=l((h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=24-a.clz(h[c])},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=16-a.clz(h[c])},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=a.clz(h[c])}),Qt.cnt=l((h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=a.cnt(h[c])&255},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=a.cnt(h[c])&65535},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=a.cnt(h[c])}),Qt.cto=l((h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=Math.min(a.cto(h[c]),8)},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=Math.min(a.cto(h[c]),16)},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=a.cto(h[c])}),Qt.ctz=l((h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=Math.min(a.ctz(h[c]),8)},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=Math.min(a.ctz(h[c]),16)},(h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=a.ctz(h[c])}),Qt.not=l((h,o)=>{for(let c=0,s=h.length;c<s;c++)o[c]=~h[c]}),Qt.or=g((h,o,c)=>{for(let s=0,u=c.length;s<u;s++)c[s]=h[s]|o[s]}),Qt.sum=y(h=>{let o=0n;for(let c=0,s=h.length;c<s;c++)o+=BigInt(h[c]);return o}),Qt.xor=g((h,o,c)=>{for(let s=0,u=c.length;s<u;s++)c[s]=h[s]^o[s]}),Qt}var cw;function er(){if(cw)return ei;cw=1;const n=bS(),a=(16+128*16)*2,p=ei.get=function(f,m){const E=f.byteLength*8;if(m<0&&(m+=E),m<0||m>=E)return!1;const b=f.BYTES_PER_ELEMENT*8,_=m&b-1,B=(m-_)/b;return(f[B]&1<<_)!==0},l=ei.set=function(f,m,E=!0){const b=f.byteLength*8;if(m<0&&(m+=b),m<0||m>=b)return!1;const _=f.BYTES_PER_ELEMENT*8,B=m&_-1,M=(m-B)/_,z=1<<B;if(E){if((f[M]&z)!==0)return!1}else if((f[M]&z)===0)return!1;return f[M]^=z,!0};ei.fill=function(f,m,E=0,b=f.byteLength*8){const _=f.byteLength*8;if(E<0&&(E+=_),b<0&&(b+=_),E<0||E>=f.byteLength*8||E>=b)return f;const B=f.BYTES_PER_ELEMENT*8;let M,z;{const j=E&B-1;if(M=(E-j)/B,j!==0){let v=B-j;b-E<v&&(v=b-E);const w=(1<<v)-1<<j;m?f[M]|=w:f[M]&=~w,M++}}{const j=b&B-1;if(z=(b-j)/B,j!==0&&z>=M){const v=(1<<j)-1;m?f[z]|=v:f[z]&=~v}}return M<z&&f.fill(m?2**B-1:0,M,z),f},ei.clear=function(f,...m){const E=f.byteLength;for(const b of m){if(b.offset>=E)continue;const _=b.field.byteLength;let B=b.offset,M=0;for(;((B&15)!==0||(M&15)!==0)&&B<E&&M<_;)f[B]=f[B]&~b.field[M],B++,M++;if(B+15<E&&M+15<_){const z=Math.min(E-(E&15)-B,_-(_&15)-M);n.clear(f.subarray(B,B+z),b.field.subarray(M,M+z),f.subarray(B,B+z))}for(;B<E&&M<_;)f[B]=f[B]&~b.field[M],B++,M++}};function g(u,f){return u?a*8/2+f:f}function y(u,f){return u?a/2+f:f}ei.findFirst=function(f,m,E=0){const b=f.byteLength*8;if(E<0&&(E+=b),E<0&&(E=0),E>=b)return-1;m=!!m;for(let _=E;_<b;_++)if(p(f,_)===m)return _;return-1},ei.findLast=function(f,m,E=f.byteLength*8-1){const b=f.byteLength*8;if(E<0&&(E+=b),E<0)return-1;E>=b&&(E=b-1),m=!!m;for(let _=E;_>=0;_--)if(p(f,_)===m)return _;return-1};const h=ei.Index=class{static from(f,m=-1){return Array.isArray(f)?new s(f,m):new o(f,m)}constructor(f){this._byteLength=f,this.handle=new Uint32Array(a/4)}get byteLength(){return this._byteLength}skipFirst(f,m=0){const E=this.byteLength*8;if(m<0&&(m+=E),m<0&&(m=0),m>=E)return E-1;let b=Math.floor(m/16384);if(b>127)return m;for(;b<=127&&p(this.handle,g(f,b));)b++;if(b===128)return E-1;let _=b*16384,B=0;for(m>_&&(B=Math.floor((m-_)/128));B<=127&&p(this.handle,g(f,b*128+B+128));)B++,_+=128;return B===128&&b!==127?this.skipFirst(f,(b+1)*16384):(_>m&&(m=_),m<E?m:E-1)}skipLast(f,m=this.byteLength*8-1){const E=this.byteLength*8;if(m<0&&(m+=E),m<0)return 0;m>=E&&(m=E-1);let b=Math.floor(m/16384);if(b>127)return m;for(;b>=0&&p(this.handle,g(f,b));)b--;if(b===-1)return 0;let _=(b+1)*16384-1,B=127;for(m<_&&(B=128-Math.ceil((_-m)/128));B>=0&&p(this.handle,g(f,b*128+B+128));)B--,_-=128;return B===-1&&b!==0?this.skipLast(f,b*16384-1):(_<m&&(m=_),m)}};class o extends h{constructor(f,m){super(m),this.field=f;const E=f.BYTES_PER_ELEMENT;for(let b=0;b<128;b++){for(let _=0;_<128;_++){const B=(b*128+_)*16;let M=!0,z=!1;if(B+16<=this.field.byteLength){const v=this.field.subarray(B/E,(B+16)/E);M=n.allz(v),z=n.allo(v)}const j=b*128+128+_;l(this.handle,g(!1,j),M),l(this.handle,g(!0,j),z)}{const _=y(!1,b*16+16)/4,B=n.allo(this.handle.subarray(_,_+4));l(this.handle,g(!1,b),B)}{const _=y(!0,b*16+16)/4,B=n.allo(this.handle.subarray(_,_+4));l(this.handle,g(!0,b),B)}}}get byteLength(){return this._byteLength!==-1?this._byteLength:this.field.byteLength}update(f){const m=this.byteLength*8;if(f<0&&(f+=m),f<0||f>=m)return!1;const E=this.field.BYTES_PER_ELEMENT,b=Math.floor(f/16384),_=Math.floor(f/128),B=_*16/E,M=this.field.subarray(B,B+16/E),z=n.allz(M),j=n.allo(M);let v=!1;if(l(this.handle,g(!1,128+_),z)){v=!0;const w=y(!1,b*16+16)/4,R=n.allo(this.handle.subarray(w,w+4));l(this.handle,g(!1,b),R)}if(l(this.handle,g(!0,128+_),j)){v=!0;const w=y(!0,b*16+16)/4,R=n.allo(this.handle.subarray(w,w+4));l(this.handle,g(!0,b),R)}return v}}function c(u,f){for(let m=0;m<u.length;m++){const E=u[m],b=E.offset,_=E.offset+E.field.byteLength;if(f>=b&&f+16<=_)return E}return null}class s extends h{constructor(f,m){super(m),this.chunks=f;for(let E=0;E<128;E++){for(let b=0;b<128;b++){const _=(E*128+b)*16;let B=!0,M=!1;const z=c(this.chunks,_);if(z!==null){const v=z.field.BYTES_PER_ELEMENT,w=z.field.subarray((_-z.offset)/v,(_-z.offset+16)/v);B=n.allz(w),M=n.allo(w)}const j=E*128+128+b;l(this.handle,g(!1,j),B),l(this.handle,g(!0,j),M)}{const b=y(!1,E*16+16)/4,_=n.allo(this.handle.subarray(b,b+4));l(this.handle,g(!1,E),_)}{const b=y(!0,E*16+16)/4,_=n.allo(this.handle.subarray(b,b+4));l(this.handle,g(!0,E),_)}}}get byteLength(){if(this._byteLength!==-1)return this._byteLength;const f=this.chunks[this.chunks.length-1];return f?f.offset+f.field.byteLength:0}update(f){const m=this.byteLength*8;if(f<0&&(f+=m),f<0||f>=m)return!1;const E=Math.floor(f/16384),b=Math.floor(f/128),_=b*16,B=c(this.chunks,_);if(B===null)return!1;const M=B.field.BYTES_PER_ELEMENT,z=B.field.subarray((_-B.offset)/M,(_-B.offset+16)/M),j=n.allz(z),v=n.allo(z);let w=!1;if(l(this.handle,g(!1,128+b),j)){w=!0;const R=y(!1,E*16+16)/4,A=n.allo(this.handle.subarray(R,R+4));l(this.handle,g(!1,E),A)}if(l(this.handle,g(!0,128+b),v)){w=!0;const R=y(!0,E*16+16)/4,A=n.allo(this.handle.subarray(R,R+4));l(this.handle,g(!0,E),A)}return w}}return ei}var hw;function jf(){if(hw)return Lu;hw=1;let n=er();return(typeof n.findFirst!="function"||typeof n.findLast!="function"||typeof n.clear!="function")&&(n=er()),Lu.quickbit=n,Lu}var Tu,uw;function vS(){if(uw)return Tu;uw=1;const n=Ue(),a=jf().quickbit;Tu=class{constructor(){this.ranges=[]}contiguousLength(g){for(const y of this.ranges){if(y.start>g)break;if(!y.value&&y.start<=g)return y.start}for(;this.get(g)===!0;)g++;return g}get(g){let y=0,h=this.ranges.length;for(;y<h;){const o=y+h>>1,c=this.ranges[o];if(g<c.start){h=o;continue}if(g>=c.end){if(o===y)break;y=o;continue}return c.value}return!1}setRange(g,y,h){if(g===y)return;let o=null;for(let c=0;c<this.ranges.length;c++){if(o=this.ranges[c],o.start<=g&&y<=o.end){if(h===o.value)return;const u=p(o,{start:g,end:y,value:h});this.ranges.splice(c,1,...u);return}if(g>o.end)continue;if(y>=o.start&&y<=o.end){o.start=o.value===h?g:y,o.value!==h&&this.ranges.splice(c,0,{start:g,end:y,value:h});return}if(g>=o.start&&g<=o.end){if(o.value!==h){this.ranges.splice(++c,0,{start:g,end:y,value:h}),o.end=g;return}g=o.start}let s=0;for(let u=c;u<this.ranges.length;u++){const f=this.ranges[u];if(f.start>y||f.value!==h)break;f.start<=y&&f.end>y&&(y=f.end),s++}this.ranges.splice(c,s,{start:g,end:y,value:h});return}if(o!==null){if(g<=o.end&&y>o.end){o.end=y;return}if(o.end>g)return}this.ranges.push({start:g,end:y,value:h})}flush(g,y){if(!this.ranges.length)return[];let h=this.ranges[0].start;const o=this.ranges[this.ranges.length-1].end;let c=0;for(;h<o;){const s=y.getBitfield(h),u=s?s.index:y.getPageIndex(h),f=n.allocUnsafe(y.getPageByteLength());if(s){const _=s.bitfield;f.set(n.from(_.buffer,_.byteOffset,_.byteLength),0)}else n.fill(f,0);const m=(u+1)*(f.byteLength<<3),E=u*(f.byteLength<<3);let b=!1;for(;c<this.ranges.length;){const{start:_,end:B,value:M}=this.ranges[c];!b&&M&&(b=!0);const z=_<h?h:_,j=B<m?B:m;if(a.fill(f,M,z-E,j-E),h=j,j===m)break;c++}(s||b)&&g.putBitfieldPage(u,f)}return this.ranges}};function p(l,g){const y=[];return l.start<g.start&&y.push({start:l.start,end:g.start,value:l.value}),y.push({start:g.start,end:g.end,value:g.value}),g.end<l.end&&y.push({start:g.end,end:l.end,value:l.value}),y}return Tu}var Du,dw;function ll(){if(dw)return Du;dw=1;const n=new Uint16Array(8);function a(l,g){for(;g>0;){const y=l&4095;n[--g]=y,l=(l-y)/4096}return n}Du=class{constructor(){this.tiny=new p,this.maxLength=4096,this.factor=1}set(g,y){if(y!==void 0){for(;g>=this.maxLength;)if(this.maxLength*=4096,this.factor++,!this.tiny.isEmptyish()){const s=new p;s.set(0,this.tiny),this.tiny=s}}const h=a(g,this.factor),o=this.factor-1;let c=this.tiny;for(let s=0;s<o;s++){const u=c.get(h[s]);if(u===void 0){if(y===void 0)return;c=c.set(h[s],new p)}else c=u}return c.set(h[o],y)}get(g){if(g>=this.maxLength)return;const y=a(g,this.factor),h=this.factor-1;let o=this.tiny;for(let c=0;c<h;c++)if(o=o.get(y[c]),o===void 0)return;return o.get(y[h])}};class p{constructor(){this.s=0,this.b=new Array(1),this.f=new Uint16Array(1)}isEmptyish(){return this.b.length===1&&this.b[0]===void 0}get(g){if(this.s===12)return this.b[g];const y=g>>>this.s,h=g&this.b.length-1;return this.f[h]===y?this.b[h]:void 0}set(g,y){for(;this.s!==12;){const h=g>>>this.s,o=g&this.b.length-1;if(this.b[o]===void 0||h===this.f[o])return this.b[o]=y,this.f[o]=h,y;this.grow()}return this.b[g]=y,y}grow(){const g=this.s,y=this.b,h=this.f;this.s+=4,this.b=new Array(this.b.length<<4),this.f=this.s===12?null:new Uint8Array(this.b.length);const o=this.b.length-1;for(let c=0;c<y.length;c++){if(y[c]===void 0)continue;const s=h[c]<<g|c,u=s>>>this.s,f=s&o;this.b[f]=y[c],this.s!==12&&(this.f[f]=u)}}}return Du}var Bu,fw;function Gf(){if(fw)return Bu;fw=1;const n=ll(),a=Ue(),p=jf().quickbit,l=32768,g=l/8,y=g/4,h=2097152,o=h/8,c=o/4,s=1024,u=h/l,f=4;class m{constructor(M,z){this.index=M,this.offset=M*g-z.offset,this.bitfield=null,this.segment=z,z.add(this)}get tree(){return this.segment.tree}get(M,z){return p.get(this.bitfield,M)}set(M,z){p.set(this.bitfield,M,z)&&this.tree.update(this.offset*8+M)}setRange(M,z,j){p.fill(this.bitfield,j,M,z);let v=Math.floor(M/128);const w=v+Math.ceil((z-M)/128);for(;v<=w;)this.tree.update(this.offset*8+v++*128)}findFirst(M,z){return p.findFirst(this.bitfield,M,z)}findLast(M,z){return p.findLast(this.bitfield,M,z)}count(M,z,j){const v=M+z;let w=M,R=0;for(;z>0;){const A=this.findFirst(j,w);if(A===-1||A>=v)return R;const q=this.findFirst(!j,A+1);if(q===-1||q>=v)return R+v-A;R+=q-A,z-=q-w,w=q}return R}}class E{constructor(M,z){this.index=M,this.offset=M*o,this.tree=p.Index.from(z,o),this.pages=new Array(u)}get bitfield(){return this.tree.field}add(M){const z=M.index-this.index*u;this.pages[z]=M;const j=z*y,v=j+y;v>=this.bitfield.length&&this.reallocate(v),M.bitfield=this.bitfield.subarray(j,v)}reallocate(M){let z=this.bitfield.length;for(;z<M;)z*=f;const j=new Uint32Array(z);j.set(this.bitfield),this.tree=p.Index.from(j,o);for(let v=0;v<this.pages.length;v++){const w=this.pages[v];if(!w)continue;const R=v*y,A=R+y;w.bitfield=j.subarray(R,A)}}findFirst(M,z){z=this.tree.skipFirst(!M,z);let j=z&l-1,v=(z-j)/l;if(v>=u)return-1;for(;v<this.pages.length;){const w=this.pages[v];let R=-1;if(w?R=w.findFirst(M,j):M||(R=j),R!==-1)return v*l+R;j=0,v++}return-1}findLast(M,z){z=this.tree.skipLast(!M,z);let j=z&l-1,v=(z-j)/l;if(v>=u)return-1;for(;v>=0;){const w=this.pages[v];let R=-1;if(w?R=w.findLast(M,j):M||(R=j),R!==-1)return v*l+R;j=l-1,v--}return-1}}Bu=class tl{static BITS_PER_PAGE=l;static BYTES_PER_PAGE=g;constructor(M){this.resumed=!!(M&&M.byteLength>=0),this._pages=new n,this._segments=new n;const z=this.resumed?new Uint32Array(M.buffer,M.byteOffset,Math.floor(M.byteLength/4)):new Uint32Array(s);for(let j=0;j<z.length;j+=c){let v=z.subarray(j,j+c),w=c;if(j===0)for(w=s;w<v.length;)w*=f;if(v.length!==w){const A=new Uint32Array(w);A.set(v,0),v=A}const R=new E(j/c,v);this._segments.set(R.index,R);for(let A=0;A<v.length;A+=y){const q=new m((j+A)/y,R);this._pages.set(q.index,q)}}}static from(M){return new tl(M.toBuffer(M._pages.maxLength*l))}toBuffer(M){const z=Math.ceil(M/l),j=a.allocUnsafe(z*g);for(let v=0;v<z;v++){const w=this._pages.get(v),R=v*g;if(w){const A=a.from(w.bitfield.buffer,w.bitfield.byteOffset,w.bitfield.byteLength);j.set(A,R)}else j.fill(0,R,R+g)}return j}getBitfield(M){const z=this.getPageIndex(M);return this._pages.get(z)||null}merge(M,z){let j=0;for(;j<z;){const v=M.firstSet(j);if(v===-1||(j=M.firstUnset(v),(j===-1||j>z)&&(j=z),this.setRange(v,j,!0),j>=z))break}}get(M){const z=M&l-1,j=(M-z)/l,v=this._pages.get(j);return v?v.get(z):!1}getPageByteLength(){return g}getPageIndex(M){const z=M&l-1;return(M-z)/l}getPage(M,z){const j=this.getPageIndex(M);let v=this._pages.get(j);if(v)return v;if(!z)return null;const w=Math.floor(j/u),R=this._segments.get(w)||this._segments.set(w,new E(w,new Uint32Array(w===0?s:c)));return v=this._pages.set(j,new m(j,R)),v}set(M,z){const j=M&l-1,v=(M-j)/l;let w=this._pages.get(v);if(!w&&z){const R=Math.floor(v/u),A=this._segments.get(R)||this._segments.set(R,new E(R,new Uint32Array(R===0?s:c)));w=this._pages.set(v,new m(v,A))}w&&w.set(j,z)}setRange(M,z,j){let v=M&l-1,w=(M-v)/l;for(;M<z;){let R=this._pages.get(w);if(!R&&j){const T=Math.floor(w/u),Q=this._segments.get(T)||this._segments.set(T,new E(T,new Uint32Array(T===0?s:c)));R=this._pages.set(w,new m(w,Q))}const A=R.index*l,q=Math.min(z-A,l),U=q-v;R&&R.setRange(v,q,j),v=0,w++,M+=U}}findFirst(M,z){let j=z&h-1,v=(z-j)/h;for(;v<this._segments.maxLength;){const w=this._segments.get(v);let R=-1;if(w?R=w.findFirst(M,j):M||(R=j),R!==-1)return v*h+R;j=0,v++}return M?-1:this._segments.maxLength*h}firstSet(M){return this.findFirst(!0,M)}firstUnset(M){return this.findFirst(!1,M)}findLast(M,z){let j=z&h-1,v=(z-j)/h;for(;v>=0;){const w=this._segments.get(v);let R=-1;if(w?R=w.findLast(M,j):M||(R=j),R!==-1)return v*h+R;j=h-1,v--}return-1}lastSet(M){return this.findLast(!0,M)}lastUnset(M){return this.findLast(!1,M)}count(M,z,j){let v=M&l-1,w=(M-v)/l,R=0;for(;z>0;){const A=this._pages.get(w),U=Math.min(v+z,l)-v;A?R+=A.count(v,U,j):j||(R+=U),v=0,w++,z-=U}return R}countSet(M,z){return this.count(M,z,!0)}countUnset(M,z){return this.count(M,z,!1)}*want(M,z){const j=M&h-1;let v=(M-j)/h;for(;z>0;){const w=this._segments.get(v);if(w){const R=_(b(z/8,4096,o),4096);yield{start:v*h,bitfield:w.bitfield.subarray(0,R/4)}}v++,z-=h}}clear(M){return M.deleteBitfieldPageRange(0,-1)}onupdate(M){for(const{start:z,end:j,value:v}of M)this.setRange(z,j,v)}static async open(M,z){if(z===0)return new tl(M,null);const j=Math.ceil(z/l),v=a.alloc(j*g),w=M.createBitfieldStream();for await(const{index:R,page:A}of w)v.set(A,R*g);return new tl(v)}};function b(B,M,z){return Math.min(Math.max(B,M),z)}function _(B,M=1){const z=B%M;return z===0?B:B+M-z}return Bu}var Nu,gw;function Wv(){if(gw)return Nu;gw=1;const n=ll(),a=jf().quickbit,p=32768,l=p/8,g=l/4,y=2097152,h=y/8,o=y/p;class c{constructor(f,m,E){this.index=f,this.offset=f*l-E.offset,this.bitfield=m,this.segment=E,E.add(this)}get tree(){return this.segment.tree}get(f){return a.get(this.bitfield,f)}set(f,m){a.set(this.bitfield,f,m)&&this.tree.update(this.offset*8+f)}setRange(f,m,E){a.fill(this.bitfield,E,f,m);let b=Math.floor(f/128);const _=b+Math.ceil((m-f)/128);for(;b<=_;)this.tree.update(this.offset*8+b++*128)}findFirst(f,m){return a.findFirst(this.bitfield,f,m)}findLast(f,m){return a.findLast(this.bitfield,f,m)}insert(f,m){this.bitfield.set(m,f/32),this.segment.refresh()}clear(f,m){a.clear(this.bitfield,{field:m,offset:f})}}class s{constructor(f){this.index=f,this.offset=f*h,this.tree=a.Index.from([],h),this.pages=new Array(o),this.pagesLength=0}get chunks(){return this.tree.chunks}refresh(){this.tree=a.Index.from(this.tree.chunks,h)}add(f){const m=f.index-this.index*o;m>=this.pagesLength&&(this.pagesLength=m+1),this.pages[m]=f;const E={field:f.bitfield,offset:f.offset};this.chunks.push(E);for(let b=this.chunks.length-2;b>=0;b--){const _=this.chunks[b];if(_.offset<=E.offset)break;this.chunks[b]=E,this.chunks[b+1]=_}}findFirst(f,m){m=this.tree.skipFirst(!f,m);let E=m&p-1,b=(m-E)/p;if(b>=o)return-1;for(;b<this.pagesLength;){const _=this.pages[b];let B=-1;if(_?B=_.findFirst(f,E):f||(B=E),B!==-1)return b*p+B;E=0,b++}return f||this.pagesLength===o?-1:this.pagesLength*p}findLast(f,m){m=this.tree.skipLast(!f,m);let E=m&p-1,b=(m-E)/p;if(b>=o)return-1;for(;b>=0;){const _=this.pages[b];let B=-1;if(_?B=_.findLast(f,E):f||(B=E),B!==-1)return b*p+B;E=p-1,b--}return-1}}return Nu=class{static BITS_PER_PAGE=p;constructor(){this._pages=new n,this._segments=new n,this._maxSegments=0}getBitfield(f){const m=f&p-1,E=(f-m)/p;return this._pages.get(E)||null}get(f){const m=f&p-1,E=(f-m)/p,b=this._pages.get(E);return b?b.get(m):!1}set(f,m){const E=f&p-1,b=(f-E)/p;let _=this._pages.get(b);if(!_&&m){const B=Math.floor(b/o),M=this._segments.get(B)||this._segments.set(B,new s(B));this._maxSegments<=B&&(this._maxSegments=B+1),_=this._pages.set(b,new c(b,new Uint32Array(g),M))}_&&_.set(E,m)}setRange(f,m,E){let b=f&p-1,_=(f-b)/p;for(;f<m;){let B=this._pages.get(_);if(!B&&E){const v=Math.floor(_/o),w=this._segments.get(v)||this._segments.set(v,new s(v));this._maxSegments<=v&&(this._maxSegments=v+1),B=this._pages.set(_,new c(_,new Uint32Array(g),w))}const M=_*p,z=Math.min(m-M,p),j=z-b;B&&B.setRange(b,z,E),b=0,_++,f+=j}}findFirst(f,m){let E=m&y-1,b=(m-E)/y;for(;b<this._maxSegments;){const _=this._segments.get(b);let B=-1;if(_?B=_.findFirst(f,E):f||(B=E),B!==-1)return b*y+B;E=0,b++}return f?-1:Math.max(m,this._maxSegments*y)}firstSet(f){return this.findFirst(!0,f)}firstUnset(f){return this.findFirst(!1,f)}findLast(f,m){let E=m&y-1,b=(m-E)/y;for(;b>=0;){const _=this._segments.get(b);let B=-1;if(_?B=_.findLast(f,E):f||(B=E),B!==-1)return b*y+B;E=y-1,b--}return-1}lastSet(f){return this.findLast(!0,f)}lastUnset(f){return this.findLast(!1,f)}insert(f,m){if(f%32!==0)return!1;let E=m.byteLength*8,b=f&p-1,_=(f-b)/p;for(;E>0;){let B=this._pages.get(_);if(!B){const j=Math.floor(_/o),v=this._segments.get(j)||this._segments.set(j,new s(j));this._maxSegments<=j&&(this._maxSegments=j+1),B=this._pages.set(_,new c(_,new Uint32Array(g),v))}const z=Math.min(b+E,p)-b;B.insert(b,m.subarray(0,z/32)),m=m.subarray(z/32),b=0,_++,E-=z}return!0}clear(f,m){if(f%32!==0)return!1;let E=m.byteLength*8,b=f&p-1,_=(f-b)/p;for(;E>0;){let B=this._pages.get(_);if(!B){const j=Math.floor(_/o),v=this._segments.get(j)||this._segments.set(j,new s(j));this._maxSegments<=j&&(this._maxSegments=j+1),B=this._pages.set(_,new c(_,new Uint32Array(g),v))}const z=Math.min(b+E,p)-b;B.clear(b,m.subarray(0,z/32)),m=m.subarray(z/32),b=0,_++,E-=z}return!0}},Nu}var as={},pw;function Yf(){if(pw)return as;pw=1;const n=et(),a=Ue(),{DEFAULT_NAMESPACE:p}=tr(),{INVALID_OPLOG_VERSION:l}=Lt(),g=Xt(),y=a.alloc(0),h=1,o=2,c=4,s=8,u={preencode(d,k){d.end++},encode(d,k){if(k==="blake2b"){n.uint.encode(d,0);return}throw new Error("Unknown hash: "+k)},decode(d){const k=n.uint.decode(d);if(k===0)return"blake2b";throw new Error("Unknown hash id: "+k)}},f={preencode(d,k){d.end++},encode(d,k){if(k==="ed25519"){n.uint.encode(d,0);return}throw new Error("Unknown signature: "+k)},decode(d){const k=n.uint.decode(d);if(k===0)return"ed25519";throw new Error("Unknown signature id: "+k)}},m={preencode(d,k){f.preencode(d,k.signature),n.fixed32.preencode(d,k.namespace),n.fixed32.preencode(d,k.publicKey)},encode(d,k){f.encode(d,k.signature),n.fixed32.encode(d,k.namespace),n.fixed32.encode(d,k.publicKey)},decode(d){return{signature:f.decode(d),namespace:n.fixed32.decode(d),publicKey:n.fixed32.decode(d)}}},E=n.array(m),b={preencode(d,k){n.fixed32.preencode(d,k.hash),n.uint.preencode(d,k.length)},encode(d,k){n.fixed32.encode(d,k.hash),n.uint.encode(d,k.length)},decode(d){return{hash:n.fixed32.decode(d),length:n.uint.decode(d)}}},_={preencode(d,k){if(u.preencode(d,k.hash),d.end++,k.prologue&&k.signers.length===0){n.fixed32.preencode(d,k.prologue.hash);return}k.quorum===1&&k.signers.length===1&&!k.allowPatch?m.preencode(d,k.signers[0]):(d.end++,n.uint.preencode(d,k.quorum),E.preencode(d,k.signers))},encode(d,k){if(u.encode(d,k.hash),k.prologue&&k.signers.length===0){n.uint.encode(d,0),n.fixed32.encode(d,k.prologue.hash);return}k.quorum===1&&k.signers.length===1&&!k.allowPatch?(n.uint.encode(d,1),m.encode(d,k.signers[0])):(n.uint.encode(d,2),n.uint.encode(d,k.allowPatch?1:0),n.uint.encode(d,k.quorum),E.encode(d,k.signers))},decode(d){const k=u.decode(d),X=n.uint.decode(d);if(X>2)throw new Error("Unknown type: "+X);if(X===0)return{version:0,hash:k,allowPatch:!1,quorum:0,signers:[],prologue:{hash:n.fixed32.decode(d),length:0},linked:null,userData:null};if(X===1)return{version:0,hash:k,allowPatch:!1,quorum:1,signers:[m.decode(d)],prologue:null,linked:null,userData:null};const ie=n.uint.decode(d);return{version:0,hash:k,allowPatch:(ie&1)!==0,quorum:n.uint.decode(d),signers:E.decode(d),prologue:null,linked:null,userData:null}}},B=n.array(n.fixed32),M=as.manifest={preencode(d,k){if(d.end++,k.version===0)return _.preencode(d,k);d.end++,u.preencode(d,k.hash),n.uint.preencode(d,k.quorum),E.preencode(d,k.signers),k.prologue&&b.preencode(d,k.prologue),k.linked&&B.preencode(d,k.linked),k.userData&&n.buffer.preencode(d,k.userData)},encode(d,k){if(n.uint.encode(d,k.version),k.version===0)return _.encode(d,k);let X=0;k.allowPatch&&(X|=h),k.prologue&&(X|=o),k.linked&&(X|=c),k.userData&&(X|=s),n.uint.encode(d,X),u.encode(d,k.hash),n.uint.encode(d,k.quorum),E.encode(d,k.signers),k.prologue&&b.encode(d,k.prologue),k.linked&&B.encode(d,k.linked),k.userData&&n.buffer.encode(d,k.userData)},decode(d){const k=n.uint.decode(d);if(k===0)return _.decode(d);if(k>2)throw new Error("Unknown version: "+k);const X=n.uint.decode(d),ie=u.decode(d),I=n.uint.decode(d),L=E.decode(d),V=(X&h)!==0,te=(X&o)!==0,de=(X&c)!==0,C=(X&s)!==0;return{version:k,hash:ie,allowPatch:V,quorum:I,signers:L,prologue:te?b.decode(d):null,linked:de?B.decode(d):null,userData:C?n.buffer.decode(d):null}}},z={preencode(d,k){n.uint.preencode(d,k.index),n.uint.preencode(d,k.size),n.fixed32.preencode(d,k.hash)},encode(d,k){n.uint.encode(d,k.index),n.uint.encode(d,k.size),n.fixed32.encode(d,k.hash)},decode(d){return{index:n.uint.decode(d),size:n.uint.decode(d),hash:n.fixed32.decode(d)}}},j=n.array(z),v=as.wire={};v.handshake={preencode(d,k){n.uint.preencode(d,1),n.fixed32.preencode(d,k.capability)},encode(d,k){n.uint.encode(d,k.seeks?1:0),n.fixed32.encode(d,k.capability)},decode(d){return{seeks:(n.uint.decode(d)&1)!==0,capability:g(n.fixed32.decode(d))}}};const w={preencode(d,k){n.uint.preencode(d,k.index),n.uint.preencode(d,k.nodes)},encode(d,k){n.uint.encode(d,k.index),n.uint.encode(d,k.nodes)},decode(d){return{index:n.uint.decode(d),nodes:n.uint.decode(d)}}},R={preencode(d,k){n.uint.preencode(d,k.bytes),n.uint.preencode(d,k.padding)},encode(d,k){n.uint.encode(d,k.bytes),n.uint.encode(d,k.padding)},decode(d){return{bytes:n.uint.decode(d),padding:n.uint.decode(d)}}},A={preencode(d,k){n.uint.preencode(d,k.start),n.uint.preencode(d,k.length)},encode(d,k){n.uint.encode(d,k.start),n.uint.encode(d,k.length)},decode(d){return{start:n.uint.decode(d),length:n.uint.decode(d)}}};v.request={preencode(d,k){d.end++,n.uint.preencode(d,k.id),n.uint.preencode(d,k.fork),k.block&&w.preencode(d,k.block),k.hash&&w.preencode(d,k.hash),k.seek&&R.preencode(d,k.seek),k.upgrade&&A.preencode(d,k.upgrade),k.priority&&n.uint.preencode(d,k.priority)},encode(d,k){const X=(k.block?1:0)|(k.hash?2:0)|(k.seek?4:0)|(k.upgrade?8:0)|(k.manifest?16:0)|(k.priority?32:0);n.uint.encode(d,X),n.uint.encode(d,k.id),n.uint.encode(d,k.fork),k.block&&w.encode(d,k.block),k.hash&&w.encode(d,k.hash),k.seek&&R.encode(d,k.seek),k.upgrade&&A.encode(d,k.upgrade),k.priority&&n.uint.encode(d,k.priority)},decode(d){const k=n.uint.decode(d);return{id:n.uint.decode(d),fork:n.uint.decode(d),block:k&1?w.decode(d):null,hash:k&2?w.decode(d):null,seek:k&4?R.decode(d):null,upgrade:k&8?A.decode(d):null,manifest:(k&16)!==0,priority:k&32?n.uint.decode(d):0}}},v.cancel={preencode(d,k){n.uint.preencode(d,k.request)},encode(d,k){n.uint.encode(d,k.request)},decode(d,k){return{request:n.uint.decode(d)}}};const q={preencode(d,k){n.uint.preencode(d,k.start),n.uint.preencode(d,k.length),j.preencode(d,k.nodes),j.preencode(d,k.additionalNodes),n.buffer.preencode(d,k.signature)},encode(d,k){n.uint.encode(d,k.start),n.uint.encode(d,k.length),j.encode(d,k.nodes),j.encode(d,k.additionalNodes),n.buffer.encode(d,k.signature)},decode(d){return{start:n.uint.decode(d),length:n.uint.decode(d),nodes:j.decode(d),additionalNodes:j.decode(d),signature:n.buffer.decode(d)}}},U={preencode(d,k){n.uint.preencode(d,k.bytes),j.preencode(d,k.nodes)},encode(d,k){n.uint.encode(d,k.bytes),j.encode(d,k.nodes)},decode(d){return{bytes:n.uint.decode(d),nodes:j.decode(d)}}},T={preencode(d,k){n.uint.preencode(d,k.index),n.buffer.preencode(d,k.value),j.preencode(d,k.nodes)},encode(d,k){n.uint.encode(d,k.index),n.buffer.encode(d,k.value),j.encode(d,k.nodes)},decode(d){return{index:n.uint.decode(d),value:n.buffer.decode(d)||y,nodes:j.decode(d)}}},Q={preencode(d,k){n.uint.preencode(d,k.index),j.preencode(d,k.nodes)},encode(d,k){n.uint.encode(d,k.index),j.encode(d,k.nodes)},decode(d){return{index:n.uint.decode(d),nodes:j.decode(d)}}};v.data={preencode(d,k){d.end++,n.uint.preencode(d,k.request),n.uint.preencode(d,k.fork),k.block&&T.preencode(d,k.block),k.hash&&Q.preencode(d,k.hash),k.seek&&U.preencode(d,k.seek),k.upgrade&&q.preencode(d,k.upgrade),k.manifest&&M.preencode(d,k.manifest)},encode(d,k){const X=(k.block?1:0)|(k.hash?2:0)|(k.seek?4:0)|(k.upgrade?8:0)|(k.manifest?16:0);n.uint.encode(d,X),n.uint.encode(d,k.request),n.uint.encode(d,k.fork),k.block&&T.encode(d,k.block),k.hash&&Q.encode(d,k.hash),k.seek&&U.encode(d,k.seek),k.upgrade&&q.encode(d,k.upgrade),k.manifest&&M.encode(d,k.manifest)},decode(d){const k=n.uint.decode(d);return{request:n.uint.decode(d),fork:n.uint.decode(d),block:k&1?T.decode(d):null,hash:k&2?Q.decode(d):null,seek:k&4?U.decode(d):null,upgrade:k&8?q.decode(d):null,manifest:k&16?M.decode(d):null}}},v.noData={preencode(d,k){n.uint.preencode(d,k.request)},encode(d,k){n.uint.encode(d,k.request)},decode(d,k){return{request:n.uint.decode(d)}}},v.want={preencode(d,k){n.uint.preencode(d,k.start),n.uint.preencode(d,k.length)},encode(d,k){n.uint.encode(d,k.start),n.uint.encode(d,k.length)},decode(d){return{start:n.uint.decode(d),length:n.uint.decode(d)}}},v.unwant={preencode(d,k){n.uint.preencode(d,k.start),n.uint.preencode(d,k.length)},encode(d,k){n.uint.encode(d,k.start),n.uint.encode(d,k.length)},decode(d,k){return{start:n.uint.decode(d),length:n.uint.decode(d)}}},v.range={preencode(d,k){d.end++,n.uint.preencode(d,k.start),k.length!==1&&n.uint.preencode(d,k.length)},encode(d,k){n.uint.encode(d,(k.drop?1:0)|(k.length===1?2:0)),n.uint.encode(d,k.start),k.length!==1&&n.uint.encode(d,k.length)},decode(d){const k=n.uint.decode(d);return{drop:(k&1)!==0,start:n.uint.decode(d),length:(k&2)!==0?1:n.uint.decode(d)}}},v.bitfield={preencode(d,k){n.uint.preencode(d,k.start),n.uint32array.preencode(d,k.bitfield)},encode(d,k){n.uint.encode(d,k.start),n.uint32array.encode(d,k.bitfield)},decode(d,k){return{start:n.uint.decode(d),bitfield:n.uint32array.decode(d)}}},v.sync={preencode(d,k){d.end++,n.uint.preencode(d,k.fork),n.uint.preencode(d,k.length),n.uint.preencode(d,k.remoteLength)},encode(d,k){n.uint.encode(d,(k.canUpgrade?1:0)|(k.uploading?2:0)|(k.downloading?4:0)|(k.hasManifest?8:0)),n.uint.encode(d,k.fork),n.uint.encode(d,k.length),n.uint.encode(d,k.remoteLength)},decode(d){const k=n.uint.decode(d);return{fork:n.uint.decode(d),length:n.uint.decode(d),remoteLength:n.uint.decode(d),canUpgrade:(k&1)!==0,uploading:(k&2)!==0,downloading:(k&4)!==0,hasManifest:(k&8)!==0}}},v.reorgHint={preencode(d,k){n.uint.preencode(d,k.from),n.uint.preencode(d,k.to),n.uint.preencode(d,k.ancestors)},encode(d,k){n.uint.encode(d,k.from),n.uint.encode(d,k.to),n.uint.encode(d,k.ancestors)},decode(d){return{from:n.uint.encode(d),to:n.uint.encode(d),ancestors:n.uint.encode(d)}}},v.extension={preencode(d,k){n.string.preencode(d,k.name),n.raw.preencode(d,k.message)},encode(d,k){n.string.encode(d,k.name),n.raw.encode(d,k.message)},decode(d){return{name:n.string.decode(d),message:n.raw.decode(d)}}};const le={preencode(d,k){n.string.preencode(d,k.key),n.buffer.preencode(d,k.value)},encode(d,k){n.string.encode(d,k.key),n.buffer.encode(d,k.value)},decode(d){return{key:n.string.decode(d),value:n.buffer.decode(d)}}},Y={preencode(d,k){n.uint.preencode(d,k.fork),n.uint.preencode(d,k.ancestors),n.uint.preencode(d,k.length),n.buffer.preencode(d,k.signature)},encode(d,k){n.uint.encode(d,k.fork),n.uint.encode(d,k.ancestors),n.uint.encode(d,k.length),n.buffer.encode(d,k.signature)},decode(d){return{fork:n.uint.decode(d),ancestors:n.uint.decode(d),length:n.uint.decode(d),signature:n.buffer.decode(d)}}},oe={preencode(d,k){d.end++,n.uint.preencode(d,k.start),n.uint.preencode(d,k.length)},encode(d,k){d.buffer[d.start++]=k.drop?1:0,n.uint.encode(d,k.start),n.uint.encode(d,k.length)},decode(d){return{drop:(n.uint.decode(d)&1)!==0,start:n.uint.decode(d),length:n.uint.decode(d)}}},ue=as.oplog={};ue.entry={preencode(d,k){d.end++,k.userData&&le.preencode(d,k.userData),k.treeNodes&&j.preencode(d,k.treeNodes),k.treeUpgrade&&Y.preencode(d,k.treeUpgrade),k.bitfield&&oe.preencode(d,k.bitfield)},encode(d,k){const X=d.start++;let ie=0;k.userData&&(ie|=1,le.encode(d,k.userData)),k.treeNodes&&(ie|=2,j.encode(d,k.treeNodes)),k.treeUpgrade&&(ie|=4,Y.encode(d,k.treeUpgrade)),k.bitfield&&(ie|=8,oe.encode(d,k.bitfield)),d.buffer[X]=ie},decode(d){const k=n.uint.decode(d);return{userData:(k&1)!==0?le.decode(d):null,treeNodes:(k&2)!==0?j.decode(d):null,treeUpgrade:(k&4)!==0?Y.decode(d):null,bitfield:(k&8)!==0?oe.decode(d):null}}};const O={preencode(d,k){n.buffer.preencode(d,k.publicKey),n.buffer.preencode(d,k.secretKey)},encode(d,k){n.buffer.encode(d,k.publicKey),n.buffer.encode(d,k.secretKey)},decode(d){return{publicKey:n.buffer.decode(d),secretKey:n.buffer.decode(d)}}},P={preencode(d,k){n.uint.preencode(d,k.from),n.uint.preencode(d,k.to),n.uint.preencode(d,k.ancestors)},encode(d,k){n.uint.encode(d,k.from),n.uint.encode(d,k.to),n.uint.encode(d,k.ancestors)},decode(d){return{from:n.uint.decode(d),to:n.uint.decode(d),ancestors:n.uint.decode(d)}}},Z=n.array(P),he={preencode(d,k){Z.preencode(d,k.reorgs),n.uint.preencode(d,k.contiguousLength)},encode(d,k){Z.encode(d,k.reorgs),n.uint.encode(d,k.contiguousLength)},decode(d){return{reorgs:Z.decode(d),contiguousLength:d.start<d.end?n.uint.decode(d):0}}},se={preencode(d,k){n.uint.preencode(d,k.fork),n.uint.preencode(d,k.length),n.buffer.preencode(d,k.rootHash),n.buffer.preencode(d,k.signature)},encode(d,k){n.uint.encode(d,k.fork),n.uint.encode(d,k.length),n.buffer.encode(d,k.rootHash),n.buffer.encode(d,k.signature)},decode(d){return{fork:n.uint.decode(d),length:n.uint.decode(d),rootHash:n.buffer.decode(d),signature:n.buffer.decode(d)}}},G={preencode(d,k){n.string.preencode(d,k.tree),n.string.preencode(d,k.bitfield),n.string.preencode(d,k.signer)},encode(d,k){n.string.encode(d,k.tree),n.string.encode(d,k.bitfield),n.string.encode(d,k.signer)},decode(d){return{tree:n.string.decode(d),bitfield:n.string.decode(d),signer:n.string.decode(d)}}},re={preencode(d,k){n.uint.preencode(d,k.start),n.uint.preencode(d,k.length)},encode(d,k){n.uint.encode(d,k.start),n.uint.encode(d,k.length)},decode(d){return{start:n.uint.decode(d),length:n.uint.decode(d)}}},W=n.array(le);ue.header={preencode(d,k){if(d.end+=2,k.external){re.preencode(d,k.external);return}n.fixed32.preencode(d,k.key),k.manifest&&M.preencode(d,k.manifest),k.keyPair&&O.preencode(d,k.keyPair),W.preencode(d,k.userData),se.preencode(d,k.tree),he.preencode(d,k.hints)},encode(d,k){if(n.uint.encode(d,1),k.external){n.uint.encode(d,1),re.encode(d,k.external);return}n.uint.encode(d,(k.manifest?2:0)|(k.keyPair?4:0)),n.fixed32.encode(d,k.key),k.manifest&&M.encode(d,k.manifest),k.keyPair&&O.encode(d,k.keyPair),W.encode(d,k.userData),se.encode(d,k.tree),he.encode(d,k.hints)},decode(d){const k=n.uint.decode(d);if(k>1)throw l("Invalid header version. Expected <= 1, got "+k);if(k===0){const ie={types:G.decode(d),userData:W.decode(d),tree:se.decode(d),signer:O.decode(d),hints:he.decode(d)};return{external:null,key:ie.signer.publicKey,manifest:{version:0,hash:ie.types.tree,allowPatch:!1,quorum:1,signers:[{signature:ie.types.signer,namespace:p,publicKey:ie.signer.publicKey}],prologue:null,linked:null,userData:null},keyPair:ie.signer.secretKey?ie.signer:null,userData:ie.userData,tree:ie.tree,hints:ie.hints}}const X=n.uint.decode(d);return X&1?{external:re.decode(d),key:null,manifest:null,keyPair:null,userData:null,tree:null,hints:null}:{external:null,key:n.fixed32.decode(d),manifest:(X&2)!==0?M.decode(d):null,keyPair:(X&4)!==0?O.decode(d):null,userData:W.decode(d),tree:se.decode(d),hints:he.decode(d)}}};const $=n.array(n.uint),S={preencode(d,k){n.uint.preencode(d,k.signer),n.fixed64.preencode(d,k.signature),n.uint.preencode(d,k.patch)},encode(d,k){n.uint.encode(d,k.signer),n.fixed64.encode(d,k.signature),n.uint.encode(d,k.patch)},decode(d){return{signer:n.uint.decode(d),signature:n.fixed64.decode(d),patch:n.uint.decode(d)}}},N={preencode(d,k){n.uint.preencode(d,k.start),n.uint.preencode(d,k.length),$.preencode(d,k.nodes)},encode(d,k){n.uint.encode(d,k.start),n.uint.encode(d,k.length),$.encode(d,k.nodes)},decode(d){return{start:n.uint.decode(d),length:n.uint.decode(d),nodes:$.decode(d)}}},D={preencode(d,k){d.end++,n.uint.preencode(d,k.signer),n.fixed64.preencode(d,k.signature),k.patch&&N.preencode(d,k.patch)},encode(d,k){n.uint.encode(d,k.patch?1:0),n.uint.encode(d,k.signer),n.fixed64.encode(d,k.signature),k.patch&&N.encode(d,k.patch)},decode(d){const k=n.uint.decode(d);return{signer:n.uint.decode(d),signature:n.fixed64.decode(d),patch:k&1?N.decode(d):null}}},H=n.array(D),_e=n.array(S),ce={preencode(d,k){n.uint.preencode(d,k.index),n.uint.preencode(d,k.size),n.fixed32.preencode(d,k.hash)},encode(d,k){n.uint.encode(d,k.index),n.uint.encode(d,k.size),n.fixed32.encode(d,k.hash)},decode(d){return{index:n.uint.decode(d),size:n.uint.decode(d),hash:n.fixed32.decode(d)}}},J=n.array(ce);return as.multiSignaturev0={preencode(d,k){H.preencode(d,k.proofs),J.preencode(d,k.patch)},encode(d,k){H.encode(d,k.proofs),J.encode(d,k.patch)},decode(d){return{proofs:H.decode(d),patch:J.decode(d)}}},as.multiSignature={preencode(d,k){_e.preencode(d,k.proofs),J.preencode(d,k.patch)},encode(d,k){_e.encode(d,k.proofs),J.encode(d,k.patch)},decode(d){return{proofs:_e.decode(d),patch:J.decode(d)}}},as}var qu,yw;function Qv(){if(yw)return qu;yw=1;const n=et(),a=Ue(),p=rn(),{MerkleTree:l}=nr(),{multiSignature:g,multiSignaturev0:y}=Yf();qu={assemblev0:m,assemble:E,inflatev0:h,inflate:o,partialSignature:c,signableLength:u};function h(M){return n.decode(y,M)}function o(M){return n.decode(g,M)}async function c(M,z,j,v=M.state.length,w=M.state.signature){if(j>M.state.length)return null;const R=v<=j?null:await s(M,j,v);return w.byteLength!==64&&(w=n.decode(g,w).proofs[0].signature),{signer:z,signature:w,patch:R?v-j:0,nodes:R}}async function s(M,z,j){const v=M.state.storage.read();let w=null;try{w=await l.proof(M.state,v,{upgrade:{start:z,length:j-z}})}catch(R){throw v.destroy(),R}return v.tryFlush(),(await w.settle()).upgrade.nodes}function u(M,z){return z<=0&&(z=1),z>M.length?0:M.sort(f)[z-1]}function f(M,z){return z-M}function m(M){const z=[],j=[];for(const v of M)z.push(_(v,j));return n.encode(y,{proofs:z,patch:j})}function E(M){const z=[],j=[],v=new Set;for(const w of M){if(w.nodes)for(const R of w.nodes)v.has(R.index)||(v.add(R.index),j.push(R));z.push({signer:w.signer,signature:w.signature,patch:w.patch})}return n.encode(g,{proofs:z,patch:j})}function b(M,z){return M.index!==z.index||M.size!==z.size?!1:a.equals(M.hash,z.hash)}function _(M,z){return{signer:M.signer,signature:M.signature,patch:M.patch?B(M,z):null}}function B(M,z){const j={start:p.rightSpan(M.nodes[M.nodes.length-1].index)/2+1,length:M.patch,nodes:[]};for(const v of M.nodes){let w=!1;for(let R=0;R<z.length;R++)if(b(z[R],v)){j.nodes.push(R),w=!0;break}w||j.nodes.push(z.push(v)-1)}return j}return qu}var Cu,_w;function Zv(){if(_w)return Cu;_w=1;const n=_t(),a=Ue(),p=et(),l=rn(),{BAD_ARGUMENT:g}=Lt(),y=Xt(),h=Yf(),o=Qv(),c=tr();class s{constructor(w,R,A,{signature:q="ed25519",publicKey:U,namespace:T=c.DEFAULT_NAMESPACE}={}){if(!U)throw g("public key is required for a signer");if(q!=="ed25519")throw g("Only Ed25519 signatures are supported");this.manifestHash=w,this.version=R,this.signer=A,this.signature=q,this.publicKey=U,this.namespace=T}_ctx(){return this.version===0?this.namespace:this.manifestHash}verify(w,R){return n.verify(w.signable(this._ctx()),R,this.publicKey)}sign(w,R){return n.sign(w.signable(this._ctx()),R.secretKey)}}class u extends s{constructor(w,R,A){super(null,0,w,R),this.legacy=A}verify(w,R){return n.verify(w.signableCompat(this.legacy),R,this.publicKey)}sign(w,R){return n.sign(w.signableCompat(this.legacy),R.secretKey)}}Cu=class Xv{constructor(w,R,{compat:A=m(w,R),legacy:q=!1}={}){const U=this;this.manifestHash=w,this.compat=A||R===null,this.version=this.compat?0:typeof R.version=="number"?R.version:1,this.hash=R.hash||"blake2b",this.allowPatch=!this.compat&&!!R.allowPatch,this.quorum=this.compat?1:E(R),this.signers=R.signers?R.signers.map(T):[],this.prologue=this.compat?null:R.prologue||null;function T(Q,le){return U.compat?new u(le,Q,q):new s(w,U.version,le,Q)}}_verifyCompat(w,R){return R?this.compat||!this.allowPatch&&this.signers.length===1?!!R&&this.signers[0].verify(w,R):this._verifyMulti(w,R):!1}_inflate(w){if(this.version>=1)return o.inflate(w);const{proofs:R,patch:A}=o.inflatev0(w);return{proofs:R.map(z),patch:A}}_verifyMulti(w,R){if(!R||this.quorum===0)return!1;const{proofs:A,patch:q}=this._inflate(R);if(A.length<this.quorum)return!1;const U=new Uint8Array(this.signers.length),T=this.allowPatch&&q.length?f(q):null;for(let Q=0;Q<this.quorum;Q++){const le=A[Q];let Y=w;if(le.patch&&this.allowPatch){Y=w.clone();const ue=b(T,w.length,le.patch),O={fork:Y.fork,block:null,hash:null,seek:null,upgrade:ue,manifest:null};try{if(!Y.verifyUpgrade(O))return!1}catch{return!1}}if(le.signer>=this.signers.length||U[le.signer]||(U[le.signer]=1,!this.signers[le.signer].verify(Y,le.signature)))return!1}return!0}verify(w,R){return this.version===0?this._verifyCompat(w,R):this.prologue!==null&&w.length<=this.prologue.length?w.length===this.prologue.length&&a.equals(w.hash(),this.prologue.hash):this._verifyMulti(w,R)}sign(w,R){if(!R||!R.secretKey)throw g("No key pair was passed");for(const A of this.signers)if(a.equals(A.publicKey,R.publicKey)){const q=A.sign(w,R);return this.signers.length!==1||this.version===0?q:this.assemble([{signer:0,signature:q,patch:0,nodes:null}])}throw g("Public key is not a declared signer")}assemble(w){return this.version===0?o.assemblev0(w):o.assemble(w)}static manifestHash(w){return M(w)}static encodeManifest(w){return p.encode(h.manifest,w)}static decodeManifest(w){return p.decode(h.manifest,w)}static defaultSignerManifest(w){return{version:1,hash:"blake2b",allowPatch:!1,quorum:1,signers:[{signature:"ed25519",namespace:c.DEFAULT_NAMESPACE,publicKey:w}],prologue:null,linked:null,userData:null}}static fromManifest(w,R){const A=this.createManifest(w);return new this(M(A),A,R)}static createManifest(w){if(!w)return null;const R={version:j(w),hash:"blake2b",allowPatch:!!w.allowPatch,quorum:E(w),signers:w.signers?w.signers.map(_):[],prologue:null,linked:null,userData:w.userData||null};if(w.hash&&w.hash!=="blake2b")throw g("Only Blake2b hashes are supported");if(w.prologue){if(!(a.isBuffer(w.prologue.hash)&&w.prologue.hash.byteLength===32)||!(w.prologue.length>=0))throw g("Invalid prologue");R.prologue=w.prologue,R.prologue.hash=y(R.prologue.hash)}if(R.userData!==null&&R.version<2)throw g("Invalid field: userData");if(w.linked&&w.linked.length){if(R.version<2)throw g("Invalid field: linked");for(const A of w.linked)if(!(a.isBuffer(A)&&A.byteLength===32))throw g("Invalid key");R.linked=w.linked}return R}static isValidManifest(w,R){return a.equals(w,M(R))}static isCompat(w,R){return m(w,R)}static sign(w,R,A,q){return Xv.fromManifest(w,q).sign(R,A)}};function f(v){const w=new Map;for(const R of v)w.set(R.index,R);return w}function m(v,w){return!!(w&&w.signers.length===1&&a.equals(v,w.signers[0].publicKey))}function E(v){return typeof v.quorum=="number"?v.quorum:!v.signers||!v.signers.length?0:(v.signers.length>>1)+1}function b(v,w,R){const A={start:w,length:R,nodes:null,additionalNodes:[],signature:null},q=w*2,U=q+R*2;for(const T=l.iterator(0);T.fullRoot(U);T.nextTree())if(!(T.index+T.factor/2<q)){if(A.nodes===null&&T.contains(q-2)){A.nodes=[];const Q=T.index,le=q-2;for(T.seek(le);T.index!==Q;)T.sibling(),T.index>le&&A.nodes.push(v.get(T.index)),T.parent();continue}A.nodes===null&&(A.nodes=[]),A.nodes.push(v.get(T.index))}return A.nodes===null&&(A.nodes=[]),A}function _(v){return B(v),{signature:"ed25519",namespace:y(v.namespace||c.DEFAULT_NAMESPACE),publicKey:y(v.publicKey)}}function B(v){if(!v||!v.publicKey)throw g("Signer missing public key");if(v.signature&&v.signature!=="ed25519")throw g("Only Ed25519 signatures are supported")}function M(v){const w={start:0,end:32,buffer:null};return h.manifest.preencode(w,v),w.buffer=a.allocUnsafe(w.end),p.raw.encode(w,c.MANIFEST),h.manifest.encode(w,v),n.hash(w.buffer)}function z(v){return{signer:v.signer,signature:v.signature,patch:v.patch?v.patch.length:0}}function j(v){return typeof v.version=="number"?v.version:v.linked&&v.linked.length||v.userData?2:1}return Cu}var Mu,mw;function kS(){if(mw)return Mu;mw=1;const n=_t(),a=rn(),p=Ue(),{MerkleTree:l}=nr();Mu=async function(c,{tree:s=!0,blocks:u=!0,bitfield:f=!0,dryRun:m=!1}={}){const E=c.state.length,b={treeNodes:0,blocks:0,bits:0,droppedTreeNodes:0,droppedBlocks:0,droppedBits:0,corrupt:!1};if(s){let _=null;const B=await l.getRootsFromStorage(c.state.storage,E),M=[];for(const z of B){if(z===null){if(!m){const j=c.state.storage;return await j.store.deleteCore(j.core),null}b.corrupt=!0}M.push(z)}for(b.treeNodes+=B.length;M.length>0;){const z=M.pop();if((z.index&1)===0)continue;const[j,v]=a.children(z.index),w=c.state.storage.read(),R=w.getTreeNode(j),A=w.getTreeNode(v);w.tryFlush();const[q,U]=await Promise.all([R,A]);if(y(z,q,U)){!_&&!b.corrupt&&(_=c.state.storage.write());const[T,Q]=a.spans(z.index);_.deleteTreeNodeRange(T,Q+1),b.droppedTreeNodes++;continue}q&&(b.treeNodes+=2,M.push(q,U))}_&&!m&&await _.flush()}if(u){let _=null;for await(const B of c.state.storage.createBlockStream()){c.bitfield.get(B.index)||(!_&&!b.corrupt&&(_=c.state.storage.write()),_.deleteBlock(B.index),b.droppedBlocks++);const M=c.state.storage.read(),z=M.getTreeNode(2*B.index);M.tryFlush();const j=await z;if(g(j,B.value)){!_&&!b.corrupt&&(_=c.state.storage.write()),_.deleteBlock(B.index),b.droppedBlocks++;continue}b.blocks++}_&&!m&&await _.flush()}if(f){let _=null;for(const B of h(c.bitfield)){const M=c.state.storage.read(),z=M.getBlock(B);if(M.tryFlush(),!await z){if(b.droppedBits++,m)continue;!_&&!b.corrupt&&(_=c.state.storage.write()),c.bitfield.set(B,!1);const v=c.bitfield.getBitfield(B);v.bitfield?_.setBitfieldPage(v.index,v.bitfield):_.deleteBitfieldPage(v.idnex);continue}b.bits++}_&&!m&&await _.flush()}return b};function g(o,c){if(!o)return!0;const s=n.data(c);return!p.equals(s,o.hash)||o.size!==c.byteLength}function y(o,c,s){if(!c&&!s)return!1;if(!c||!s)return!0;const u=n.parent(c,s);return!p.equals(u,o.hash)||o.size!==c.size+s.size}function*h(o){let c=0;for(o.get(0)&&(yield 0);c=o.findFirst(!0,c+1),c!==-1;)yield c}return Mu}var Uu,ww;function SS(){if(ww)return Uu;ww=1;const n=_t(),a=rn(),p=Ue(),l=er(),g=Gf(),y=4*1024*1024,h=512*1024;Uu=o;async function o(_,B){const M=B.header.manifest.prologue;if(_.length<M.length||M.length===0)return;const z=[],j=a.fullRoots(M.length*2),v={roots:j,first:!0,last:!1,contig:0,used:0,tree:[],blocks:[]};for(let A=0;A<j.length;A++){const q=j[A];v.tree.push(q),z.push(q)}let w=-1,R=-1;for await(const A of _.storage.createBlockStream({gte:0,lt:M.length,reverse:!0})){if(E(z,A.index*2,v)===!1)throw new Error("Missing block or tree node for "+A.index);v.contig=A.index+1===R?v.contig+1:1,R=A.index;const q=f(A.index);v.blocks.push(A),w!==q&&(v.used+=4096),v.used+=Math.max(A.value.byteLength,128),(v.used>=h&&q!==w||v.used>=y)&&await c(M,_,B,v),w=q}R!==0&&(v.contig=0),v.last=!0,await c(M,_,B,v)}async function c(_,B,M,z){const j=[],v=B.storage.read();for(const Z of z.tree)j.push(v.getTreeNode(Z));v.tryFlush();const w=await Promise.all(j),R=[],A=M.storage.read(),q=z.first?A.getHead():null;q&&q.catch(b);let U=-1;for(const{index:Z}of z.blocks){const he=f(Z);he!==U&&(U=he,R.push(A.getBitfieldPage(he)))}A.tryFlush();const T=await Promise.all(R),Q=q===null?null:await q,le=[];if(z.first){const Z=w.slice(0,z.roots.length);for(const se of Z)if(!se)throw new Error("Missing nodes for prologue hash");const he=n.tree(Z);if(!p.equals(he,_.hash))throw new Error("Prologue does not match source")}if(z.first)for await(const Z of B.storage.createUserDataStream())le.push(Z);for(let Z=0;Z<T.length;Z++)T[Z]||(T[Z]=p.alloc(4096));const Y=M.storage.write();for(const Z of w)Y.putTreeNode(Z);U=-1;let oe=-1;for(const{index:Z,value:he}of z.blocks){const se=f(Z);se!==U&&(U=se,oe++,Y.putBitfieldPage(oe,T[oe]));const G=T[oe];l.set(G,m(Z),!0),Y.putBlock(Z,he)}for(const{key:Z,value:he}of le)Y.putUserData(Z,he);let ue=z.first&&!Q;if(ue&&Y.setHead(u(_)),await Y.flush(),ue){const Z=w.slice(0,z.roots.length);M.state.setRoots(Z),M.header.tree=u(_)}le.length>0&&(M.header.userData=le.concat(M.header.userData)),z.contig&&(M.header.hints.contiguousLength=z.contig);let O=0,P=0;for(const{index:Z}of z.blocks)O===0||O-1===Z?P++:(P>0&&s(M,ue,O,P),ue=!1,P=1),O=Z,M.bitfield.set(Z,!0);P>0&&s(M,ue,O,P),z.tree=[],z.blocks=[],z.first=!1,z.used=0}function s(_,B,M,z){B?(_.replicator.cork(),_.replicator.onhave(M,z,!1),_.replicator.onupgrade(),_.replicator.uncork()):_.replicator.onhave(M,z,!1)}function u(_){return{fork:0,length:_.length,rootHash:_.hash,signature:null}}function f(_){return Math.floor(_/g.BITS_PER_PAGE)}function m(_){return _&g.BITS_PER_PAGE-1}function E(_,B,M){for(;_.length>0;){const z=_.pop();if((z&1)===0){if(z===B)return!0;continue}const j=a.iterator(z);if(j.contains(B)){for(;(j.index&1)!==0;){const v=j.leftChild(),w=j.sibling();M.tree.push(v,w),j.contains(B)?_.push(v):j.sibling()}if(j.index===B)return!0}}return!1}function b(){}return Uu}var Ou,bw;function xS(){if(bw)return Ou;bw=1;const n=_t(),a=Ue(),p=On(),l=rn(),g=er(),{INVALID_OPERATION:y,INVALID_SIGNATURE:h}=Lt(),o=Yv(),c=Gf(),{MerkleTree:s,MerkleTreeBatch:u}=nr();Ou=class Uf{constructor(v,w,R,A,q){this.core=v,this.index=this.core.sessionStates.push(this)-1,this.storage=R,this.name=q,this.sessions=[],this.lingers=null,this.parent=w,this.atomized=null,this.mutex=new o,this.roots=A.roots.length?A.roots:[],this.fork=A.fork||0,this.length=s.span(this.roots)/2,this.byteLength=s.size(this.roots),this.prologue=A.prologue||null,this.signature=A.signature||null,this.snapshotCompatLength=this.isSnapshot()?Math.min(this.length,this.core.state.length):-1,this.lastTruncation=null,this.active=0,this._activeTx=null,this._pendingBitfield=null,this.ref()}isSnapshot(){return this.storage.snapshotted}isDefault(){return this.core.state===this||this.isAtomicDefault()}isAtomicDefault(){return!!this.storage.atom&&!!this.parent&&this.parent.isDefault()}createTreeBatch(){return new u(this)}addSession(v){v._stateIndex===-1&&(v._stateIndex=this.sessions.push(v)-1,v.weak===!1&&this.core.activeSessions++)}removeSession(v){if(v._stateIndex===-1)return;const w=this.sessions.pop();w!==v&&(this.sessions[w._stateIndex=v._stateIndex]=w),v._stateIndex=-1,v.weak===!1&&this.core.activeSessions--,this.core.checkIfIdle()}flushedLength(){if(this.isDefault()||this.isSnapshot())return this.length;const v=this.storage.dependencies;return v.length?v[v.length-1].length:0}signedLength(){const v=Math.min(this.flushedLength(),this.core.state.length);return this.isSnapshot()&&v>this.snapshotCompatLength?this.snapshotCompatLength:v}unref(){--this.active>0||this.close().catch(f)}ref(){return this.active++,this}hash(){return s.hash(this)}setRoots(v){this.roots=v,this.length=s.span(v)/2,this.byteLength=s.size(v)}get encryptionFork(){return this.core.header.tree.fork}async updateSnapshotStorage(v){if(!this.atomized||!this.atomized.flushing)return this.treeInfo();await this.atomized.flushed();let w=v.read();const R=w.getHead(),A=w.getAuth(),q=w.getDependency();w.tryFlush();const[U,T,Q]=await Promise.all([R,A,q]);v.setDependencyHead(Q);const le=U?U.fork:0,Y=U?U.length:0;w=v.read();const oe=[];for(const O of l.fullRoots(Y*2))oe.push(w.getTreeNode(O));w.tryFlush();const ue=await Promise.all(oe);for(const O of ue)if(O===null)throw new Error("Bad snapshot from atomized session, id = "+this.core.id+" length = "+Y+" fork = "+le);return{fork:le,roots:ue,length:Y,prologue:T.manifest&&T.manifest.prologue,signature:U&&U.signature}}treeInfo(){return{fork:this.fork,roots:this.roots.slice(),length:this.length,prologue:this.prologue,signature:this.signature}}async close(){if(this.index===-1)return;this.active=0,this.mutex.destroy(new Error("Closed")).catch(f),this.parent&&this.parent.atomized&&(this.parent.atomized=null);const v=this.storage.close(),w=this.core.sessionStates.pop();if(w!==this&&(this.core.sessionStates[w.index=this.index]=w),this.index=-1,this.core.checkIfIdle(),this.lingers!==null)for(const R of this.lingers)await R.close();return v}async snapshot(){const v=this.storage.snapshot(),w=await this.updateSnapshotStorage(v);return new Uf(this.core,null,v,w,this.name)}updateDependency(v,w){const R=B(this,w,!1);return R&&v.setDependency(R),R}_clearActiveBatch(){this._activeTx=null}createWriteBatch(){return p(!this._activeTx&&!this.storage.snapshotted),this._activeTx=this.storage.write(),this._activeTx}_unlock(){this._clearActiveBatch(),this.mutex.unlock(),this.core.checkIfIdle()}async flush(){const v=this._activeTx;this._activeTx=null;try{if(!await v.flush())return!1}finally{this._clearActiveBatch()}return this.lastTruncation=null,!0}_precommit(){this.commiting=!0}async _commit(){await this.mutex.lock();try{const v=this._pendingBitfield;this._pendingBitfield=null,this.lastTruncation=null,await this.parent._oncommit(this,v)}finally{this.commiting=!1,this.mutex.unlock()}}async _oncommit(v,w){await this.mutex.lock();try{const R=this.length,A=this.storage.read(),q=A.getDependency();A.tryFlush();const U=await q;this.fork=v.fork,this.length=v.length,this.byteLength=v.byteLength,this.roots=v.roots.slice(),this.signature=v.signature;const T={fork:this.fork,length:this.length,rootHash:this.hash(),signature:this.signature};U&&this.storage.setDependencyHead(U);const Q=w;if(Q&&Q.truncated&&Q.start<R&&(this.ontruncate(T,Q.start,R,!0),!Q||Q.appends===0))return;const le=Q?{start:Q.start,length:Q.appends,drop:!1}:null;this.onappend(T,le,!0)}finally{this.mutex.unlock(),this.core.checkIfIdle()}}async setUserData(v,w){await this.mutex.lock();try{return this.createWriteBatch().putUserData(v,w),await this.flush()}finally{this._unlock()}}async _verifyBlock(v,w,R,A,q){await this.mutex.lock();try{if(!v.commitable())return!1;const U=this.createWriteBatch();this.updating=!0,w&&U.putBlock(w.start,R),w&&this.isDefault()&&await b(this.storage,U,w.start,w.start+1,!0),A&&this.core._setManifest(U,A,null),p(v.commitable(),"Should still be commitable"),v.commit(U);const T={fork:v.fork,length:v.length,rootHash:v.hash(),signature:v.signature};v.upgraded&&U.setHead(T);const Q=await this.flush();v.upgraded&&(this.roots=v.roots,this.length=v.length,this.byteLength=v.byteLength,this.fork=v.fork,this.signature=v.signature,this.onappend(T,w,Q))}finally{this._clearActiveBatch(),this.updating=!1,this.mutex.unlock()}return!0}async truncate(v,w,{signature:R,keyPair:A}={}){!A&&this.isDefault()&&(A=this.core.header.keyPair),await this.mutex.lock();try{if(this.prologue&&v<this.prologue.length)throw y("Truncation breaks prologue");if(v>this.length)throw y("Not a truncation, "+v+" must be less or equal to "+this.length);const q=this.createTreeBatch();await s.truncate(this,v,q,w),!R&&A&&v>0&&(R=this.core.verifier.sign(q,A)),R&&(q.signature=R);const U=this.createWriteBatch();this.core.verifier===null&&A&&this.core._setManifest(U,null,A);const{dependency:T,tree:Q,roots:le}=await this._truncate(U,q);for(const oe of this.core.sessionStates)oe.isSnapshot()&&oe.name===this.name&&v<oe.snapshotCompatLength&&(oe.snapshotCompatLength=v);const Y=await this.flush();this.fork=Q.fork,this.length=Q.length,this.byteLength=s.size(le),this.roots=le,this.signature=Q.signature,T&&this.storage.setDependencyHead(T),this.ontruncate(Q,Q.length,q.treeLength,Y)}finally{this._unlock()}}async reorg(v){await this.mutex.lock();const w=this.createWriteBatch();try{if(!v.commitable())return!1;const{dependency:R,tree:A}=await this._truncate(w,v),q=await this.flush();this.fork=v.fork,this.length=v.length,this.byteLength=v.byteLength,this.roots=v.roots,this.signature=v.signature,R&&this.storage.setDependencyHead(R),this.ontruncate(A,v.ancestors,v.treeLength,q)}finally{this._unlock()}}async _truncate(v,w){v.deleteBlockRange(w.ancestors,w.treeLength),p(w.commitable(),"Batch must be commitable");const R={fork:w.fork,length:w.length,rootHash:w.hash(),signature:w.signature};v.setHead(R),w.commit(v);const q=w.length<this.flushedLength()?B(this,w.length,!0):null;return q&&v.setDependency(q),this.isDefault()&&(await b(this.storage,v,w.ancestors,w.treeLength,!1),w.ancestors<this.core.header.hints.contiguousLength&&v.setHints({contiguousLength:w.ancestors})),{dependency:q,tree:R,roots:w.roots}}async clear(v,w,R){await this.mutex.lock();try{const A=this.createWriteBatch();this.isDefault()&&(await b(this.storage,A,v,w,!1),v<this.core.header.hints.contiguousLength&&A.setHints({contiguousLength:v})),A.deleteBlockRange(v,w);const q=v<this.flushedLength()?B(this,v,!0):null,U=await this.flush();if(q&&this.storage.setDependencyHead(q),this.isDefault()&&U){const T=w-v;this.core.updateContiguousLength({start:v,length:T,drop:!0}),this.core._setBitfieldRanges(v,w,!1),this.core.replicator.onhave(v,T,!0)}}finally{this._unlock()}}async append(v,{signature:w,keyPair:R,preappend:A,maxLength:q=-1}={}){!R&&this.isDefault()&&(R=this.core.header.keyPair),await this.mutex.lock();try{if(q>=0&&this.length+v.length>q)return{length:this.length,byteLength:this.byteLength};const U=this.createWriteBatch();if(this.core.verifier===null&&R&&this.core._setManifest(U,null,R),A&&await A(v),!v.length)return await this.flush(),{length:this.length,byteLength:this.byteLength};const T=this.createTreeBatch();for(const oe of v)T.append(oe);if(this.prologue&&T.length<this.prologue.length)throw y("Append is not consistent with prologue");!w&&R&&(w=this.core.verifier.sign(T,R)),w&&(T.signature=w),T.commit(U);const Q={fork:T.fork,length:T.length,rootHash:T.hash(),signature:T.signature};U.setHead(Q),this.isDefault()&&(await b(this.storage,U,T.ancestors,T.length,!0),this.length===this.core.header.hints.contiguousLength&&U.setHints({contiguousLength:this.length+v.length}));for(let oe=0;oe<v.length;oe++)U.putBlock(this.length+oe,v[oe]);const le={drop:!1,start:T.ancestors,length:v.length},Y=await this.flush();return this.fork=T.fork,this.roots=T.roots,this.length=T.length,this.byteLength=T.byteLength,this.signature=T.signature,this.onappend(Q,le,Y),{length:this.length,byteLength:this.byteLength}}finally{this._unlock()}}onappend(v,w,R){R?this.isDefault()&&this.core.onappend(v,w):this._updateBitfield(w);for(let A=this.sessions.length-1;A>=0;A--)this.sessions[A].emit("append")}ontruncate(v,w,R,A){const q={start:w,length:R-w,drop:!0};this.lastTruncation={from:R,to:w},A?this.isDefault()&&this.core.ontruncate(v,q):this._updateBitfield(q);for(const U of this.core.sessionStates)U.isSnapshot()&&U.name===this.name&&w<U.snapshotCompatLength&&(U.snapshotCompatLength=w);for(let U=this.sessions.length-1;U>=0;U--)this.sessions[U].emit("truncate",w,v.fork)}_updateBitfield(v,w){if(!v)return;const R=this._pendingBitfield,A=v;if(A.drop){if(R&&A.start+A.length!==R.start+R.appends)throw y("Atomic truncations must be contiguous");if(R===null||A.start<R.start){this._pendingBitfield={truncated:!0,start:A.start,appends:0};return}R.appends=A.start-R.start,R.appends===0&&(this._pendingBitfield=null);return}if(R===null){this._pendingBitfield={truncated:!1,start:A.start,appends:A.length};return}if(A.start!==R.start+R.appends)throw y("Atomic operations must be contiguous");R.appends+=A.length}async catchup(v){p(!this.isDefault(),"Cannot catchup signed state"),await this.mutex.lock();try{const w=this.length;let R=0;for(let O=this.storage.dependencies.length-1;O>=0;O--){const P=this.storage.dependencies[O];if(P.dataPointer===this.core.state.storage.core.dataPointer){R=P.length;break}}const A=this.createWriteBatch(),q=this.core.state.storage.read(),U=[];for(const O of l.fullRoots(v*2))U.push(q.getTreeNode(O));q.tryFlush();const T=await Promise.all(U),Q=R<w;for(const O of T)if(O===null)throw y("Invalid catchup length, tree nodes not available");const le=Q?this.fork+1:this.fork;A.deleteBlockRange(0,-1),A.deleteTreeNodeRange(0,-1),A.deleteBitfieldPageRange(0,-1);const Y={fork:le,length:v,rootHash:n.tree(T),signature:null};A.setHead(Y);const oe=B(this,R,!0);oe.length=v,A.setDependency(oe);const ue=await this.flush();this.storage.setDependencyHead(oe),this.fork=Y.fork,this.roots=T,this.length=Y.length,this.byteLength=s.size(T),Q&&this.ontruncate(Y,R,w,ue),R<v&&this.onappend(Y,null,ue)}finally{this.mutex.unlock()}}async _overwrite(v,w,R,A,q){const U=[],T=[],Q=[],le=v.storage.read();for(const G of l.fullRoots(R*2))Q.push(le.getTreeNode(G));for(const G of l.patch(A*2,R*2))T.push(le.getTreeNode(G));for(let G=A;G<R;G++)T.push(le.getTreeNode(G*2)),T.push(le.getTreeNode(G*2+1)),U.push(le.getBlock(G));le.tryFlush();const Y=await Promise.all(U),oe=await Promise.all(T),ue=await Promise.all(Q);if(this.core.destroyed)throw new Error("Core destroyed");if(q){const G=this.createTreeBatch();if(G.roots=ue,G.length=R,!this.core.verifier.verify(G,q))throw h("Signature is not valid over committed tree")}const O=this.createWriteBatch();A<this.length&&O.deleteBlockRange(A,this.length);for(const G of ue)O.putTreeNode(G);for(const G of oe)G!==null&&O.putTreeNode(G);for(let G=0;G<Y.length;G++)p(Y[G]!==null,"has block"),O.putBlock(G+A,Y[G]);const P=Math.max(R,this.length);if(P>A){const G=m(A),re=m(P-1),W=this.storage.read(),$=W.getBitfieldPage(G);W.tryFlush();const S=await $;let N=A;for(let D=G;D<=re;D++){const H=a.alloc(c.BYTES_PER_PAGE);O.putBitfieldPage(D,H),D===G&&S&&H.set(S),!(N<R&&(N=E(H,N,R,D,!0),N<R))&&N<this.length&&(N=E(H,N,this.length,D,!1))}}const Z={fork:w,length:R,rootHash:n.tree(ue),signature:q};(A<this.length||this.length<R||Z.fork!==this.fork)&&O.setHead(Z);const se=await this.flush();return this.fork=Z.fork,this.roots=ue,this.length=R,this.byteLength=s.size(ue),this.signature=q,{tree:Z,flushed:se}}async commit(v,{signature:w,keyPair:R,length:A=v.length,treeLength:q=-1,overwrite:U=!1}={}){p(this.isDefault()||this.parent&&this.parent.isDefault(),"Can only commit into default state");let T=!1;await this.mutex.lock();try{if(await v.mutex.lock(),T=!0,q===-1&&(q=v.flushedLength()),!await this.core._validateCommit(v,q)||this.length>A)return null;if(this.length<A&&!w){R||(R=this.core.header.keyPair);const oe=v.createTreeBatch();A!==oe.length&&await oe.restore(A),w=this.core.verifier.sign(oe,R)}const{tree:Q,flushed:le}=await this._overwrite(v,this.fork,A,q,w);if(q<A){const oe=v.createWriteBatch();oe.deleteBlockRange(q,A);const ue=v.updateDependency(oe,A);await v.flush(oe),ue&&v.storage.setDependencyHead(ue)}const Y={start:q,length:A-q,drop:!1};return this.onappend(Q,Y,le),{length:this.length,byteLength:this.byteLength}}finally{this.updating=!1,this.mutex.unlock(),T&&(v.mutex.unlock(),v._clearActiveBatch()),this.core.checkIfIdle()}}async _getTreeHeadAt(v){if(v===null)return this.treeInfo();const w=M();w.length=v;const R=await s.getRootsFromStorage(this.storage,v),A=n.tree(R);return w.fork=this.fork,w.rootHash=A,v===this.length&&(w.signature=this.signature),w}_moveToCore(v,w,R){const A=this.core.sessionStates.pop();A!==this&&(this.core.sessionStates[A.index=this.index]=A),this.core=v,this.index=this.core.sessionStates.push(this)-1;for(let q=this.sessions.length-1;q>=0;q--){const U=this.sessions[q],T=U.manifest;U.transferSession(this.core),!T&&U.manifest&&U.emit("manifest"),w&&U.emit("truncate",w.to,w.fork),R&&U.emit("append")}}async moveTo(v,w){const R=v.state;await this.mutex.lock();try{const A=this.length;let q=null,U=!1;if(!this.isSnapshot()){this.lingers===null&&(this.lingers=[]),this.lingers.push(this.storage);const T=await R.storage.resumeSession(this.name),Q=w<this.length?await _(this,w):null,le=Q?Q.tree:T?null:await R._getTreeHeadAt(this.length),Y=Q?this.fork+1:this.fork;let oe=null;T?oe=T:(le.fork=Y,oe=await R.storage.createSession(this.name,le));const ue=await s.getRootsFromStorage(oe,w);if(this.storage=oe,this.prologue=R.prologue,this.fork=Y,this.length=w,this.byteLength=s.size(ue),this.roots=ue,Q){const{dependency:O}=Q;O&&this.storage.setDependencyHead(O),q={to:A,fork:Y}}this.length>A&&(U=!0)}for(let T=this.core.sessionStates.length-1;T>=0;T--){const Q=this.core.sessionStates[T];Q!==this&&Q.name===this.name&&Q._moveToCore(v.core)}this._moveToCore(v.core,q,U)}finally{this.mutex.unlock()}}async createSession(v,w,R){let A=null,q=null;!R&&!w&&this.storage&&(A=await this.storage.resumeSession(v),A!==null&&(q=await z(A)||M()));const U=q?q.length:this.length;if(A===null&&(q=await this._getTreeHeadAt(U),R?A=await this.storage.createAtomicSession(R,q):A=await this.storage.createSession(v,q)),this.atomized&&R)throw new Error("Session already atomized");const T={fork:this.fork,roots:U===this.length?this.roots.slice():await s.getRootsFromStorage(A,U),length:U,prologue:this.prologue,signature:U===this.length?this.signature:null},Q=new Uf(this.core,R?this:null,A,T,R?this.name:v);return R&&(this.atomized=R,R.onflush(Q._commit.bind(Q))),Q}};function f(){}function m(j){return Math.floor(j/c.BITS_PER_PAGE)}function E(j,v,w,R,A){const q=R*c.BITS_PER_PAGE,U=q+c.BITS_PER_PAGE,T=U<w?U:w,Q=v-q,le=T-q;return g.fill(j,A,Q,le),T}async function b(j,v,w,R,A){if(w>=R)return;const q=m(w),U=m(R-1);let T=w;const Q=j.read(),le=[];for(let ue=q;ue<=U;ue++)le.push(Q.getBitfieldPage(ue));Q.tryFlush();const Y=await Promise.all(le),oe=U-q+1;for(let ue=0;ue<oe;ue++){const O=ue+q;Y[ue]||(Y[ue]=a.alloc(c.BYTES_PER_PAGE)),T=E(Y[ue],T,R,O,A),v.putBitfieldPage(O,Y[ue])}}async function _(j,v){const w=j.createTreeBatch();await s.truncate(j,v,w,j.fork);const R=j.createWriteBatch(),A=await j._truncate(R,w),q=await j.flush();return{tree:A.tree,roots:A.roots,dependency:A.dependency,flushed:q}}function B(j,v,w){const R=j.storage.findDependencyIndex(v,w);return R===-1?null:{dataPointer:j.storage.dependencies[R].dataPointer,length:v}}function M(){return{fork:0,length:0,rootHash:null,signature:null}}function z(j){const v=j.read(),w=v.getHead();return v.tryFlush(),w}return Ou}var Pu,vw;function $v(){return vw||(vw=1,Pu=class{constructor(a){this.values=a,this.start=0,this.length=this.values.length}next(){if(this.length===0){if(this.start===0)return{done:!0,value:void 0};this.length=this.start,this.start=0}const a=this.start+(Math.random()*this.length|0),p=this.start+--this.length,l=this.values[a];return this.values[a]=this.values[p],this.values[p]=l,{done:!1,value:l}}dequeue(){this.values[this.start+this.length]=this.values[this.values.length-1],this.values.pop()}requeue(){const a=this.start+this.length,p=this.values[a];this.values[a]=this.values[this.start],this.values[this.start++]=p}restart(){return this.start=0,this.length=this.values.length,this}[Symbol.iterator](){return this}}),Pu}var Iu,kw;function ES(){if(kw)return Iu;kw=1;const n=Ff();return Iu=class{constructor(){this.queue=new n,this.priority=[],this.requests=new Map,this.length=0}push(p){p.priority>0?this.priority.push(p):this.queue.push(p),this.requests.set(p.id,p),this.length++}shift(){for(;this.priority.length>0;){const p=this.priority.pop(),l=this._processRequest(p);if(l!==null)return l}for(;this.queue.length>0;){const p=this.queue.shift(),l=this._processRequest(p);if(l!==null)return l}return null}_processRequest(p){return p.block||p.hash||p.seek||p.upgrade||p.manifest?(this.requests.delete(p.id),this.length--,p):null}clear(){this.queue.clear(),this.priority=[],this.length=0,this.requests.clear()}delete(p){const l=this.requests.get(p);l&&(l.block=null,l.hash=null,l.seek=null,l.upgrade=null,l.manifest=!1,this.requests.delete(p),this.length--,this.length===0&&(this.queue.clear(),this.priority=[]))}},Iu}var Ku,Sw;function AS(){if(Sw)return Ku;Sw=1;const n=16;Ku=class{constructor(){this.priorities=[[],[],[]]}*pick(l){for(let g=0;g<this.priorities.length;g++){let y=(this.priorities.length-g)*n;const h=this.priorities[g];for(let o=0;o<h.length;o++){const c=o+Math.floor(Math.random()*h.length-o),s=h[o],u=h[c];if(c!==o&&(h[u.hotswap.index=o]=u,h[s.hotswap.index=c]=s),!a(u,l)&&(yield u,--y<=0))break}}}add(l){if(l.hotswap!==null&&this.remove(l),l.inflight.length===0||l.inflight.length>=3)return;const g=this.priorities[l.inflight.length-1],y=g.push(l)-1;l.hotswap={ref:this,queue:g,index:y}}remove(l){const g=l.hotswap;if(g===null)return;l.hotswap=null;const y=g.queue.pop();y!==l&&(g.queue[y.hotswap.index=g.index]=y)}};function a(p,l){for(let g=0;g<p.inflight.length;g++)if(p.inflight[g].peer===l)return!0;return!1}return Ku}var zu,xw;function RS(){if(xw)return zu;xw=1;const n=Ue(),a=jt(),p=$v(),l=rn(),g=ES(),y=AS(),h=Wv(),{MerkleTree:o}=nr(),{REQUEST_CANCELLED:c,REQUEST_TIMEOUT:s,INVALID_CAPABILITY:u,SNAPSHOT_NOT_AVAILABLE:f}=Lt(),m=Yf(),E=tr(),b=[16,512],_=50,B=256*1024*8,M=2e4+Math.random()*2e4|0,z=3,j=256,v=2048,w=64,R={NORMAL:0,HIGH:1,VERY_HIGH:2,CANCELLED:255};class A{constructor(){this.resolved=!1,this.processing=!1,this.refs=[]}attach(F){const ne={context:this,session:F,sindex:0,rindex:0,snapshot:!0,resolve:null,reject:null,promise:null,timeout:null};return ne.sindex=F.push(ne)-1,ne.rindex=this.refs.push(ne)-1,ne.promise=new Promise((ye,me)=>{ne.resolve=ye,ne.reject=me}),ne}detach(F,ne=null){return F.context!==this?!1:(this._detach(F),this._cancel(F,ne),this.gc(),!0)}_detach(F){const ne=this.refs.pop(),ye=F.session.pop();return F.rindex<this.refs.length&&(this.refs[ne.rindex=F.rindex]=ne),F.sindex<F.session.length&&(F.session[ye.sindex=F.sindex]=ye),W(F),F.context=null,F}gc(){this.refs.length===0&&!this.processing&&this._unref()}processed(){this.processing=!1,this.gc()}_cancel(F,ne){F.reject(ne||c())}_unref(){}resolve(F){for(this.resolved=!0;this.refs.length>0;)this._detach(this.refs[this.refs.length-1]).resolve(F)}reject(F){for(this.resolved=!0;this.refs.length>0;)this._detach(this.refs[this.refs.length-1]).reject(F)}setTimeout(F,ne){W(F),F.timeout=setTimeout(re,ne,F)}}class q extends A{constructor(F,ne,ye){super(),this.index=ne,this.priority=ye,this.inflight=[],this.queued=!1,this.hotswap=null,this.tracker=F}_unref(){this.queued=!1;for(const F of this.inflight)F.peer._cancelRequest(F);this.tracker.remove(this.index),Z(this)}}class U extends A{constructor(F,ne,ye,me,Ee,qe){super(),this.start=ne,this.end=ye,this.linear=me,this.ifAvailable=Ee,this.blocks=qe,this.ranges=F,this.userStart=ne,this.userEnd=ye}_unref(){const F=this.ranges.indexOf(this);if(F===-1)return;const ne=this.ranges.pop();F<this.ranges.length&&(this.ranges[F]=ne)}_cancel(F){F.resolve(!1)}}class T extends A{constructor(F,ne,ye){super(),this.fork=ne,this.length=ye,this.inflight=[],this.replicator=F}_unref(){this.replicator.eagerUpgrade===!0||this.inflight.length>0||(this.replicator._upgrade=null)}_cancel(F){F.resolve(!1)}}class Q extends A{constructor(F,ne){super(),this.seeker=ne,this.inflight=[],this.seeks=F}_unref(){if(this.inflight.length>0)return;const F=this.seeks.indexOf(this);if(F===-1)return;const ne=this.seeks.pop();F<this.seeks.length&&(this.seeks[F]=ne)}}class le{constructor(){this._requests=[],this._free=[]}get idle(){return this._requests.length===this._free.length}*[Symbol.iterator](){for(const F of this._requests)F!==null&&(yield F)}add(F){const ne=this._free.length?this._free.pop():this._requests.push(null);return F.id=ne,this._requests[ne-1]=F,F}get(F){return F<=this._requests.length?this._requests[F-1]:null}remove(F,ne){F>this._requests.length||(this._requests[F-1]=null,ne===!0&&this._free.push(F))}reusable(F){this._free.push(F)}}class Y{constructor(){this._map=new Map}[Symbol.iterator](){return this._map.values()}isEmpty(){return this._map.size===0}has(F){return this._map.has(F)}get(F){return this._map.get(F)||null}add(F,ne){let ye=this._map.get(F);return ye||(ye=new q(this,F,ne),this._map.set(F,ye),ye)}remove(F){const ne=this.get(F);return this._map.delete(F),ne}}class oe{constructor(){this.queue=[],this.tick=0}clear(){const F=new Array(this.queue.length);for(let ne=0;ne<F.length;ne++)F[ne]=this.queue[ne][1];return this.queue=[],F}add(F){this.queue.push([++this.tick,F])}flush(F){let ne=null;for(let ye=0;ye<this.queue.length&&!(this.queue[ye][0]>F);ye++)ne===null&&(ne=[]),ne.push(this.queue[ye][1]);return ne!==null&&this.queue.splice(0,ne.length),ne}}class ue{constructor(F,ne,ye,me){this.msg=F,this.proof=ne,this.block=ye,this.manifest=me}async fulfill(){if(this.proof===null)return null;const[F,ne]=await Promise.all([this.proof.settle(),this.block]);return this.manifest&&(F.manifest=this.manifest),!ne&&F.block?null:(ne&&(F.block.value=ne),F)}}class O{constructor(F,ne,ye,me){this.core=F.core,this.replicator=F,this.stream=ne.stream,this.protomux=ne,this.remotePublicKey=this.stream.remotePublicKey,this.remoteSupportsSeeks=!1,this.inflightRange=me,this.remoteSegmentsWanted=new Set,this.paused=!1,this.removed=!1,this.channel=ye,this.channel.userData=this,this.wireSync=this.channel.messages[0],this.wireRequest=this.channel.messages[1],this.wireCancel=this.channel.messages[2],this.wireData=this.channel.messages[3],this.wireNoData=this.channel.messages[4],this.wireWant=this.channel.messages[5],this.wireUnwant=this.channel.messages[6],this.wireBitfield=this.channel.messages[7],this.wireRange=this.channel.messages[8],this.wireExtension=this.channel.messages[9],this.stats={wireSync:{tx:0,rx:0},wireRequest:{tx:0,rx:0},wireCancel:{tx:0,rx:0},wireData:{tx:0,rx:0},wireWant:{tx:0,rx:0},wireBitfield:{tx:0,rx:0},wireRange:{tx:0,rx:0},wireExtension:{tx:0,rx:0},hotswaps:0},this.receiverQueue=new g,this.receiverBusy=!1,this.roundtripQueue=null,this.inflight=0,this.dataProcessing=0,this.canUpgrade=!0,this.needsSync=!1,this.syncsProcessing=0,this._remoteContiguousLength=0,this.remoteOpened=!1,this.remoteBitfield=new h,this.missingBlocks=new h,this.remoteFork=0,this.remoteLength=0,this.remoteCanUpgrade=!1,this.remoteUploading=!0,this.remoteDownloading=!0,this.remoteSynced=!1,this.remoteHasManifest=!1,this.remoteRequests=new Map,this.segmentsWanted=new Set,this.broadcastedNonSparse=!1,this.lengthAcked=0,this.extensions=new Map,this.lastExtensionSent="",this.lastExtensionRecv="",F._ifAvailable++,F._active++}get remoteContiguousLength(){return this.remoteBitfield.findFirst(!1,this._remoteContiguousLength)}getMaxInflight(){const F=this.stream.rawStream;if(!F.udx)return Math.min(this.inflightRange[1],this.inflightRange[0]*3);const ne=F.rtt<=_?1:F.rtt/_*Math.min(1,2/this.replicator.peers.length);return Math.max(this.inflightRange[0],Math.round(Math.min(this.inflightRange[1],this.inflightRange[0]*ne)))}getMaxHotswapInflight(){const F=this.getMaxInflight();return Math.max(16,F/2)}signalUpgrade(){this._shouldUpdateCanUpgrade()===!0?this._updateCanUpgradeAndSync():this.sendSync()}_markInflight(F){this.missingBlocks.set(F,!1)}broadcastRange(F,ne,ye){if(!this.isActive())return;ye?this._unclearLocalRange(F,ne):this._clearLocalRange(F,ne);const me=Math.floor(F/B),Ee=this.core.header.hints.contiguousLength===this.core.state.length;if(!(F+j<this.core.state.length&&!this.remoteSegmentsWanted.has(me)&&!ye&&!Ee)){if(Ee&&!ye&&(F=0,ne=this.core.state.length),!ye){if(this._remoteContiguousLength>=F+ne)return;if(ne===1){if(this.remoteBitfield.get(F))return}else if(this.remoteBitfield.firstUnset(F)>=F+ne)return}this.wireRange.send({drop:ye,start:F,length:ne}),ee(this.stats.wireRange,this.replicator.stats.wireRange)}}extension(F,ne){this.wireExtension.send({name:F===this.lastExtensionSent?"":F,message:ne}),ee(this.stats.wireExtension,this.replicator.stats.wireExtension),this.lastExtensionSent=F}onextension(F){const ne=F.name||this.lastExtensionRecv;this.lastExtensionRecv=ne;const ye=this.extensions.get(ne);ye&&ye._onmessage({start:0,end:F.message.byteLength,buffer:F.message},this)}sendSync(){if(this.syncsProcessing!==0){this.needsSync=!0;return}this.core.state.fork!==this.remoteFork&&(this.canUpgrade=!1),this.needsSync=!1,this.wireSync.send({fork:this.core.state.fork,length:this.core.state.length,remoteLength:this.core.state.fork===this.remoteFork?this.remoteLength:0,canUpgrade:this.canUpgrade,uploading:!0,downloading:this.replicator.isDownloading(),hasManifest:!!this.core.header.manifest&&this.core.compat===!1}),ee(this.stats.wireSync,this.replicator.stats.wireSync)}onopen({seeks:F,capability:ne}){const ye=E.replicate(this.stream.isInitiator===!1,this.core.key,this.stream.handshakeHash);if(n.equals(ne,ye)!==!0)throw u("Remote sent an invalid replication capability");if(this.remoteOpened===!0)return;this.remoteOpened=!0,this.remoteSupportsSeeks=F,this.protomux.cork(),this.sendSync();const me=Math.min(this.core.state.length,this.core.header.hints.contiguousLength);me>0&&(this.broadcastRange(0,me,!1),me===this.core.state.length&&(this.broadcastedNonSparse=!0)),this.replicator._ifAvailable--,this.replicator._addPeer(this),this.protomux.uncork(),this.core.checkIfIdle()}onclose(F){const ne=F===!0&&this.remoteOpened===!0&&this.remoteDownloading===!1&&this.remoteUploading===!0&&this.replicator.downloading===!0;if(this.remoteOpened===!1){this.replicator._ifAvailable--,this.replicator.updateAll();return}if(this.remoteOpened=!1,this.removed=!0,this.remoteRequests.clear(),this.receiverQueue.clear(),this.roundtripQueue!==null)for(const ye of this.roundtripQueue.clear())this.replicator._inflight.reusable(ye);this.replicator._removePeer(this),ne&&this.replicator._makePeer(this.protomux)}closeIfIdle(){return this.remoteDownloading===!1&&this.replicator.isDownloading()===!1?(this.channel.close(),!0):!1}async onsync({fork:F,length:ne,remoteLength:ye,canUpgrade:me,uploading:Ee,downloading:qe,hasManifest:Oe}){const Pe=ne!==this.remoteLength,ze=F===this.core.state.fork;if(this.remoteSynced=!0,this.remoteFork=F,this.remoteLength=ne,this.remoteCanUpgrade=me,this.remoteUploading=Ee,this.remoteDownloading=qe,this.remoteHasManifest=Oe,this.closeIfIdle())return;this.lengthAcked=ze?ye:0,this.syncsProcessing++,this.replicator._updateFork(this),this.remoteLength>this.core.state.length&&this.lengthAcked===this.core.state.length&&this.replicator._addUpgradeMaybe()!==null&&this._update();const it=Pe===!1||ze===!1?this.canUpgrade&&ze:await this._canUpgrade(ne,F);ne===this.remoteLength&&F===this.core.state.fork&&(this.canUpgrade=it),--this.syncsProcessing===0&&((this.needsSync===!0||this.core.state.fork===this.remoteFork&&this.core.state.length>this.remoteLength)&&this.signalUpgrade(),this._update())}_shouldUpdateCanUpgrade(){return this.core.state.fork===this.remoteFork&&this.core.state.length>this.remoteLength&&this.canUpgrade===!1&&this.syncsProcessing===0}async _updateCanUpgradeAndSync(){const{length:F,fork:ne}=this.core.state,ye=await this._canUpgrade(this.remoteLength,this.remoteFork);this.syncsProcessing>0||F!==this.core.state.length||ne!==this.core.state.fork||ye!==this.canUpgrade&&(this.canUpgrade=ye,this.sendSync())}async _canUpgrade(F,ne){if(ne!==this.core.state.fork)return!1;if(F===0)return!0;if(F>=this.core.state.length)return!1;try{const ye=await o.upgradeable(this.core.state,F);return ne!==this.core.state.fork?!1:ye}catch{return!1}}async _getProof(F,ne){let ye=null;if(ne.block){const Ee=ne.block.index;if(ne.fork!==this.core.state.fork||!this.core.bitfield.get(Ee))return new ue(ne,null,null,null);ye=F.getBlock(Ee),ye.catch(ve)}const me=ne.manifest&&!this.core.compat?this.core.header.manifest:null;try{const Ee=await o.proof(this.core.state,F,ne);return new ue(ne,Ee,ye,me)}catch(Ee){throw F.destroy(),Ee}}async onrequest(F){const ne=this.remoteRequests.size;if(this.remoteRequests.set(F.id,F),ne===this.remoteRequests.size&&(this._cancel(F.id),this.remoteRequests.set(F.id,F)),!this.protomux.drained||this.receiverQueue.length){this.receiverQueue.push(F);return}this.replicator.destroyed||await this._handleRequest(F)}oncancel(F){this._cancel(F.request)}_cancel(F){this.remoteRequests.delete(F),this.receiverQueue.delete(F)}ondrain(){return this._handleRequests()}async _handleRequests(){if(!(this.receiverBusy||this.replicator.destroyed)){for(this.receiverBusy=!0,this.protomux.cork();this.remoteOpened&&this.protomux.drained&&this.receiverQueue.length>0&&!this.removed;){const F=this.receiverQueue.shift();await this._handleRequest(F)}this.protomux.uncork(),this.receiverBusy=!1}}async _handleRequest(F){const ne=this.core.storage.read(),ye=F.fork===this.core.state.fork?await this._getProof(ne,F):new ue(F,null,null,null);ne.tryFlush(),await this._fulfillRequest(ye)}async _fulfillRequest(F){const ne=await F.fulfill();if(this.remoteRequests.get(F.msg.id)===F.msg&&(this.remoteRequests.delete(F.msg.id),!(!this.isActive()&&ne.block!==null))){if(ne===null){if(F.msg.manifest&&this.core.header.manifest){const ye=this.core.header.manifest;this.wireData.send({request:F.msg.id,fork:this.core.state.fork,block:null,hash:null,seek:null,upgrade:null,manifest:ye}),ee(this.stats.wireData,this.replicator.stats.wireData);return}this.wireNoData.send({request:F.msg.id});return}ne.block!==null&&this.replicator._onupload(ne.block.index,ne.block.value.byteLength,this),this.wireData.send({request:F.msg.id,fork:F.msg.fork,block:ne.block,hash:ne.hash,seek:ne.seek,upgrade:ne.upgrade,manifest:ne.manifest}),ee(this.stats.wireData,this.replicator.stats.wireData)}}_cancelRequest(F){F.priority!==R.CANCELLED&&(F.priority=R.CANCELLED,this.inflight--,this.replicator._requestDone(F.id,!1),de(F)&&this.replicator._unmarkInflight(F.block.index),C(F)&&this.replicator._clearInflightUpgrade(F),this.roundtripQueue===null&&(this.roundtripQueue=new oe),this.roundtripQueue.add(F.id),this.wireCancel.send({request:F.id}),ee(this.stats.wireCancel,this.replicator.stats.wireCancel))}_checkIfConflict(){this.paused=!0;const F=Math.min(this.core.state.length,this.remoteLength);F!==0&&(this.wireRequest.send({id:0,fork:this.remoteFork,block:null,hash:null,seek:null,upgrade:{start:0,length:F}}),ee(this.stats.wireRequest,this.replicator.stats.wireRequest))}async ondata(F){if(F.request===0&&F.upgrade&&F.upgrade.start===0){if(await this.core.checkConflict(F,this))return;this.paused=!1}const ne=F.request>0?this.replicator._inflight.get(F.request):null,ye=F.fork>this.core.state.fork;if(!(ne===null&&ye===!1)){if(ne!==null){if(ne.peer!==this)return;this._onrequestroundtrip(ne)}try{if(ye===!0)return await this.replicator._onreorgdata(this,ne,F)}catch(me){a(me),de(ne)&&this.replicator._unmarkInflight(ne.block.index),this.paused=!0,this.replicator._oninvalid(me,ne,F,this);return}this.dataProcessing++,de(ne)&&this.replicator._markProcessing(ne.block.index);try{if(!P(ne,F)||!await this.core.verify(F,this)){this.replicator._onnodata(this,ne);return}}catch(me){if(a(me),de(ne)&&this.replicator._unmarkInflight(ne.block.index),me.code==="WRITE_FAILED"){this.paused=!0;return}if(this.core.closed&&!$(me))return;me.code!=="INVALID_OPERATION"&&this._checkIfConflict(),this.replicator._onnodata(this,ne),this.replicator._oninvalid(me,ne,F,this);return}finally{de(ne)&&this.replicator._markProcessed(ne.block.index),this.dataProcessing--}this.replicator._ondata(this,ne,F),this._shouldUpdateCanUpgrade()===!0&&this._updateCanUpgradeAndSync()}}onnodata({request:F}){const ne=F>0?this.replicator._inflight.get(F):null;ne===null||ne.peer!==this||(this._onrequestroundtrip(ne),this.replicator._onnodata(this,ne))}_onrequestroundtrip(F){if(F.priority===R.CANCELLED||(F.priority=R.CANCELLED,this.inflight--,this.replicator._requestDone(F.id,!0),this.roundtripQueue===null))return;const ne=this.roundtripQueue.flush(F.rt);if(ne!==null)for(const ye of ne)this.replicator._inflight.reusable(ye)}onwant({start:F,length:ne}){const ye=Math.floor(F/B);this.remoteSegmentsWanted.size>=v&&this.remoteSegmentsWanted.clear(),this.remoteSegmentsWanted.add(ye),this.replicator._onwant(this,F,ne)}onunwant(){}onbitfield({start:F,bitfield:ne}){F<this._remoteContiguousLength&&(this._remoteContiguousLength=F),this.remoteBitfield.insert(F,ne),this.missingBlocks.insert(F,ne),this._clearLocalRange(F,ne.byteLength*8),this._update()}_clearLocalRange(F,ne){const ye=this.core.skipBitfield===null?this.core.bitfield:this.core.skipBitfield;if(ne===1){this.missingBlocks.set(F,this._remoteHasBlock(F)&&!ye.get(F));return}const me=Math.min(this.core.state.length,this.core.header.hints.contiguousLength);if(F+ne<me){this.missingBlocks.setRange(F,me,!1);return}const Ee=F&32767;Ee>0&&(F-=Ee,ne+=Ee);const qe=F+Math.min(ne,this.core.state.length);for(;F<qe;){const Oe=ye.getBitfield(F);Oe&&Oe.bitfield&&this.missingBlocks.clear(F,Oe.bitfield),F+=32768}}_resetMissingBlock(F){const ne=this.core.skipBitfield===null?this.core.bitfield:this.core.skipBitfield;this.missingBlocks.set(F,this._remoteHasBlock(F)&&!ne.get(F))}_unclearLocalRange(F,ne){if(ne===1){this._resetMissingBlock(F);return}const ye=F&2097151;ye>0&&(F-=ye,ne+=ye);const me=F,Ee=F+Math.min(ne,this.remoteLength);for(;F<Ee;){const qe=this.remoteBitfield.getBitfield(F);qe&&qe.bitfield&&this.missingBlocks.insert(F,qe.bitfield),F+=2097152}this._clearLocalRange(me,ne)}onrange({drop:F,start:ne,length:ye}){const me=F===!1;if(F===!0&&ne<this._remoteContiguousLength&&(this._remoteContiguousLength=ne),ne===0&&F===!1)ye>this._remoteContiguousLength&&(this._remoteContiguousLength=ye);else if(ye===1){const Ee=this.core.skipBitfield===null?this.core.bitfield:this.core.skipBitfield;this.remoteBitfield.set(ne,me),this.missingBlocks.set(ne,me&&!Ee.get(ne))}else{const Ee=this.remoteBitfield.findFirst(!me,ne),qe=ye+ne;Ee!==-1&&Ee<qe&&(this.remoteBitfield.setRange(Ee,qe,me),this.missingBlocks.setRange(Ee,qe,me),me&&this._clearLocalRange(Ee,qe-Ee))}F===!1&&this._update()}onreorghint(){}_update(){this.replicator.updatePeer(this)}async _onconflict(){this.protomux.cork(),this.remoteLength>0&&this.core.state.fork===this.remoteFork&&await this.onrequest({id:0,fork:this.core.state.fork,block:null,hash:null,seek:null,upgrade:{start:0,length:Math.min(this.core.state.length,this.remoteLength)}}),this.channel.close(),this.protomux.uncork()}_makeRequest(F,ne,ye){return F===!0&&this.replicator._shouldUpgrade(this)===!1||this.remoteLength<ye?null:(F===!1&&this.replicator._autoUpgrade(this)===!0&&(F=!0),{peer:this,rt:this.roundtripQueue===null?0:this.roundtripQueue.tick,id:0,fork:this.remoteFork,block:null,hash:null,seek:null,upgrade:F===!1?null:{start:this.core.state.length,length:this.remoteLength-this.core.state.length},manifest:this.core.header.manifest===null&&this.remoteHasManifest===!0,priority:ne,timestamp:Date.now(),elapsed:0})}_requestManifest(){const F=this._makeRequest(!1,0,0);this._send(F)}_requestUpgrade(F){const ne=this._makeRequest(!0,0,0);return ne===null?!1:(this._send(ne),!0)}_requestSeek(F){if(this.replicator._updatesPending>0)return!1;const{length:ne,fork:ye}=this.core.state;if(ye!==this.remoteFork)return!1;if(F.seeker.start>=ne){const qe=this._makeRequest(!0,0,0);return qe===null?!1:(qe.seek=this.remoteSupportsSeeks?{bytes:F.seeker.bytes,padding:F.seeker.padding}:null,F.inflight.push(qe),this._send(qe),!0)}const me=F.seeker.end-F.seeker.start,Ee=F.seeker.start+Math.floor(Math.random()*me);for(let qe=0;qe<me;qe++){let Oe=Ee+qe;if(Oe>F.seeker.end&&(Oe-=me),this._remoteHasBlock(Oe)===!1||this.core.bitfield.get(Oe)===!0||!this._hasTreeParent(Oe))continue;const Pe=this.replicator._blocks.get(Oe);if(Pe!==null&&Pe.inflight.length>0)continue;const ze=this.replicator._hashes.add(Oe,R.NORMAL);if(ze.inflight.length>0)continue;const it=this._makeRequest(!1,ze.priority,Oe+1);if(it===null)continue;const at=l.depth(F.seeker.start+F.seeker.end-1);return it.hash={index:2*Oe,nodes:at},it.seek=this.remoteSupportsSeeks?{bytes:F.seeker.bytes,padding:F.seeker.padding}:null,F.inflight.push(it),ze.inflight.push(it),this._send(it),!0}return this._maybeWant(F.seeker.start,me),!1}_hasTreeParent(F){if(this.remoteLength>=this.core.state.length)return!0;const ne=l.iterator(F*2);let ye=2,me=0;for(;;){ne.parent();const Ee=(ne.index-ne.factor/2+1)/2;if(me=Ee+ye,me>this.core.state.length){if(me>this.remoteLength)return!0;break}if(me>this.remoteLength)break;ye*=2;const qe=this.core.bitfield.findFirst(!0,Ee);if(qe>-1&&qe<me)return!0}return!1}_remoteHasBlock(F){return F<this._remoteContiguousLength||this.remoteBitfield.get(F)===!0}_sendBlockRequest(F,ne){F.block={index:ne.index,nodes:0},this.replicator._markInflight(ne.index),ne.inflight.push(F),this.replicator.hotswaps.add(ne),this._send(F)}_requestBlock(F){const{length:ne,fork:ye}=this.core.state;if(this._remoteHasBlock(F.index)===!1||ye!==this.remoteFork)return this._maybeWant(F.index),!1;if(!this._hasTreeParent(F.index))return!1;const me=this._makeRequest(F.index>=ne,F.priority,F.index+1);return me===null?!1:(this._sendBlockRequest(me,F),!0)}_requestRangeBlock(F,ne){if(this.core.bitfield.get(F)===!0||!this._hasTreeParent(F))return!1;const ye=this.replicator._blocks.add(F,R.NORMAL);if(ye.inflight.length>0)return this.missingBlocks.set(F,!1),!1;const me=this._makeRequest(F>=ne,ye.priority,F+1);return me===null?(ye.gc(),!1):(this._sendBlockRequest(me,ye),ye.queued&&(ye.queued=!1),!0)}_findNext(F){if(F<this._remoteContiguousLength){if(this.core.skipBitfield===null&&this.replicator._openSkipBitfield(),F=this.core.skipBitfield.findFirst(!1,F),F<this._remoteContiguousLength&&F>-1)return F;F=this._remoteContiguousLength}return this.missingBlocks.findFirst(!0,F)}_requestRange(F){const{length:ne,fork:ye}=this.core.state;if(F.blocks){let Pe=-1,ze=-1;for(let it=F.start;it<F.end;it++){const at=F.blocks[it];if((Pe===-1||at<Pe)&&(Pe=at),(ze===-1||at>ze)&&(ze=at),(at<this._remoteContiguousLength||this.missingBlocks.get(at)===!0)===!0&&this._requestRangeBlock(at,ne))return!0}return Pe>-1&&this._maybeWant(Pe,ze-Pe),!1}const me=Math.min(this.core.state.length,Math.min(F.end===-1?this.remoteLength:F.end,this.remoteLength));if(me<=F.start||ye!==this.remoteFork)return!1;const Ee=me-F.start,qe=F.start+(F.linear?0:Math.floor(Math.random()*Ee));let Oe=qe;for(;Oe=this._findNext(Oe),!(Oe===-1||Oe>=me);){if(this._requestRangeBlock(Oe,ne))return!0;Oe++}for(Oe=F.start;Oe=this._findNext(Oe),!(Oe===-1||Oe>=qe);){if(this._requestRangeBlock(Oe,ne))return!0;Oe++}return this._maybeWant(F.start,Ee),!1}_requestForkProof(F){if(!this.remoteLength)return;const ne=this._makeRequest(!1,0,0);ne.upgrade={start:0,length:this.remoteLength},ne.manifest=!this.core.header.manifest,F.inflight.push(ne),this._send(ne)}_requestForkRange(F){if(F.fork!==this.remoteFork||F.batch.want===null)return!1;const ne=Math.min(F.batch.want.end,this.remoteLength);if(ne<F.batch.want.start)return!1;const ye=ne-F.batch.want.start,me=F.batch.want.start+Math.floor(Math.random()*ye);for(let Ee=0;Ee<ye;Ee++){let qe=me+Ee;if(qe>=ne&&(qe-=ye),this._remoteHasBlock(qe)===!1)continue;const Oe=this._makeRequest(!1,0,0);return Oe.hash={index:2*qe,nodes:F.batch.want.nodes},F.inflight.push(Oe),this._send(Oe),!0}return this._maybeWant(F.batch.want.start,ye),!1}_maybeWant(F,ne=1){if(F+ne<=this.remoteContiguousLength)return;let ye=Math.floor(F/B);const me=Math.ceil((F+ne)/B);for(;ye<me;ye++)this.segmentsWanted.has(ye)||(this.segmentsWanted.add(ye),this.wireWant.send({start:ye*B,length:B}),ee(this.stats.wireWant,this.replicator.stats.wireWant))}isActive(){return!(this.paused||this.removed||this.core.header.frozen)}async _send(F){const ne=this.core.state.fork;this.inflight++,this.replicator._inflight.add(F),F.upgrade!==null&&F.fork===ne&&this.replicator._addUpgrade().inflight.push(F);try{if(F.block!==null&&F.fork===ne&&(F.block.nodes=await o.missingNodes(this.core.state,2*F.block.index,this.core.state.length),F.priority===R.CANCELLED))return;if(F.hash!==null&&F.fork===ne&&F.hash.nodes===0){if(F.hash.nodes=await o.missingNodes(this.core.state,F.hash.index,this.core.state.length),F.priority===R.CANCELLED)return;if(F.hash.nodes===0&&(F.hash.index&1)===0){this.inflight--,this.replicator._resolveHashLocally(this,F);return}}}catch(ye){this.stream.destroy(ye);return}this.wireRequest.send(F),ee(this.stats.wireRequest,this.replicator.stats.wireRequest)}}zu=class{static Peer=O;constructor(F,{notDownloadingLinger:ne=M,eagerUpgrade:ye=!0,allowFork:me=!0,inflightRange:Ee=null}={}){this.core=F,this.eagerUpgrade=ye,this.allowFork=me,this.ondownloading=null,this.peers=[],this.findingPeers=0,this.destroyed=!1,this.downloading=!1,this.activeSessions=0,this.hotswaps=new y,this.inflightRange=Ee||b,this.stats={wireSync:{tx:0,rx:0},wireRequest:{tx:0,rx:0},wireCancel:{tx:0,rx:0},wireData:{tx:0,rx:0},wireWant:{tx:0,rx:0},wireBitfield:{tx:0,rx:0},wireRange:{tx:0,rx:0},wireExtension:{tx:0,rx:0},hotswaps:0},this._attached=new Set,this._inflight=new le,this._blocks=new Y,this._hashes=new Y,this._queued=[],this._seeks=[],this._upgrade=null,this._reorgs=[],this._ranges=[],this._hadPeers=!1,this._active=0,this._ifAvailable=0,this._updatesPending=0,this._applyingReorg=null,this._manifestPeer=null,this._notDownloadingLinger=ne,this._downloadingTimer=null;const qe=this;this._onstreamclose=Oe;function Oe(){qe.detachFrom(this.userData)}}updateActivity(F,ne){this.activeSessions+=F,this.setDownloading(this.activeSessions!==0,ne)}isDownloading(){return this.downloading||!this._inflight.idle}setDownloading(F){if(clearTimeout(this._downloadingTimer),!this.destroyed){if(F||this._notDownloadingLinger===0){this.setDownloadingNow(F);return}this._downloadingTimer=setTimeout(te,this._notDownloadingLinger,this,F),this._downloadingTimer.unref&&this._downloadingTimer.unref()}}setDownloadingNow(F){if(this._downloadingTimer=null,this.downloading!==F&&(this.downloading=F,!(!F&&this.isDownloading()))){for(const ne of this.peers)ne.signalUpgrade();if(F)for(const ne of this._attached)ne.stream.handshakeHash&&(ne.opened({protocol:"hypercore/alpha",id:this.core.discoveryKey})||this._makePeer(ne,!0));else for(const ne of this.peers)ne.closeIfIdle();this.ondownloading!==null&&F&&this.ondownloading()}}cork(){for(const F of this.peers)F.protomux.cork()}uncork(){for(const F of this.peers)F.protomux.uncork()}onhave(F,ne,ye=!1){for(const me of this.peers)me.broadcastRange(F,ne,ye)}ontruncate(F,ne){const ye=[];for(const me of this._blocks)me.index<F||ye.push(me);for(const me of ye)for(const Ee of me.refs)Ee.snapshot!==!1&&me.detach(Ee,f());for(const me of this.peers)me._unclearLocalRange(F,ne)}onupgrade(){for(const F of this.peers)F.signalUpgrade();this._blocks.isEmpty()===!1&&this._resolveBlocksLocally(),this._upgrade!==null&&this._resolveUpgradeRequest(null),(!this._blocks.isEmpty()||this._ranges.length!==0||this._seeks.length!==0)&&this._updateNonPrimary(!0)}async onconflict(){const F=[];for(const ne of this.peers)F.push(ne._onconflict());await Promise.allSettled(F)}async applyPendingReorg(){if(this._applyingReorg!==null)return await this._applyingReorg,!0;for(let F=this._reorgs.length-1;F>=0;F--){const ne=this._reorgs[F];if(ne.batch!==null&&ne.batch.finished)return await this._applyReorg(ne),!0}return!1}addUpgrade(F){if(this._upgrade!==null){const ye=this._upgrade.attach(F);return this._checkUpgradeIfAvailable(),ye}const ne=this._addUpgrade().attach(F);return this.updateAll(),ne}addBlock(F,ne){const ye=this._blocks.add(ne,R.HIGH),me=ye.attach(F);return this._queueBlock(ye),this.updateAll(),me}addSeek(F,ne){const ye=new Q(this._seeks,ne),me=ye.attach(F);return this._seeks.push(ye),this.updateAll(),me}addRange(F,{start:ne=0,end:ye=-1,length:me=se(ne,ye),blocks:Ee=null,linear:qe=!1,ifAvailable:Oe=!1}={}){Ee!==null&&(ne=0,ye=me=Ee.length);const Pe=new U(this._ranges,ne,me===-1?-1:ne+me,qe,Oe,Ee),ze=Pe.attach(F);return G(this.core,Pe),this._ranges.push(Pe),Pe.end!==-1&&Pe.start>=Pe.end?(this._resolveRangeRequest(Pe,this._ranges.length-1),ze):(this.updateAll(),ze)}cancel(F){F.context.detach(F,null)}clearRequests(F,ne=null){let ye=!1;for(;F.length>0;){const me=F[F.length-1];me.context.detach(me,ne),ye=!0}ye&&this.updateAll()}_addUpgradeMaybe(){return this.eagerUpgrade===!0?this._addUpgrade():this._upgrade}_checkUpgradeIfAvailable(){if(this._ifAvailable>0&&this.peers.length<z||this._upgrade===null||this._upgrade.refs.length===0||this._hadPeers===!1&&this.findingPeers>0)return;const F=Math.min(this.peers.length,z);for(let ye=0;ye<F;ye++){const me=this.peers[ye];if(me.remoteSynced===!1||this.core.state.length===0&&me.remoteLength>0)return;if(!(me.remoteLength<=this._upgrade.length||me.remoteFork!==this._upgrade.fork)&&(me.syncsProcessing>0||me.lengthAcked!==this.core.state.length&&me.remoteFork===this.core.state.fork||me.remoteCanUpgrade===!0))return}if(this._applyingReorg!==null)return;for(let ye=0;ye<this._reorgs.length;ye++)if(this._reorgs[ye].inflight.length>0)return;if(this._upgrade.inflight.length>0)return;const ne=this._upgrade;this._upgrade=null,ne.resolve(!1)}_addUpgrade(){return this._upgrade!==null?this._upgrade:(this._upgrade=new T(this,this.core.state.fork,this.core.state.length),this._upgrade)}_addReorg(F,ne){if(this.allowFork===!1)return null;for(const Ee of this._reorgs){if(Ee.fork>F&&Ee.batch!==null)return null;if(Ee.fork===F)return Ee}const ye={fork:F,inflight:[],batch:null};this._reorgs.push(ye);let me=this._reorgs.length-1;for(;me>0&&this._reorgs[me-1].fork>F;)this._reorgs[me]=this._reorgs[me-1],this._reorgs[--me]=ye;return ye}_shouldUpgrade(F){return this._upgrade!==null&&this._upgrade.inflight.length>0?!1:F.remoteCanUpgrade===!0&&F.remoteLength>this.core.state.length&&F.lengthAcked===this.core.state.length}_autoUpgrade(F){return this._upgrade!==null&&F.remoteFork===this.core.state.fork&&this._shouldUpgrade(F)}_addPeer(F){this._hadPeers=!0,this.peers.push(F),this.updatePeer(F),this._onpeerupdate(!0,F)}_requestDone(F,ne){if(this._inflight.remove(F,ne),this.isDownloading()!==!0)for(const ye of this.peers)ye.signalUpgrade()}_removePeer(F){this.peers.splice(this.peers.indexOf(F),1),this._manifestPeer===F&&(this._manifestPeer=null);for(const ne of this._inflight)ne.peer===F&&(this._inflight.remove(ne.id,!0),this._clearRequest(F,ne));this._onpeerupdate(!1,F),this.updateAll()}_queueBlock(F){F.inflight.length>0||F.queued===!0||(F.queued=!0,this._queued.push(F))}_resolveHashLocally(F,ne){this._requestDone(ne.id,!1),this._resolveBlockRequest(this._hashes,ne.hash.index/2,null,ne),this.updatePeer(F)}async _resolveBlocksLocally(){const F=[],ne=[],ye=this.core.storage.read();for(const me of this._blocks)this.core.bitfield.get(me.index)!==!1&&ne.push(this._resolveLocalBlock(me,ye,F));if(ye.tryFlush(),await Promise.all(ne),!!F.length)for(const me of F)this._blocks.remove(me.index),Z(me)}async _resolveLocalBlock(F,ne,ye){try{F.resolve(await ne.getBlock(F.index))}catch(me){F.reject(me);return}ye.push(F)}_resolveBlockRequest(F,ne,ye,me){const Ee=F.remove(ne);if(Ee===null)return!1;if(he(Ee.inflight,me),Z(Ee),Ee.queued=!1,Ee.resolve(ye),Ee.inflight.length>0)for(let qe=Ee.inflight.length-1;qe>=0;qe--){const Oe=Ee.inflight[qe];Oe.peer._cancelRequest(Oe)}return!0}_resolveUpgradeRequest(F){if(F!==null&&he(this._upgrade.inflight,F),this.core.state.length===this._upgrade.length&&this.core.state.fork===this._upgrade.fork)return!1;const ne=this._upgrade;return this._upgrade=null,ne.resolve(!0),!0}_resolveRangeRequest(F,ne){const ye=this._ranges.pop();ne<this._ranges.length&&(this._ranges[ne]=ye),F.resolve(!0)}_clearInflightBlock(F,ne){const ye=F===this._blocks,me=ye===!0?ne.block.index:ne.hash.index/2,Ee=F.get(me);if(!(Ee===null||he(Ee.inflight,ne)===!1)){if(Z(Ee)===!0&&Ee.inflight.length>0&&this.hotswaps.add(Ee),Ee.refs.length>0&&ye===!0){this._queueBlock(Ee);return}Ee.gc()}}_clearInflightUpgrade(F){he(this._upgrade.inflight,F)!==!1&&this._upgrade.gc()}_clearInflightSeeks(F){for(const ne of this._seeks)he(ne.inflight,F)!==!1&&ne.gc()}_clearInflightReorgs(F){for(const ne of this._reorgs)he(ne.inflight,F)}_clearOldReorgs(F){for(let ne=0;ne<this._reorgs.length;ne++)this._reorgs[ne].fork>=F||(ne===this._reorgs.length-1?this._reorgs.pop():this._reorgs[ne]=this._reorgs.pop(),ne--)}async _updateNonPrimary(F){for(;++this._updatesPending===1;){let ne=Math.min(w,this._ranges.length);for(let ye=0;ye<ne;ye++){const me=this._ranges[ye];G(this.core,me),me.end!==-1&&me.start>=me.end&&(this._resolveRangeRequest(me,ye--),ne>this._ranges.length&&ne--,this._ranges.length===w&&(F=!0))}for(let ye=0;ye<this._seeks.length;ye++){const me=this._seeks[ye];let Ee=null,qe=null;try{qe=await me.seeker.update()}catch(Oe){Ee=Oe}!qe&&!Ee||(ye<this._seeks.length-1?this._seeks[ye]=this._seeks.pop():this._seeks.pop(),ye--,Ee?me.reject(Ee):me.resolve(qe))}if(--this._updatesPending===0)break;this._updatesPending=0}(this._inflight.idle||F)&&this.updateAll()}_maybeResolveIfAvailableRanges(){if(!(this._ifAvailable>0||!this._inflight.idle||!this._ranges.length)){for(let F=0;F<this.peers.length;F++)if(this.peers[F].dataProcessing>0)return;for(let F=0;F<this._ranges.length;F++){const ne=this._ranges[F];ne.ifAvailable&&this._resolveRangeRequest(ne,F--)}}}_clearRequest(F,ne){ne.block!==null&&(this._clearInflightBlock(this._blocks,ne),this._unmarkInflight(ne.block.index)),ne.hash!==null&&this._clearInflightBlock(this._hashes,ne),ne.upgrade!==null&&this._upgrade!==null&&this._clearInflightUpgrade(ne),this._seeks.length>0&&this._clearInflightSeeks(ne),this._reorgs.length>0&&this._clearInflightReorgs(ne)}_onnodata(F,ne){this._clearRequest(F,ne),this.updateAll()}_openSkipBitfield(){const F=this.core.openSkipBitfield();for(const ne of this._inflight)ne.block&&F.set(ne.block.index,!0)}_markProcessing(F){const ne=this._blocks.get(F);if(ne){ne.processing=!0;return}const ye=this._hashes.get(F);ye&&(ye.processing=!0)}_markProcessed(F){const ne=this._blocks.get(F);if(ne)return ne.processed();const ye=this._hashes.get(F);ye&&ye.processed()}_markInflight(F){this.core.skipBitfield!==null&&this.core.skipBitfield.set(F,!0);for(const ne of this.peers)ne._markInflight(F)}_unmarkInflight(F){this.core.skipBitfield!==null&&this.core.skipBitfield.set(F,this.core.bitfield.get(F));for(const ne of this.peers)ne._resetMissingBlock(F)}_ondata(F,ne,ye){ne.elapsed=Date.now()-ne.timestamp,ye.block!==null&&(this._resolveBlockRequest(this._blocks,ye.block.index,ye.block.value,ne),this._ondownload(ye.block.index,ye.block.value.byteLength,F,ne)),ye.hash!==null&&(ye.hash.index&1)===0&&this._resolveBlockRequest(this._hashes,ye.hash.index/2,null,ne),this._upgrade!==null&&this._resolveUpgradeRequest(ne),this._seeks.length>0&&this._clearInflightSeeks(ne),this._reorgs.length>0&&this._clearInflightReorgs(ne),this._manifestPeer===F&&this.core.header.manifest!==null&&(this._manifestPeer=null),(this._seeks.length>0||this._ranges.length>0)&&this._updateNonPrimary(this._seeks.length>0),this.updatePeer(F)}_onwant(F,ne,ye){if(!F.isActive())return;const me=Math.min(this.core.state.length,this.core.header.hints.contiguousLength);if(ne+ye<me||this.core.state.length===me){F.wireRange.send({drop:!1,start:0,length:me}),ee(F.stats.wireRange,this.stats.wireRange);return}ye=Math.min(ye,this.core.state.length-ne),F.protomux.cork();for(const Ee of this.core.bitfield.want(ne,ye))F.wireBitfield.send(Ee),ee(F.stats.wireBitfield,this.stats.wireBitfield);F.protomux.uncork()}async _onreorgdata(F,ne,ye){const me=ye.upgrade&&await this.core.verifyReorg(ye),Ee=this._addReorg(ye.fork,F);if(Ee===null){this.updateAll();return}he(Ee.inflight,ne),Ee.batch?await Ee.batch.update(ye):ye.upgrade&&(Ee.batch=me,this._clearOldReorgs(Ee.fork)),Ee.batch&&Ee.batch.finished&&this._addUpgradeMaybe()!==null&&await this._applyReorg(Ee),this.updateAll()}async _applyReorg(F){const ne=this._upgrade;this._reorgs=[],this._applyingReorg=this.core.reorg(F.batch,null);try{await this._applyingReorg}catch(ye){this._upgrade=null,ne.reject(ye)}this._applyingReorg=null,this._upgrade!==null&&this._resolveUpgradeRequest(null);for(const ye of this.peers)this._updateFork(ye);for(const ye of this._ranges)ye.start=ye.userStart,ye.end=ye.userEnd;this.updateAll()}_maybeUpdate(){return this._upgrade!==null&&this._upgrade.inflight.length===0}_maybeRequestManifest(){return this.core.header.manifest===null&&this._manifestPeer===null}_updateFork(F){if(this._applyingReorg!==null||this.allowFork===!1||F.remoteFork<=this.core.state.fork)return!1;const ne=this._addReorg(F.remoteFork,F);return ne!==null&&ne.batch===null&&ne.inflight.length===0?F._requestForkProof(ne):!1}_updateHotswap(F){const ne=F.getMaxHotswapInflight();if(!(!F.isActive()||F.inflight>=ne)){for(const ye of this.hotswaps.pick(F))if(F._requestBlock(ye)!==!1&&(F.stats.hotswaps++,F.replicator.stats.hotswaps++,F.inflight>=ne))break}}_updatePeer(F){if(!F.isActive()||F.inflight>=F.getMaxInflight())return!1;this._maybeRequestManifest()===!0&&F.remoteLength===0&&F.remoteHasManifest===!0&&(this._manifestPeer=F,F._requestManifest());for(const ye of this._seeks)if(!(ye.inflight.length>0)&&F._requestSeek(ye)===!0)return!0;const ne=new p(this._queued);for(const ye of ne)if(ye.queued===!1||F._requestBlock(ye)===!0)return ye.queued=!1,ne.dequeue(),!0;return!1}_updatePeerNonPrimary(F){if(!F.isActive()||F.inflight>=F.getMaxInflight())return!1;const ne=new p(this._ranges);let ye=0;for(const me of ne){if(F._requestRange(me)===!0)return!0;if(++ye>=w)break}for(let me=this._reorgs.length-1;me>=0;me--){const Ee=this._reorgs[me];if(Ee.batch!==null&&Ee.inflight.length===0&&F._requestForkRange(Ee)===!0)return!0}return this._maybeUpdate()===!0&&F._requestUpgrade(this._upgrade)===!0}updatePeer(F){if(this._applyingReorg===null){for(;this._updatePeer(F)===!0;);for(;this._updatePeerNonPrimary(F)===!0;);this.peers.length>1&&this._blocks.isEmpty()===!1&&this._updateHotswap(F),this._checkUpgradeIfAvailable(),this._maybeResolveIfAvailableRanges()}}updateAll(){if(this._applyingReorg!==null)return;const F=new p(this.peers);for(const ne of F)this._updatePeer(ne)===!0&&F.requeue();if(this._maybeUpdate()===!1&&this._ranges.length===0&&this._reorgs.length===0){this._checkUpgradeIfAvailable();return}for(const ne of F.restart())this._updatePeerNonPrimary(ne)===!0&&F.requeue();this._checkUpgradeIfAvailable(),this._maybeResolveIfAvailableRanges()}onpeerdestroy(){--this._active===0&&this.core.checkIfIdle()}attached(F){return this._attached.has(F)}attachTo(F){if(this.core.closed)return;const ne=this._makePeer.bind(this,F);this._attached.add(F),F.pair({protocol:"hypercore/alpha",id:this.core.discoveryKey},ne),F.stream.setMaxListeners(0),F.stream.on("close",this._onstreamclose),this._ifAvailable++,this._active++,F.stream.opened.then(ye=>{this._ifAvailable--,this._active--,ye&&!this.destroyed&&ne(),this._checkUpgradeIfAvailable(),this.core.checkIfIdle()})}detachFrom(F){this._attached.delete(F)&&(F.stream.removeListener("close",this._onstreamclose),F.unpair({protocol:"hypercore/alpha",id:this.core.discoveryKey}))}idle(){return this.peers.length===0&&this._active===0}close(){const F=[];for(const ne of this.peers)F.push(ne.channel.fullyClosed());return this.destroy(),Promise.all(F)}destroy(){if(!this.destroyed){for(this.destroyed=!0,this._downloadingTimer&&(clearTimeout(this._downloadingTimer),this._downloadingTimer=null);this.peers.length;){const F=this.peers[this.peers.length-1];this.detachFrom(F.protomux),F.channel.close()}for(const F of this._attached)this.detachFrom(F)}}_makePeer(F){const ne=this;if(F.opened({protocol:"hypercore/alpha",id:this.core.discoveryKey}))return qe();const ye=F.createChannel({userData:null,protocol:"hypercore/alpha",aliases:["hypercore"],id:this.core.discoveryKey,handshake:m.wire.handshake,messages:[{encoding:m.wire.sync,onmessage:_e},{encoding:m.wire.request,onmessage:ce},{encoding:m.wire.cancel,onmessage:J},{encoding:m.wire.data,onmessage:d},{encoding:m.wire.noData,onmessage:k},{encoding:m.wire.want,onmessage:X},{encoding:m.wire.unwant,onmessage:ie},{encoding:m.wire.bitfield,onmessage:I},{encoding:m.wire.range,onmessage:L},{encoding:m.wire.extension,onmessage:V}],onopen:S,onclose:N,ondrain:H,ondestroy:D});if(ye===null)return qe();const me=new O(ne,F,ye,this.inflightRange),Ee=F.stream;return me.channel.open({seeks:!0,capability:E.replicate(Ee.isInitiator,this.core.key,Ee.handshakeHash)}),!0;function qe(){return!1}}_onpeerupdate(F,ne){const ye=F?"peer-add":"peer-remove",me=this.core.monitors;for(let Ee=me.length-1;Ee>=0;Ee--)if(me[Ee].emit(ye,ne),F)for(const qe of me[Ee].extensions.values())ne.extensions.set(qe.name,qe)}_ondownload(F,ne,ye,me){const Ee=this.core.monitors;for(let qe=Ee.length-1;qe>=0;qe--){const Oe=Ee[qe];Oe.emit("download",F,ne-Oe.padding,ye,me)}}_onupload(F,ne,ye){const me=this.core.monitors;for(let Ee=me.length-1;Ee>=0;Ee--){const qe=me[Ee];qe.emit("upload",F,ne-qe.padding,ye)}}_oninvalid(F,ne,ye,me){const Ee=this.core.monitors;for(let qe=0;qe<Ee.length;qe++)Ee[qe].emit("verification-error",F,ne,ye,me)}};function P(we,F){return F.block!==null&&(we.block===null||we.block.index!==F.block.index)||F.hash!==null&&(we.hash===null||we.hash.index!==F.hash.index)||F.seek!==null&&(we.seek===null||we.seek.bytes!==F.seek.bytes)||F.upgrade!==null&&we.upgrade===null?!1:we.fork===F.fork}function Z(we){return we.hotswap===null?!1:(we.hotswap.ref.remove(we),!0)}function he(we,F){const ne=we.indexOf(F);return ne===-1?!1:(ne<we.length-1?we[ne]=we.pop():we.pop(),!0)}function se(we,F){return F===-1?-1:F<we?0:F-we}function G(we,F){if(F.blocks===null){const ne=we.bitfield.firstUnset(F.start);if(F.end===-1)F.start=ne===-1?we.state.length:ne;else if(ne===-1||ne>=F.end)F.start=F.end;else{F.start=ne;const ye=we.bitfield.lastUnset(F.end-1);ye===-1||ne>=ye+1?F.end=F.start:F.end=ye+1}}else{for(;F.start<F.end&&we.bitfield.get(F.blocks[F.start]);)F.start++;for(;F.start<F.end&&we.bitfield.get(F.blocks[F.end-1]);)F.end--}}function re(we){we.context&&we.context.detach(we,s())}function W(we){we.timeout!==null&&(clearTimeout(we.timeout),we.timeout=null)}function $(we){return we.name==="HypercoreError"}function S(we,F){return F.userData.onopen(we)}function N(we,F){return F.userData.onclose(we)}function D(we){we.userData.replicator.onpeerdestroy()}function H(we){return we.userData.ondrain()}function _e(we,F){return fe(F.userData.stats.wireSync,F.userData.replicator.stats.wireSync),F.userData.onsync(we)}function ce(we,F){return fe(F.userData.stats.wireRequest,F.userData.replicator.stats.wireRequest),F.userData.onrequest(we)}function J(we,F){return fe(F.userData.stats.wireCancel,F.userData.replicator.stats.wireCancel),F.userData.oncancel(we)}function d(we,F){return fe(F.userData.stats.wireData,F.userData.replicator.stats.wireData),F.userData.ondata(we)}function k(we,F){return F.userData.onnodata(we)}function X(we,F){return fe(F.userData.stats.wireWant,F.userData.replicator.stats.wireWant),F.userData.onwant(we)}function ie(we,F){return F.userData.onunwant(we)}function I(we,F){return fe(F.userData.stats.wireBitfield,F.userData.replicator.stats.wireBitfield),F.userData.onbitfield(we)}function L(we,F){return fe(F.userData.stats.wireRange,F.userData.replicator.stats.wireRange),F.userData.onrange(we)}function V(we,F){return fe(F.userData.stats.wireExtension,F.userData.replicator.stats.wireExtension),F.userData.onextension(we)}function te(we,F,ne){we.setDownloadingNow(F,ne)}function de(we){return we!==null&&we.block!==null}function C(we){return we!==null&&we.upgrade!==null}function ee(we,F){we.tx++,F.tx++}function fe(we,F){we.rx++,F.rx++}function ve(){}return zu}var Hu,Ew;function LS(){if(Ew)return Hu;Ew=1;const n=_t(),a=Ue(),p=Xt(),l=Of(),g=Yv(),{MerkleTree:y,ReorgBatch:h}=nr(),o=vS(),c=Gf(),s=Wv(),{BAD_ARGUMENT:u,STORAGE_EMPTY:f,STORAGE_CONFLICT:m,INVALID_SIGNATURE:E,INVALID_CHECKSUM:b}=Lt(),_=Zv(),B=kS(),M=SS(),z=xS(),j=RS();Hu=class{constructor(T,Q={}){this.db=T,this.storage=null,this.replicator=new j(this,Q),this.sessionStates=[],this.monitors=[],this.activeSessions=0,this.gc=0,this.id=Q.key?l.encode(Q.key):null,this.key=Q.key||null,this.discoveryKey=Q.discoveryKey||Q.key&&n.discoveryKey(Q.key)||null,this.manifest=null,this.opening=null,this.closing=null,this.exclusive=null,this.preupdate=null,this.header=null,this.compat=!1,this.bitfield=null,this.verifier=null,this.truncating=0,this.updating=!1,this.skipBitfield=null,this.globalCache=Q.globalCache||null,this.autoClose=Q.autoClose!==!1,this.onidle=A,this.state=null,this.opened=!1,this.destroyed=!1,this.closed=!1,this._manifestFlushed=!1,this._bitfield=null,this._verifies=null,this._verifiesFlushed=null,this._legacy=!!Q.legacy,this.opening=this._open(Q),this.opening.catch(A)}ready(){return this.opening}addMonitor(T){T._monitorIndex>=0||(T._monitorIndex=this.monitors.push(T)-1)}removeMonitor(T){if(T._monitorIndex<0)return;const Q=this.monitors.pop();Q!==T&&(this.monitors[Q._monitorIndex=T._monitorIndex]=Q),T._monitorIndex=-1}emitManifest(){for(let T=this.monitors.length-1;T>=0;T--)this.monitors[T].emit("manifest")}createUserDataStream(T,Q=this.state){return Q.storage.createUserDataStream(T)}allSessions(){const T=[];for(const Q of this.sessionStates)Q.sessions.length&&T.push(...Q.sessions);return T}hasSession(){return this.activeSessions!==0}checkIfIdle(){!this.opened||this.destroyed===!0||this.hasSession()===!0||this.replicator.idle()!==!1&&(this.state===null||this.state.mutex.idle()===!1||this.onidle())}async lockExclusive(){this.exclusive===null&&(this.exclusive=new g),await this.exclusive.lock()}unlockExclusive(){this.exclusive!==null&&this.exclusive.unlock()}async _open(T){try{await this._tryOpen(T)}catch(Q){throw this.onidle(),Q}this.opened=!0}async _tryOpen(T){T.preopen&&await T.preopen;let Q=await this.db.resume(this.discoveryKey),le=T.overwrite===!0;const Y=T.force===!0,oe=T.createIfMissing!==!1,ue=!!T.legacy;let O=T.compat===!0||T.compat!==!1&&!T.manifest,P=Q?R(await q(Q)):null;if(Y&&T.key&&P&&!a.equals(P.key,T.key)&&(le=!0),!P&&T.discoveryKey&&!(T.key||T.manifest))throw f("No Hypercore is stored here");if(!P||le){if(!oe)throw f("No Hypercore is stored here");if(O&&T.key&&T.keyPair&&!a.equals(T.key,T.keyPair.publicKey))throw u("Key must match publicKey when in compat mode");const W=T.keyPair||(T.key?null:n.keyPair()),S=!T.manifest&&(!!T.compat||!T.key||!!(W&&a.equals(T.key,W.publicKey)))?_.defaultSignerManifest(T.key||W.publicKey):_.createManifest(T.manifest);P={key:T.key||(O?S.signers[0].publicKey:_.manifestHash(S)),manifest:S,keyPair:W?{publicKey:W.publicKey,secretKey:W.secretKey||null}:null,frozen:!1,tree:{fork:0,length:0,rootHash:null,signature:null},hints:{reorgs:[],contiguousLength:0}};const N=T.discoveryKey||n.discoveryKey(P.key);Q=await this.db.create({key:P.key,manifest:S,keyPair:W,frozen:!1,discoveryKey:N,userData:T.userData||[],alias:T.alias||null})}if(P.key=p(P.key),P.tree&&(P.tree.rootHash=p(P.tree.rootHash),P.tree.signature=p(P.tree.signature)),P.keyPair&&(P.keyPair.publicKey=p(P.keyPair.publicKey),P.keyPair.secretKey=p(P.keyPair.secretKey)),P.keyPair&&(P.keyPair.publicKey=p(P.keyPair.publicKey),P.keyPair.secretKey=p(P.keyPair.secretKey)),T.manifest){if(!T.key&&!_.isValidManifest(P.key,_.createManifest(T.manifest)))throw m("Manifest does not hash to provided key");P.manifest||(P.manifest=T.manifest)}if(T.key&&!a.equals(P.key,T.key))throw m("Another Hypercore is stored here");O&&P.manifest&&!_.isCompat(P.key,P.manifest)?O=!1:!O&&P.manifest&&_.isCompat(P.key,P.manifest)&&(O=!0);const Z=P.manifest?P.manifest.prologue:null,he=await c.open(Q,P.tree.length),se={fork:P.tree.fork,length:P.tree.length,signature:P.tree.signature,roots:P.tree.length?await y.getRootsFromStorage(Q,P.tree.length):[],prologue:Z};if(le){const W=Q.write();W.deleteTreeNodeRange(0,-1),W.deleteBlockRange(0,-1),he.clear(W),await W.flush()}const G=he.findFirst(!1,P.hints.contiguousLength);if(P.hints.contiguousLength!==G){P.hints.contiguousLength=G;const W=Q.write();W.setHints({contiguousLength:G}),await W.flush()}P.manifest&&(P.manifest=_.createManifest(P.manifest));const re=P.manifest?new _(P.key,P.manifest,{crypto:n,legacy:ue}):null;this.storage=Q,this.header=P,this.compat=O,this.bitfield=he,this.verifier=re,this.state=new z(this,null,Q,se,null),this.key===null&&(this.key=this.header.key),this.discoveryKey===null&&(this.discoveryKey=n.discoveryKey(this.key)),this.id===null&&(this.id=l.encode(this.key)),this.manifest===null&&(this.manifest=this.header.manifest),this._manifestFlushed=!!P.manifest}async audit(T){await this.state.mutex.lock();try{return await B(this,T)}finally{this.state._unlock()}}async setManifest(T){await this.state.mutex.lock();try{if(T&&this.header.manifest===null){if(!_.isValidManifest(this.header.key,T))throw b("Manifest hash does not match");const Q=this.state.createWriteBatch();this._setManifest(Q,_.createManifest(T),null),await this.state.flush()}}finally{this.state._unlock()}}_setManifest(T,Q,le){if(!Q&&a.equals(le.publicKey,this.header.key)&&(Q=_.defaultSignerManifest(this.header.key)),!Q)return;const Y=new _(this.header.key,Q,{legacy:this._legacy});Y.prologue&&(this.state.prologue=Object.assign({},Y.prologue)),this.manifest=this.header.manifest=Q,T.setAuth({key:this.header.key,discoveryKey:this.discoveryKey,manifest:Q,keyPair:this.header.keyPair}),this.compat=Y.compat,this.verifier=Y,this._manifestFlushed=!1,this.replicator.onupgrade(),this.emitManifest()}async copyPrologue(T){await this.state.mutex.lock();try{await T.mutex.lock()}catch(Q){throw this.state.mutex.unlock(),Q}try{await M(T,this)}finally{T.mutex.unlock(),this.state.mutex.unlock(),this.checkIfIdle()}}flushed(){return this.state.flushed()}async _validateCommit(T,Q){if(this.state.length>T.length)return!1;if(this.state.length>Q)for(const le of this.state.roots){const Y=await y.get(T,le.index);if(Y.size!==le.size||!a.equals(Y.hash,le.hash))return!1}return this.verifier!==null}_verifyBatchUpgrade(T,Q){if(!this.header.manifest&&(Q||(Q=_.defaultSignerManifest(this.header.key)),!Q||!(_.isValidManifest(this.header.key,Q)||_.isCompat(this.header.key,Q))))throw E("Proof contains an invalid manifest");if(!(this.verifier||new _(this.header.key,_.createManifest(Q),{legacy:this._legacy})).verify(T,T.signature))throw E("Proof contains an invalid signature");return Q}async _verifyExclusive({batch:T,bitfield:Q,value:le,manifest:Y}){return Y=this._verifyBatchUpgrade(T,Y),!T.commitable()||(this.preupdate!==null&&await this.preupdate(T,this.header.key),!await this.state._verifyBlock(T,Q,le,this.header.manifest?null:Y))?!1:(!T.upgraded&&Q&&this.replicator.onhave(Q.start,Q.length,Q.drop),!0)}async _verifyShared(){if(!this._verifies.length)return!1;await this.state.mutex.lock();const T=this.state.createWriteBatch(),Q=this._verifies;this._verifies=null,this._verified=null;try{for(const{batch:oe,bitfield:ue,value:O}of Q)oe.commitable()&&ue&&T.putBlock(ue.start,O);const le=new o;for(let oe=0;oe<Q.length;oe++){const{batch:ue,bitfield:O,manifest:P}=Q[oe];if(!ue.commitable()){Q[oe]=null;continue}if(O&&le.setRange(O.start,O.start+1,!0),P&&this.header.manifest===null){if(!_.isValidManifest(this.header.key,P))throw b("Manifest hash does not match");this._setManifest(T,P,null)}ue.commitable()&&ue.commit(T)}const Y=le.flush(T,this.bitfield);await this.state.flush();for(const{start:oe,end:ue,value:O}of Y)this._setBitfieldRanges(oe,ue,O);for(let oe=0;oe<Q.length;oe++){const ue=Q[oe]&&Q[oe].bitfield;ue&&(this.updateContiguousLength(ue),this.replicator.onhave(ue.start,ue.length,ue.drop))}}finally{this.state._clearActiveBatch(),this.state.mutex.unlock()}return Q[0]!==null}async checkConflict(T,Q){if(this.state.length<T.upgrade.length||T.fork!==this.state.fork||!this.header.manifest)return!1;const le=y.verifyFullyRemote(this.state,T);try{this._verifyBatchUpgrade(le,T.manifest)}catch{return!0}const Y=await y.getRootsFromStorage(this.storage,T.upgrade.length),oe=n.tree(T.upgrade.nodes),ue=n.tree(Y);try{const P=this.state.storage.read(),Z=y.proof(this.state,P,{block:null,hash:null,seek:null,upgrade:{start:0,length:T.upgrade.length}});P.tryFlush();const he=await Z,se=y.verifyFullyRemote(this.state,await he.settle());this._verifyBatchUpgrade(se,this.header.manifest)}catch{return!0}if(a.equals(ue,oe))return!1;await this.state.mutex.lock();try{const P=this.state.createWriteBatch();this.header.frozen=!0,P.setAuth({key:this.header.key,discoveryKey:this.discoveryKey,manifest:this.header.manifest,keyPair:this.header.keyPair,frozen:!0}),await this.state.flush()}finally{this.state.mutex.unlock()}const O=a.toString(this.discoveryKey,"hex");return console.log("[hypercore] conflict detected in "+O+" (writable="+!!this.header.keyPair+",quorum="+this.header.manifest.quorum+")"),await this._onconflict(T),!0}async verifyReorg(T){const Q=new h(this.state);await y.reorg(this.state,T,Q);const le=this._verifyBatchUpgrade(Q,T.manifest);if(le&&!this.header.manifest){await this.state.mutex.lock();try{if(le&&this.header.manifest===null){const Y=this.state.createWriteBatch();this._setManifest(Y,_.createManifest(le),null),await this.state.flush()}}finally{this.state._unlock()}}return Q}async verify(T,Q){if(T.fork!==this.state.fork)return!1;const le=await y.verify(this.state,T);if(!le.commitable())return!1;const Y=T.block&&T.block.value||null,oe={batch:le,bitfield:Y&&{drop:!1,start:T.block.index,length:1},value:Y,manifest:T.manifest,from:Q};if(le.upgraded)return this._verifyExclusive(oe);if(this._verifies!==null){const ue=this._verifies,O=ue.push(oe);return await this._verified,ue[O]!==null}return this._verifies=[oe],this._verified=this._verifyShared(),this._verified}async reorg(T){if(!T.commitable())return!1;this.truncating++;try{await this.state.reorg(T)}finally{this.truncating--}return!0}openSkipBitfield(){if(this.skipBitfield!==null)return this.skipBitfield;this.skipBitfield=new s;const T=this.bitfield.toBuffer(this.state.length),Q=new Uint32Array(T.buffer,T.byteOffset,T.byteLength/4);return this.skipBitfield.insert(0,Q),this.skipBitfield}_setBitfieldRanges(T,Q,le){this.bitfield.setRange(T,Q,le),this.skipBitfield!==null&&this.skipBitfield.setRange(T,Q,le)}close(){return this.closing||(this.closing=this._close()),this.closing}updateContiguousLength(T){const Q=v(this.header.hints.contiguousLength,T,this.bitfield);Q.length!==-1&&Q.length!==this.header.hints.contiguousLength&&(this.header.hints.contiguousLength=Q.length)}onappend(T,Q){if(this.header.tree=T,!Q){this.replicator.onupgrade();return}this.replicator.cork();const{start:le,length:Y,drop:oe}=Q;this._setBitfieldRanges(le,le+Y,!0),this.updateContiguousLength({start:le,length:Y,drop:!1}),this.replicator.onupgrade(),this.replicator.onhave(le,Y,oe),this.replicator.uncork()}ontruncate(T,{start:Q,length:le}){T&&(this.header.tree=T),this.replicator.cork(),this.replicator.ontruncate(Q,le),this.replicator.onhave(Q,le,!0),this.replicator.onupgrade(),this.replicator.uncork();for(const Y of this.sessionStates)Q<Y.snapshotCompatLength&&(Y.snapshotCompatLength=Q);this._setBitfieldRanges(Q,Q+le,!1),this.updateContiguousLength({start:Q,length:le,drop:!0})}async _onconflict(T){await this.replicator.onconflict();for(let le=this.monitors.length-1;le>=0;le--)this.monitors[le].emit("conflict",T.upgrade.length,T.fork,T);const Q=new Error("Two conflicting signatures exist for length "+T.upgrade.length);await this.closeAllSessions(Q)}async closeAllSessions(T){const Q=this.allSessions(),le=[];for(const Y of Q)le.push(Y.close({error:T,force:!1}));await Promise.allSettled(le)}async destroy(){if(this.destroyed===!0)return;if(this.destroyed=!0,this.hasSession()===!0)throw new Error("Cannot destroy while sessions are open");const T=this.allSessions();this.replicator&&this.replicator.destroy(),this.state&&await this.state.close();for(const Q of T)Q.close().catch(A)}async _close(){if(this.opened===!1&&await this.opening,this.hasSession()===!0)throw new Error("Cannot close while sessions are open");this.replicator&&await this.replicator.close(),await this.destroy(),this.autoClose&&await this.storage.store.close(),this.closed=!0}};function v(U,T,Q){const le=T.start+T.length;let Y=U;if(T.drop)Y>T.start&&(Y=T.start);else if(Y<=le&&Y>=T.start)for(Y=le;Q.get(Y);)Y++;return Y===U?{length:-1}:Y>U?{length:Y}:{length:Y}}function w(){return{fork:0,length:0,rootHash:null,signature:null}}function R(U){return U?{key:U.key,manifest:U.manifest,external:null,keyPair:U.keyPair,tree:U.head||w(),hints:{reorgs:[],contiguousLength:U.hints?U.hints.contiguousLength:0}}:null}function A(){}async function q(U){const T=U.read(),Q=T.getAuth(),le=T.getHead(),Y=T.getHints();return T.tryFlush(),{...await Q,head:await le,hints:await Y}}return Hu}var Fu,Aw;function TS(){return Aw||(Aw=1,Fu=class $s{constructor(a={}){this.key=a.key,this.discoveryKey=a.discoveryKey,this.length=a.length||0,this.contiguousLength=a.contiguousLength||0,this.byteLength=a.byteLength||0,this.fork=a.fork||0,this.padding=a.padding||0,this.storage=a.storage||null}static async from(a,p={}){return new $s({key:a.key,discoveryKey:a.discoveryKey,length:a.length,contiguousLength:a.contiguousLength,byteLength:a.byteLength,fork:a.fork,padding:a.padding,storage:p.storage?await this.storage(a):null})}static async storage(a){const{oplog:p,tree:l,blocks:g,bitfield:y}=a.core;try{return{oplog:await $s.bytesUsed(p.storage),tree:await $s.bytesUsed(l.storage),blocks:await $s.bytesUsed(g.storage),bitfield:await $s.bytesUsed(y.storage)}}catch{return null}}static bytesUsed(a){return new Promise((p,l)=>{a.stat((g,y)=>{g?p(0):typeof y.blocks!="number"?l(new Error("cannot determine bytes used")):p(y.blocks*512)})})}}),Fu}var Vu,Rw;function DS(){if(Rw)return Vu;Rw=1,Vu=class{constructor(l,g){this.session=l,this.range=g,this.request=null,this.opened=!1,this.opening=this._open(),this.opening.catch(n)}ready(){return this.opening}async _open(){this.session.opened===!1&&await this.session.opening,this._download(),this.opened=!0}async done(){await this.ready();try{return await this.request.promise}catch(l){if(a(l))return this._download();throw l}}_download(){const l=this.range&&this.range.activeRequests||this.session.activeRequests;return this.request=this.session.core.replicator.addRange(l,this.range),this.request.promise.catch(n),this.request.promise}downloaded(){return this.done()}destroy(){this._destroyBackground().catch(n)}async _destroyBackground(){this.opened===!1&&await this.ready(),this.request.context&&this.request.context.detach(this.request)}};function n(){}function a(p){return p.code==="SESSION_MOVED"}return Vu}var ju,Lw;function Jv(){if(Lw)return ju;Lw=1;const n=sn(),a=et(),p=Ue(),{DEFAULT_ENCRYPTION:l}=tr(),g=p.alloc(n.crypto_stream_NONCEBYTES);return ju=class Un{static PADDING=8;constructor(h,o,c={}){this.key=h,this.compat=c.compat===!0;const s=Un.deriveKeys(h,o,c);this.blockKey=s.block,this.blindingKey=s.blinding}static deriveKeys(h,o,{block:c=!1,compat:s=!1}={}){const u=p.alloc(2*n.crypto_stream_KEYBYTES),f=c?h:u.subarray(0,n.crypto_stream_KEYBYTES),m=u.subarray(n.crypto_stream_KEYBYTES);return c||(s?n.crypto_generichash_batch(f,[h],o):n.crypto_generichash_batch(f,[l,o,h])),n.crypto_generichash(m,f),{blinding:m,block:f}}static blockEncryptionKey(h,o){const c=p.alloc(n.crypto_stream_KEYBYTES);return n.crypto_generichash_batch(c,[l,h,o]),c}static encrypt(h,o,c,s,u){const f=o.subarray(0,Un.PADDING);o=o.subarray(Un.PADDING),a.uint64.encode({start:0,end:8,buffer:f},c),a.uint64.encode({start:0,end:8,buffer:g},h),g.fill(0,8,8+f.byteLength),n.crypto_stream_xor(f,f,g,u),g.set(f,8),n.crypto_stream_xor(o,o,g,s)}static decrypt(h,o,c){const s=o.subarray(0,Un.PADDING);o=o.subarray(Un.PADDING),a.uint64.encode({start:0,end:8,buffer:g},h),g.set(s,8),n.crypto_stream_xor(o,o,g,c)}encrypt(h,o,c,s){return s.compat!==this.compat&&this._reload(s),Un.encrypt(h,o,c,this.blockKey,this.blindingKey)}decrypt(h,o,c){return c.compat!==this.compat&&this._reload(c),Un.decrypt(h,o,this.blockKey)}padding(){return Un.PADDING}_reload(h){const o=p.equals(this.key,this.blockKey),c=Un.deriveKeys(this.key,h.key,{block:o,compat:h.compat});this.blockKey=c.blockKey,this.blindingKey=c.blindingKey}},ju}var lo={},Tw;function BS(){if(Tw)return lo;Tw=1;const{Writable:n,Readable:a}=Sn();class p extends a{constructor(h,o={}){super(),this.core=h,this.start=o.start||0,this.end=typeof o.end=="number"?o.end:-1,this.snapshot=!o.live&&o.snapshot!==!1,this.live=this.end===-1?!!o.live:!1}_open(h){this._openP().then(h,h)}_read(h){this._readP().then(h,h)}async _openP(){this.end===-1?await this.core.update():await this.core.ready(),this.snapshot&&this.end===-1&&(this.end=this.core.length)}async _readP(){const h=this.live?-1:this.end===-1?this.core.length:this.end;if(h>=0&&this.start>=h){this.push(null);return}this.push(await this.core.get(this.start++))}}lo.ReadStream=p;class l extends n{constructor(h){super(),this.core=h}_writev(h,o){this._writevP(h).then(o,o)}async _writevP(h){await this.core.append(h)}}lo.WriteStream=l;class g extends a{constructor(h,o={}){super(),this._core=h,this._index=0,this._range=null,this._byteOffset=o.byteOffset||0,this._byteLength=typeof o.byteLength=="number"?o.byteLength:-1,this._prefetch=typeof o.prefetch=="number"?o.prefetch:32,this._applyOffset=this._byteOffset>0}_open(h){this._openp().then(h,h)}_read(h){this._readp().then(h,h)}async _openp(){this._byteLength===-1&&(await this._core.update(),this._byteLength=Math.max(this._core.byteLength-this._byteOffset,0))}async _readp(){let h=null;if(this._byteLength===0){this.push(null);return}let o=0;if(this._applyOffset){this._applyOffset=!1;const[c,s]=await this._core.seek(this._byteOffset);this._index=c,o=s}this._predownload(this._index+1),h=await this._core.get(this._index++,{valueEncoding:"binary"}),o>0&&(h=h.subarray(o)),h.byteLength>this._byteLength&&(h=h.subarray(0,this._byteLength)),this._byteLength-=h.byteLength,this.push(h),this._byteLength===0&&this.push(null)}_predownload(h){this._range&&this._range.destroy(),this._range=this._core.download({start:h,end:h+this._prefetch,linear:!0})}_destroy(h){this._range&&this._range.destroy(),h(null)}}return lo.ByteStream=g,lo}var Gu,Dw;function Wf(){if(Dw)return Gu;Dw=1;const{EventEmitter:n}=nn,a=Kf(),p=_t(),l=lS(),g=et(),y=Ue(),h=Gv(),o=Pf(),c=ol(),s=jt(),u=Xt(),f=LS(),m=TS(),E=DS(),b=Jv(),_=tr(),{manifestHash:B,createManifest:M}=Zv(),{ReadStream:z,WriteStream:j,ByteStream:v}=BS(),{MerkleTree:w}=nr(),{ASSERTION:R,BAD_ARGUMENT:A,SESSION_CLOSED:q,SESSION_MOVED:U,SESSION_NOT_WRITABLE:T,SNAPSHOT_NOT_AVAILABLE:Q,DECODING_ERROR:le}=Lt(),Y=Symbol.for("nodejs.util.inspect.custom"),oe=15*1024*1024;class ue extends n{constructor(ce,J,d){super(),a(ce)&&!ce.db?(d=ce,ce=null,J=d.key||null):a(J)&&(d=J,J=d.key||null),J&&typeof J=="string"&&(J=c.decode(J)),d||(d={}),ce||(ce=d.storage),this.core=null,this.state=null,this.encryption=null,this.extensions=new Map,this.valueEncoding=null,this.encodeBatch=null,this.activeRequests=[],this.sessions=null,this.ongc=null,this.keyPair=d.keyPair||null,this.readable=!0,this.writable=!1,this.exclusive=!1,this.opened=!1,this.closed=!1,this.weak=!!d.weak,this.snapshotted=!!d.snapshot,this.onwait=d.onwait||null,this.wait=d.wait!==!1,this.timeout=d.timeout||0,this.preload=null,this.closing=null,this.opening=null,this._readonly=d.writable===!1,this._preappend=Z.bind(this),this._snapshot=null,this._findingPeers=0,this._active=d.weak?!!d.active:d.active!==!1,this._sessionIndex=-1,this._stateIndex=-1,this._monitorIndex=-1,this.opening=this._open(ce,J,d),this.opening.catch(s),this.on("newListener",$)}[Y](ce,J){let d="";if(typeof J.indentationLvl=="number")for(;d.length<J.indentationLvl;)d+=" ";let k="";const X=Math.min(this.peers.length,5);for(let ie=0;ie<X;ie++){const I=this.peers[ie];k+=d+`    Peer(
`,k+=d+"      remotePublicKey: "+J.stylize(P(I.remotePublicKey),"string")+`
`,k+=d+"      remoteLength: "+J.stylize(I.remoteLength,"number")+`
`,k+=d+"      remoteFork: "+J.stylize(I.remoteFork,"number")+`
`,k+=d+"      remoteCanUpgrade: "+J.stylize(I.remoteCanUpgrade,"boolean")+`
`,k+=d+`    )
`}return this.peers.length>5&&(k+=d+"  ... and "+(this.peers.length-5)+` more
`),k?k=`[
`+k+d+"  ]":k="[ "+J.stylize(0,"number")+" ]",this.constructor.name+`(
`+d+"  id: "+J.stylize(this.id,"string")+`
`+d+"  key: "+J.stylize(P(this.key),"string")+`
`+d+"  discoveryKey: "+J.stylize(P(this.discoveryKey),"string")+`
`+d+"  opened: "+J.stylize(this.opened,"boolean")+`
`+d+"  closed: "+J.stylize(this.closed,"boolean")+`
`+d+"  snapshotted: "+J.stylize(this.snapshotted,"boolean")+`
`+d+"  writable: "+J.stylize(this.writable,"boolean")+`
`+d+"  length: "+J.stylize(this.length,"number")+`
`+d+"  fork: "+J.stylize(this.fork,"number")+`
`+d+"  sessions: [ "+J.stylize(this.sessions.length,"number")+` ]
`+d+"  activeRequests: [ "+J.stylize(this.activeRequests.length,"number")+` ]
`+d+"  peers: "+k+`
`+d+")"}static MAX_SUGGESTED_BLOCK_SIZE=oe;static DefaultEncryption=b;static key(ce,{compat:J,version:d,namespace:k}={}){return y.isBuffer(ce)&&(ce={version:d,signers:[{publicKey:ce,namespace:k}]}),J?ce.signers[0].publicKey:B(M(ce))}static discoveryKey(ce){return p.discoveryKey(ce)}static blockEncryptionKey(ce,J){return b.blockEncryptionKey(ce,J)}static getProtocolMuxer(ce){return ce.noiseStream.userData}static createCore(ce,J){return new f(ue.defaultStorage(ce),{autoClose:!1,...J})}static createProtocolStream(ce,J={}){let d=o.isProtomux(ce)?ce.stream:O(ce)?ce:J.stream,k=null;if(d?k=d.noiseStream:(k=new h(ce,null,J),d=k.rawStream),!k)throw A("Invalid stream");if(!k.userData){const X=o.from(k);J.keepAlive!==!1&&k.setKeepAlive(5e3),k.userData=X}return J.ondiscoverykey&&k.userData.pair({protocol:"hypercore/alpha"},J.ondiscoverykey),d}static defaultStorage(ce,J={}){if(l.isCoreStorage(ce))return ce;const d=ce;return new l(d,J)}snapshot(ce){return this.session({...ce,snapshot:!0})}session(ce={}){if(this.closing)throw q("Cannot make sessions on a closing core");if(ce.checkout!==void 0&&!ce.name&&!ce.atom)throw R("Checkouts are only supported on atoms or named sessions");const J=ce.wait===!1?!1:this.wait,d=ce.writable===void 0?!this._readonly:ce.writable===!0,k=ce.onwait===void 0?this.onwait:ce.onwait,X=ce.timeout===void 0?this.timeout:ce.timeout,ie=ce.weak===void 0?this.weak:ce.weak,I=ce.class||ue;return new I(null,this.key,{...ce,wait:J,onwait:k,timeout:X,writable:d,weak:ie,parent:this})}async setEncryptionKey(ce,J){this.opened||await this.opening;const d=this._getEncryptionProvider({key:ce,block:!!(J&&J.block)});return this.setEncryption(d,J)}async setEncryption(ce,J){if(this.opened||await this.opening,ce===null){this.encryption=ce;return}if(!D(ce))throw R("Provider does not satisfy HypercoreEncryption interface");this.encryption=ce}setKeyPair(ce){this.keyPair=ce}setActive(ce){const J=!!ce;J===this._active||this.closing||(this._active=J,this.opened&&this.core.replicator.updateActivity(this._active?1:-1))}async _open(ce,J,d){const k=d.preload||d.parent&&d.parent.preload;k&&(this.sessions=[],this.preload=k,d={...d,...await this.preload},this.preload=null);const X=d.parent||null,ie=d.core||X&&X.core,I=d.sessions||X&&X.sessions,L=d.ongc||X&&X.ongc;ie&&(this.core=ie),L&&(this.ongc=L),I&&(this.sessions=I),this.sessions===null&&(this.sessions=[]),this._sessionIndex=this.sessions.push(this)-1,this.core===null&&W(this,ce,J,d),this._monitorIndex===-2&&this.core.addMonitor(this);try{await this._openSession(d)}catch(V){throw this.core.autoClose&&this.core.hasSession()===!1&&await this.core.close(),this.exclusive&&this.core.unlockExclusive(),this.core.removeMonitor(this),this._removeSession(),this.state!==null&&this.state.removeSession(this),this.closed=!0,this.emit("close"),V}this.emit("ready"),this.core.closing&&this.close().catch(s)}_removeSession(){if(this._sessionIndex===-1)return;const ce=this.sessions.pop();ce!==this&&(this.sessions[ce._sessionIndex=this._sessionIndex]=ce),this._sessionIndex=-1,this.ongc!==null&&this.ongc(this)}async _openSession(ce){this.core.opened===!1&&await this.core.ready(),this.keyPair===null&&(this.keyPair=ce.keyPair||this.core.header.keyPair);const J=ce.parent||null;J&&J.encryption&&(this.encryption=J.encryption);const d=N(ce);if(this.encryption||(this.encryption=this._getEncryptionProvider(d)),this.writable=this._isWritable(),ce.valueEncoding&&(this.valueEncoding=g.from(ce.valueEncoding)),ce.encodeBatch&&(this.encodeBatch=ce.encodeBatch),J){J._stateIndex===-1&&await J.ready(),this.keyPair||(this.keyPair=J.keyPair);const I=J.state;if(I){const L=this.snapshotted&&!I.isSnapshot();this.state=L?await I.snapshot():I.ref()}this.snapshotted&&this.core&&!this._snapshot&&this._updateSnapshot()}ce.exclusive&&ce.writable!==!1&&(this.exclusive=!0,await this.core.lockExclusive());const k=J?J.state:this.core.state,X=ce.checkout===void 0?-1:ce.checkout,ie=this.state;if(ce.atom?(this.state=await k.createSession(null,!1,ce.atom),ie&&ie.unref()):ce.name&&(this.state=await k.createSession(ce.name,!!ce.overwrite,null),ie&&ie.unref()),this.state&&X!==-1){if(!ce.name&&!ce.atom)throw R("Checkouts must be named or atomized");if(X>this.state.length)throw R("Invalid checkout "+X+" for "+ce.name+", length is "+this.state.length);if(this.state.prologue&&X<this.state.prologue.length)throw R("Invalid checkout "+X+" for "+ce.name+", prologue length is "+this.state.prologue.length);X<this.state.length&&await this.state.truncate(X,this.fork)}if(this.state===null&&(this.state=this.core.state.ref()),this.writable=this._isWritable(),this.snapshotted&&this.core&&this._updateSnapshot(),this.state.addSession(this),this.core=this.state.core,ce.userData){const I=this.state.storage.write();for(const[L,V]of Object.entries(ce.userData))I.putUserData(L,V);await I.flush()}ce.manifest&&!this.core.header.manifest&&await this.core.setManifest(M(ce.manifest)),this.core.replicator.updateActivity(this._active?1:0),this.opened=!0}get replicator(){return this.core===null?null:this.core.replicator}_getSnapshot(){return{length:this.state.length,byteLength:this.state.byteLength,fork:this.state.fork}}_updateSnapshot(){const ce=this._snapshot,J=this._snapshot=this._getSnapshot();return ce?ce.length!==J.length||ce.fork!==J.fork:!0}_isWritable(){return this._readonly?!1:this.state&&!this.state.isDefault()?!0:!!(this.keyPair&&this.keyPair.secretKey)}close({error:ce}={}){return this.closing?this.closing:(this.closing=this._close(ce||null),this.closing)}async _close(ce){if(this.opened===!1)try{await this.opening}catch(d){if(!this.closed)throw d}if(this.closed===!0)return;this.core.removeMonitor(this),this.state.removeSession(this),this._removeSession(),this.readable=!1,this.writable=!1,this.opened=!1;const J=[];for(const d of this.extensions.values())d.session===this&&J.push(d);for(const d of J)d.destroy();if(this.core.replicator.findingPeers-=this._findingPeers,this.core.replicator.clearRequests(this.activeRequests,ce),this.core.replicator.updateActivity(this._active?-1:0),this._findingPeers=0,this.state.unref(),this.exclusive&&this.core.unlockExclusive(),this.core.hasSession()){this.closed=!0,this.emit("close");return}this.core.autoClose&&await this.core.close(),this.closed=!0,this.emit("close")}async commit(ce,J){return await this.ready(),await ce.ready(),this.state.commit(ce.state,{keyPair:this.keyPair,...J})}replicate(ce,J={}){if(o.isProtomux(ce))return this._attachToMuxer(ce,J);if(O(ce)&&this._isAttached(ce))return ce;const d=ue.createProtocolStream(ce,J),X=d.noiseStream.userData;return this._attachToMuxer(X),d}_isAttached(ce){return ce.userData&&this.core&&this.core.replicator&&this.core.replicator.attached(ce.userData)}_attachToMuxer(ce){return this.opened?this.core.replicator.attachTo(ce):this.opening.then(()=>this.core.replicator.attachTo(ce),ce.destroy.bind(ce)),ce}get id(){return this.core===null?null:this.core.id}get key(){return this.core===null?null:this.core.key}get discoveryKey(){return this.core===null?null:this.core.discoveryKey}get manifest(){return this.core===null?null:this.core.manifest}get length(){return this._snapshot?this._snapshot.length:this.opened===!1?0:this.state.length}get signedLength(){return this.opened===!1?0:this.state.signedLength()}get byteLength(){return this.opened===!1?0:this._snapshot?this._snapshot.byteLength:this.state.byteLength-this.state.length*this.padding}get contiguousLength(){return this.opened===!1?0:Math.min(this.core.state.length,this.core.header.hints.contiguousLength)}get contiguousByteLength(){return 0}get fork(){return this.opened===!1?0:this.state.fork}get padding(){return this.encryption&&this.key&&this.manifest?this.encryption.padding(this.core,this.length):0}get peers(){return this.opened===!1?[]:this.core.replicator.peers}get globalCache(){return this.opened===!1?null:this.core.globalCache}ready(){return this.opening}async setUserData(ce,J){this.opened===!1&&await this.opening,await this.state.setUserData(ce,J)}async getUserData(ce){this.opened===!1&&await this.opening;const J=this.state.storage.read(),d=J.getUserData(ce);return J.tryFlush(),d}transferSession(ce){this.weak===!1&&(this.core.activeSessions--,ce.activeSessions++),this._monitorIndex>=0&&(this.core.removeMonitor(this),ce.addMonitor(this));const J=this.core;this.core=ce,J.replicator.clearRequests(this.activeRequests,U()),this.emit("migrate",this.key)}findingPeers(){this._findingPeers++,this.core!==null&&!this.closing&&this.core.replicator.findingPeers++;let ce=!0;return()=>{this.closing||!ce||(ce=!1,this._findingPeers--,this.core!==null&&--this.core.replicator.findingPeers===0&&this.core.replicator.updateAll())}}async info(ce){return this.opened===!1&&await this.opening,m.from(this,ce)}async update(ce){if(this.opened===!1&&await this.opening,this.closing!==null||this.snapshotted||this.writable&&(!ce||ce.force!==!0))return!1;const J=this._shouldWait(ce,this.core.replicator.findingPeers>0);let d=!1;if(await this.core.replicator.applyPendingReorg()&&(d=!0),!d&&J){const k=ce&&ce.activeRequests||this.activeRequests,X=this.core.replicator.addUpgrade(k);try{d=await X.promise}catch(ie){if(S(ie))return this.update(ce);throw ie}}return!!d}async seek(ce,J){if(this.opened===!1&&await this.opening,!he(ce))throw R("seek is invalid");const d=J&&J.activeRequests||this.activeRequests;if(this.encryption&&!this.core.manifest){const L=this.replicator.addUpgrade(d);try{await L.promise}catch(V){if(S(V))return this.seek(ce,J);throw V}}const k=w.seek(this.state,ce,this.padding),X=await k.update();if(X)return X;if(this.closing!==null)throw q();if(!this._shouldWait(J,this.wait))return null;const ie=this.core.replicator.addSeek(d,k),I=J&&J.timeout!==void 0?J.timeout:this.timeout;I&&ie.context.setTimeout(ie,I);try{return await ie.promise}catch(L){if(S(L))return this.seek(ce,J);throw L}}async has(ce,J=ce+1){if(this.opened===!1&&await this.opening,!he(ce)||!he(J))throw R("has range is invalid");if(this.state.isDefault()){if(J===ce+1)return this.core.bitfield.get(ce);const X=this.core.bitfield.firstUnset(ce);return X===-1||X>=J}if(J===ce+1){const X=this.state.storage.read(),ie=X.getBlock(ce);return X.tryFlush(),await ie!==null}let d=0;const k=this.state.storage.createBlockStream({gte:ce,lt:J});for await(const X of k){if(X===null)return!1;d++}return d===J-ce}async get(ce,J){if(this.opened===!1&&await this.opening,!he(ce))throw R("block index is invalid");if(this.closing!==null)throw q();const d=J&&J.valueEncoding&&g.from(J.valueEncoding)||this.valueEncoding;let X=await this._get(ce,J);return X?J&&J.raw?X:(this.encryption&&(!J||J.decrypt!==!1)&&(X=y.from(X),await this.encryption.decrypt(ce,X,this.core)),this._decode(d,X,ce)):null}async clear(ce,J=ce+1,d){if(this.opened===!1&&await this.opening,this.closing!==null)throw q();if(typeof J=="object"&&(d=J,J=ce+1),!he(ce)||!he(J))throw R("clear range is invalid");const k=d&&d.diff?{blocks:0}:null;return ce>=J||ce>=this.length||await this.state.clear(ce,J,k),k}async purge(){await this._closeAllSessions(null),await this.core.purge()}async _get(ce,J){const d=await re(this.state.storage.read(),ce);if(d!==null)return d;if(this.closing!==null)throw q();if(this._snapshot!==null){G(this,ce);const L=await re(this.core.state.storage.read(),ce);if(G(this,ce),L!==null)return L}if(this.core.bitfield.get(ce)){const L=await re(this.state.storage.read(),ce);if(L!==null)return L}if(!this._shouldWait(J,this.wait))return null;J&&J.onwait&&J.onwait(ce,this),this.onwait&&this.onwait(ce,this);const k=J&&J.activeRequests||this.activeRequests,X=this.core.replicator.addBlock(k,ce);X.snapshot=ce<this.length;const ie=J&&J.timeout!==void 0?J.timeout:this.timeout;ie&&X.context.setTimeout(X,ie);let I=null;try{I=await X.promise}catch(L){if(S(L))return this._get(ce,J);throw L}return this._snapshot!==null&&G(this,ce),se(I)}_shouldWait(ce,J){if(ce){if(ce.wait===!1)return!1;if(ce.wait===!0)return!0}return J}createReadStream(ce){return new z(this,ce)}createWriteStream(ce){return new j(this,ce)}createByteStream(ce){return new v(this,ce)}download(ce){return new E(this,ce)}undownload(ce){ce.destroy(null)}cancel(ce){}async truncate(ce=0,J={}){this.opened===!1&&await this.opening;const{fork:d=this.state.fork+1,keyPair:k=this.keyPair,signature:X=null}=typeof J=="number"?{fork:J}:J,ie=this.state===this.core.state,I=!this._readonly&&!!(X||k&&k.secretKey);if(ie&&I===!1&&(ce>0||d!==this.state.fork))throw T();await this.state.truncate(ce,d,{keyPair:k,signature:X}),this.state===this.core.state&&this.core.replicator.updateAll()}async append(ce,J={}){this.opened===!1&&await this.opening;const d=this.state===this.core.state,k=this.state.name===null?this.keyPair:null,{keyPair:X=k,signature:ie=null,maxLength:I}=J,L=!d||!!ie||!!(X&&X.secretKey)||J.writable===!0;if(this._readonly||L===!1)throw T();ce=Array.isArray(ce)?ce:[ce];const V=this.encryption&&this._preappend,te=this.encodeBatch!==null?this.encodeBatch(ce):new Array(ce.length);if(this.encodeBatch===null)for(let de=0;de<ce.length;de++)te[de]=this._encode(this.valueEncoding,ce[de]);for(const de of te)if(de.byteLength>oe)throw A("Appended block exceeds the maximum suggested block size");return this.state.append(te,{keyPair:X,signature:ie,preappend:V,maxLength:I})}async signable(ce=-1,J=-1){return this.opened===!1&&await this.opening,ce===-1&&(ce=this.length),J===-1&&(J=this.fork),_.treeSignable(this.key,await this.treeHash(ce),ce,J)}async treeHash(ce=-1){this.opened===!1&&await this.opening,ce===-1&&(ce=this.length);const J=await w.getRoots(this.state,ce);return p.tree(J)}async proof(ce){this.opened===!1&&await this.opening;const J=this.state.storage.read(),d=w.proof(this.state,J,ce);return J.tryFlush(),d}async verifyFullyRemote(ce){this.opened===!1&&await this.opening;const J=await w.verifyFullyRemote(this.state,ce);return await this.core._verifyBatchUpgrade(J,ce.manifest),J}registerExtension(ce,J={}){if(this.extensions.has(ce)){const k=this.extensions.get(ce);return k.handlers=J,k.encoding=g.from(J.encoding||g.buffer),k.session=this,k}const d={name:ce,handlers:J,encoding:g.from(J.encoding||g.buffer),session:this,send(k,X){const ie=g.encode(this.encoding,k);X.extension(ce,ie)},broadcast(k){const X=g.encode(this.encoding,k);for(const ie of this.session.peers)ie.extension(ce,X)},destroy(){for(const k of this.session.peers)k.extensions.get(ce)===d&&k.extensions.delete(ce);this.session.extensions.delete(ce)},_onmessage(k,X){const ie=this.encoding.decode(k);this.handlers.onmessage&&this.handlers.onmessage(ie,X)}};this.extensions.set(ce,d),this.core===null?this._monitorIndex=-2:this.core.addMonitor(this);for(const k of this.peers)k.extensions.set(ce,d);return d}_encode(ce,J){const d={start:this.padding,end:this.padding,buffer:null};if(y.isBuffer(J)){if(d.start===0)return J;d.end+=J.byteLength}else if(ce)ce.preencode(d,J);else{if(J=y.from(J),d.start===0)return J;d.end+=J.byteLength}return d.buffer=y.allocUnsafe(d.end),ce?ce.encode(d,J):d.buffer.set(J,d.start),d.buffer}_decode(ce,J,d){this.encryption&&(J=J.subarray(this.encryption.padding(this.core,d)));try{if(ce)return g.decode(ce,J)}catch{throw le()}return J}_getEncryptionProvider(ce){return D(ce)?ce:!ce||!ce.key?null:new b(ce.key,this.key,{block:ce.block,compat:this.core.compat})}}Gu=ue;function O(_e){return typeof _e=="object"&&_e&&typeof _e.pipe=="function"}function P(_e){return _e&&y.toString(_e,"hex")}async function Z(_e){const ce=this.state.length,J=this.state.encryptionFork;for(let d=0;d<_e.length;d++)await this.encryption.encrypt(ce+d,_e[d],J,this.core)}function he(_e){return _e===0||_e>0}function se(_e){return _e!==null&&2*_e.byteLength<_e.buffer.byteLength?u(_e):_e}function G(_e,ce){if(ce>=_e.state.snapshotCompatLength)throw Q()}function re(_e,ce){const J=_e.getBlock(ce);return _e.tryFlush(),J}function W(_e,ce,J,d){ce===null&&(ce=d.storage||null),J===null&&(J=d.key||null),_e.core=new f(ue.defaultStorage(ce),{preopen:d.preopen,eagerUpgrade:!0,notDownloadingLinger:d.notDownloadingLinger,allowFork:d.allowFork!==!1,inflightRange:d.inflightRange,compat:d.compat===!0,force:d.force,createIfMissing:d.createIfMissing,discoveryKey:d.discoveryKey,overwrite:d.overwrite,key:J,keyPair:d.keyPair,legacy:d.legacy,manifest:d.manifest,globalCache:d.globalCache||null})}function $(_e){_e==="append"||_e==="truncate"||this._monitorIndex>=0||this.closing||(this.core===null?this._monitorIndex=-2:this.core.addMonitor(this))}function S(_e){return _e.code==="SESSION_MOVED"}function N(_e){return _e.encryptionKey?{key:_e.encryptionKey,block:!!_e.isBlockKey}:_e.encryption?y.isBuffer(_e.encryption)?{key:_e.encryption}:_e.encryption:null}function D(_e){return _e&&H(_e.padding)&&H(_e.encrypt)&&H(_e.decrypt)}function H(_e){return!!_e&&typeof _e=="function"}return Gu}var Yu,Bw;function NS(){if(Bw)return Yu;Bw=1;const n=et(),a=Hv(),p={preencode(q,U){n.fixed32.preencode(q,U.key),n.uint.preencode(q,U.length)},encode(q,U){n.fixed32.encode(q,U.key),n.uint.encode(q,U.length)},decode(q){return{key:n.fixed32.decode(q),length:n.uint.decode(q)}}},l=n.array(p),g={preencode(q,U){n.fixed64.preencode(q,U.signature),n.uint.preencode(q,U.length)},encode(q,U){n.fixed64.encode(q,U.signature),n.uint.encode(q,U.length)},decode(q){return{signature:n.fixed64.decode(q),length:n.uint.decode(q)}}},y={preencode(q,U){n.fixed32.preencode(q,U.key)},encode(q,U){n.fixed32.encode(q,U.key)},decode(q){return{key:n.fixed32.decode(q),length:-1}}},h=n.array(y),o={preencode(q,U){n.uint.preencode(q,0),n.uint.preencode(q,U.type),U.type===1&&h.preencode(q,U.writers)},encode(q,U){n.uint.encode(q,0),n.uint.encode(q,U.type),U.type===1&&h.encode(q,U.writers)},decode(q){const U=n.uint.decode(q);if(U!==0)throw new Error("Unsupported version: "+U);const Q={version:0,type:n.uint.decode(q),writers:null};return Q.type===1&&(Q.writers=h.decode(q)),Q}},c={preencode(q,U){if(U.version===0)return o.preencode(q,U);n.uint.preencode(q,1),n.uint.preencode(q,U.type),U.type===1&&l.preencode(q,U.writers)},encode(q,U){if(U.version===0)return o.encode(q,U);n.uint.encode(q,1),n.uint.encode(q,U.type),U.type===1&&l.encode(q,U.writers)},decode(q){const U=q.start,T=n.uint.decode(q);if(T>1)throw new Error("Unsupported version: "+T);if(T===0)return q.start=U,o.decode(q);const le={version:1,type:n.uint.decode(q),writers:null};return le.type===1&&(le.writers=l.decode(q)),le}},s={preencode(){throw new Error("version 0 records cannot be encoded")},encode(){throw new Error("version 0 records cannot be encoded")},decode(q){const U=p.decode(q),T=l.decode(q);return{version:0,key:U.key,systemLength:U.length,indexersUpdated:!1,fastForwarding:!1,recoveries:1,migrating:!1,heads:T}}},u={preencode(q,U){n.uint.preencode(q,U.checkpointer),U.checkpoint!==null&&g.preencode(q,U.checkpoint)},encode(q,U){n.uint.encode(q,U.checkpointer),U.checkpoint!==null&&g.encode(q,U.checkpoint)},decode(q){const U=n.uint.decode(q),T=U?null:g.decode(q);return{checkpointer:U,checkpoint:T}}},f=n.array(u),m={preencode(q,U){n.uint.preencode(q,U.signature),n.fixed32.preencode(q,U.namespace),n.fixed32.preencode(q,U.publicKey)},encode(q,U){n.uint.encode(q,U.signature),n.fixed32.encode(q,U.namespace),n.fixed32.encode(q,U.publicKey)},decode(q){return{signature:n.uint.decode(q),namespace:n.fixed32.decode(q),publicKey:n.fixed32.decode(q)}}},E=n.array(m),b={preencode(q,U){n.uint.preencode(q,U.pointer),U.pointer===0&&E.preencode(q,U.indexers)},encode(q,U){n.uint.encode(q,U.pointer),U.pointer===0&&E.encode(q,U.indexers)},decode(q){const U=n.uint.decode(q);return{pointer:U,indexers:U===0?E.decode(q):null}}},_={preencode(q,U){n.uint.preencode(q,U.pointer),U.pointer===0&&n.fixed32.preencode(q,U.key)},encode(q,U){n.uint.encode(q,U.pointer),U.pointer===0&&n.fixed32.encode(q,U.key)},decode(q){const U=n.uint.decode(q);return{pointer:U,key:U===0?n.fixed32.decode(q):null}}},B={preencode(q,U){l.preencode(q,U.heads),n.uint.preencode(q,U.batch),n.buffer.preencode(q,U.value)},encode(q,U){l.encode(q,U.heads),n.uint.encode(q,U.batch),n.buffer.encode(q,U.value)},decode(q,U){return{heads:l.decode(q),batch:n.uint.decode(q),value:n.buffer.decode(q)}}},M={preencode(q,U){n.uint.preencode(q,U.pointer),U.pointer===0&&z.preencode(q,U.data)},encode(q,U){n.uint.encode(q,U.pointer),U.pointer===0&&z.encode(q,U.data)},decode(q){const U=n.uint.decode(q);return{pointer:U,data:U===0?z.decode(q):null}}},z={preencode(q,U){n.uint.preencode(q,0)},encode(q,U){n.uint.encode(q,0)},decode(q){const U=n.uint.decode(q);return{encryptionId:U&1?n.fixed32.decode(q):null,abi:U&2?n.uint.decode(q):0}}},j={preencode(q,U){throw new Error("Encoding not supported")},encode(q,U){throw new Error("Encoding not supported")},decode(q){const U=n.uint.decode(q),T=n.uint.decode(q),Q=(T&1)!==0,le=Q?f.decode(q):null,Y=Q?_.decode(q):null,oe=B.decode(q);return{version:1,maxSupportedVersion:U,digest:Y,checkpoint:le?{system:le[0],encryption:null,user:le.slice(1)}:null,optimistic:(T&2)!==0,node:oe}}},v={preencode(q,U){throw new Error("Encoding not supported")},encode(q,U){throw new Error("Encoding not supported")},decode(q){const T=(n.uint.decode(q)&1)!==0;T&&b.decode(q);const Q=T?f.decode(q):null,le=B.decode(q);return M.decode(q),{version:0,maxSupportedVersion:q.start<q.end?n.uint.decode(q):0,digest:null,checkpoint:Q?{system:Q[0],encryption:null,user:Q.slice(1)}:null,optimistic:null,node:le}}},w=1,R={preencode(q,U){a.UINT.preencode(q,w),a.UINT.preencode(q,U)},encode(q,U){a.UINT.encode(q,w),a.UINT.encode(q,U)},decode(q){return a.UINT.decode(q),a.UINT.decode(q)}};function A(q){return{version:q.version,members:q.members,pendingIndexers:q.pendingIndexers,indexers:q.indexers,heads:q.heads,views:q.views,encryptionLength:0,entropy:null}}return Yu={Wakeup:c,BootRecordV0:s,OplogMessageV0:v,OplogMessageV1:j,LinearizerKey:R,infoLegacyMap:A},Yu}var Wu,Nw;function qS(){if(Nw)return Wu;Nw=1;const{c:n}=If(),a=NS(),p=1;let l=p;const g={preencode(W,$){n.fixed32.preencode(W,$.key),n.uint.preencode(W,$.length)},encode(W,$){n.fixed32.encode(W,$.key),n.uint.encode(W,$.length)},decode(W){const $=n.fixed32.decode(W),S=n.uint.decode(W);return{key:$,length:S}}},y=n.array(g),h={preencode(W,$){n.fixed64.preencode(W,$.signature),n.uint.preencode(W,$.length)},encode(W,$){n.fixed64.encode(W,$.signature),n.uint.encode(W,$.length)},decode(W){const $=n.fixed64.decode(W),S=n.uint.decode(W);return{signature:$,length:S}}},o=a.Wakeup,c=a.BootRecordV0,s={preencode(W,$){n.fixed32.preencode(W,$.key),n.uint.preencode(W,$.systemLength),W.end++,$.recoveries&&n.uint.preencode(W,$.recoveries)},encode(W,$){const S=($.indexersUpdated?1:0)|($.fastForwarding?2:0)|($.recoveries?4:0);n.fixed32.encode(W,$.key),n.uint.encode(W,$.systemLength),n.uint.encode(W,S),$.recoveries&&n.uint.encode(W,$.recoveries)},decode(W,$){$===void 0&&($=n.uint.decode(W));const S=n.fixed32.decode(W),N=n.uint.decode(W),D=n.uint.decode(W);return{version:$,key:S,systemLength:N,indexersUpdated:(D&1)!==0,fastForwarding:(D&2)!==0,recoveries:(D&4)!==0?n.uint.decode(W):0}}},u={preencode(W,$){switch(n.uint.preencode(W,$.version),$.version){case 0:c.preencode(W,$);break;case 1:case 2:case 3:s.preencode(W,$);break;default:throw new Error("Unsupported version")}},encode(W,$){switch(n.uint.encode(W,$.version),$.version){case 0:c.encode(W,$);break;case 1:case 2:case 3:s.encode(W,$);break;default:throw new Error("Unsupported version")}},decode(W){const $=n.uint.decode(W);switch($){case 0:return c.decode(W,$);case 1:case 2:case 3:return s.decode(W,$);default:throw new Error("Unsupported version")}}},f={preencode(W,$){W.end++,$.checkpointer&&n.uint.preencode(W,$.checkpointer),$.checkpoint&&h.preencode(W,$.checkpoint)},encode(W,$){const S=($.checkpointer?1:0)|($.checkpoint?2:0);n.uint.encode(W,S),$.checkpointer&&n.uint.encode(W,$.checkpointer),$.checkpoint&&h.encode(W,$.checkpoint)},decode(W){const $=n.uint.decode(W);return{checkpointer:($&1)!==0?n.uint.decode(W):0,checkpoint:($&2)!==0?h.decode(W):null}}},m=n.array(f),E={preencode(W,$){W.end++,$.system&&f.preencode(W,$.system),$.encryption&&f.preencode(W,$.encryption),$.user&&m.preencode(W,$.user)},encode(W,$){const S=($.system?1:0)|($.encryption?2:0)|($.user?4:0);n.uint.encode(W,S),$.system&&f.encode(W,$.system),$.encryption&&f.encode(W,$.encryption),$.user&&m.encode(W,$.user)},decode(W){const $=n.uint.decode(W);return{system:($&1)!==0?f.decode(W):null,encryption:($&2)!==0?f.decode(W):null,user:($&4)!==0?m.decode(W):null}}},b={preencode(W,$){W.end++,$.pointer&&n.uint.preencode(W,$.pointer),$.key&&n.fixed32.preencode(W,$.key)},encode(W,$){const S=($.pointer?1:0)|($.key?2:0);n.uint.encode(W,S),$.pointer&&n.uint.encode(W,$.pointer),$.key&&n.fixed32.encode(W,$.key)},decode(W){const $=n.uint.decode(W);return{pointer:($&1)!==0?n.uint.decode(W):0,key:($&2)!==0?n.fixed32.decode(W):null}}},_={preencode(W,$){y.preencode(W,$.heads),n.uint.preencode(W,$.batch),n.buffer.preencode(W,$.value)},encode(W,$){y.encode(W,$.heads),n.uint.encode(W,$.batch),n.buffer.encode(W,$.value)},decode(W){const $=y.decode(W),S=n.uint.decode(W),N=n.buffer.decode(W);return{heads:$,batch:S,value:N}}},B=a.OplogMessageV0,M=a.OplogMessageV1,z=n.frame(E),j=n.frame(b),v={preencode(W,$){_.preencode(W,$.node),W.end++,$.checkpoint&&z.preencode(W,$.checkpoint),$.digest&&j.preencode(W,$.digest)},encode(W,$){const S=($.checkpoint?1:0)|($.digest?2:0)|($.optimistic?4:0);_.encode(W,$.node),n.uint.encode(W,S),$.checkpoint&&z.encode(W,$.checkpoint),$.digest&&j.encode(W,$.digest)},decode(W,$){$===void 0&&($=n.uint.decode(W));const S=_.decode(W),N=n.uint.decode(W);return{version:$,node:S,checkpoint:(N&1)!==0?z.decode(W):null,digest:(N&2)!==0?j.decode(W):null,optimistic:(N&4)!==0}}},w={preencode(W,$){switch(n.uint.preencode(W,$.version),$.version){case 0:B.preencode(W,$);break;case 1:M.preencode(W,$);break;case 2:v.preencode(W,$);break;default:throw new Error("Unsupported version")}},encode(W,$){switch(n.uint.encode(W,$.version),$.version){case 0:B.encode(W,$);break;case 1:M.encode(W,$);break;case 2:v.encode(W,$);break;default:throw new Error("Unsupported version")}},decode(W){const $=n.uint.decode(W);switch($){case 0:return B.decode(W,$);case 1:return M.decode(W,$);case 2:return v.decode(W,$);default:throw new Error("Unsupported version")}}},R=n.array(n.fixed32),A={preencode(W,$){n.uint.preencode(W,$.members),R.preencode(W,$.pendingIndexers),y.preencode(W,$.indexers),y.preencode(W,$.heads),y.preencode(W,$.views)},encode(W,$){n.uint.encode(W,$.members),R.encode(W,$.pendingIndexers),y.encode(W,$.indexers),y.encode(W,$.heads),y.encode(W,$.views)},decode(W,$){$===void 0&&($=n.uint.decode(W));const S=n.uint.decode(W),N=R.decode(W),D=y.decode(W),H=y.decode(W),_e=y.decode(W);return{version:$,members:S,pendingIndexers:N,indexers:D,heads:H,views:_e}}},q=R,U={preencode(W,$){n.uint.preencode(W,$.members),q.preencode(W,$.pendingIndexers),y.preencode(W,$.indexers),y.preencode(W,$.heads),y.preencode(W,$.views),n.uint.preencode(W,$.encryptionLength),W.end++,$.entropy&&n.fixed32.preencode(W,$.entropy)},encode(W,$){const S=$.entropy?1:0;n.uint.encode(W,$.members),q.encode(W,$.pendingIndexers),y.encode(W,$.indexers),y.encode(W,$.heads),y.encode(W,$.views),n.uint.encode(W,$.encryptionLength),n.uint.encode(W,S),$.entropy&&n.fixed32.encode(W,$.entropy)},decode(W,$){$===void 0&&($=n.uint.decode(W));const S=n.uint.decode(W),N=q.decode(W),D=y.decode(W),H=y.decode(W),_e=y.decode(W),ce=n.uint.decode(W),J=n.uint.decode(W);return{version:$,members:S,pendingIndexers:N,indexers:D,heads:H,views:_e,encryptionLength:ce,entropy:(J&1)!==0?n.fixed32.decode(W):null}}},T={preencode(W,$){switch(n.uint.preencode(W,$.version),$.version){case 0:case 1:A.preencode(W,$);break;case 2:U.preencode(W,$);break;default:throw new Error("Unsupported version")}},encode(W,$){switch(n.uint.encode(W,$.version),$.version){case 0:case 1:A.encode(W,$);break;case 2:U.encode(W,$);break;default:throw new Error("Unsupported version")}},decode(W){const $=n.uint.decode(W);switch($){case 0:case 1:{const S=A.decode(W,$),N=a.infoLegacyMap;return N(S)}case 2:return U.decode(W,$);default:throw new Error("Unsupported version")}}},Q={preencode(W,$){W.end++,n.uint.preencode(W,$.length)},encode(W,$){const S=($.isIndexer?1:0)|($.isRemoved?2:0);n.uint.encode(W,S),n.uint.encode(W,$.length)},decode(W){const $=n.uint.decode(W);return{isIndexer:($&1)!==0,isRemoved:($&2)!==0,length:n.uint.decode(W)}}},le=a.LinearizerKey,Y={preencode(W,$){n.fixed32.preencode(W,$.key),n.uint.preencode(W,$.length),n.uint.preencode(W,$.batch),n.uint.preencode(W,$.systemLength),W.end++},encode(W,$){const S=$.indexers?1:0;n.fixed32.encode(W,$.key),n.uint.encode(W,$.length),n.uint.encode(W,$.batch),n.uint.encode(W,$.systemLength),n.uint.encode(W,S)},decode(W){const $=n.fixed32.decode(W),S=n.uint.decode(W),N=n.uint.decode(W),D=n.uint.decode(W),H=n.uint.decode(W);return{key:$,length:S,batch:N,systemLength:D,indexers:(H&1)!==0}}},oe={preencode(W,$){n.uint.preencode(W,$.type),n.buffer.preencode(W,$.payload)},encode(W,$){n.uint.encode(W,$.type),n.buffer.encode(W,$.payload)},decode(W){const $=n.uint.decode(W),S=n.buffer.decode(W);return{type:$,payload:S}}},ue={preencode(W,$){n.uint.preencode(W,$.version),W.end++,$.legacyBlocks&&n.uint.preencode(W,$.legacyBlocks),$.namespace&&n.fixed32.preencode(W,$.namespace)},encode(W,$){const S=($.legacyBlocks?1:0)|($.namespace?2:0);n.uint.encode(W,$.version),n.uint.encode(W,S),$.legacyBlocks&&n.uint.encode(W,$.legacyBlocks),$.namespace&&n.fixed32.encode(W,$.namespace)},decode(W){const $=n.uint.decode(W),S=n.uint.decode(W);return{version:$,legacyBlocks:(S&1)!==0?n.uint.decode(W):0,namespace:(S&2)!==0?n.fixed32.decode(W):null}}};function O(W){l=W}function P(W,$,S=p){return l=S,n.encode(se(W),$)}function Z(W,$,S=p){return l=S,n.decode(se(W),$)}function he(W){throw new Error("Enum not found "+W)}function se(W){switch(W){case"@autobase/checkout":return g;case"@autobase/clock":return y;case"@autobase/index-checkpoint":return h;case"@autobase/wakeup":return o;case"@autobase/boot-record-v0":return c;case"@autobase/boot-record-raw":return s;case"@autobase/boot-record":return u;case"@autobase/checkpointer":return f;case"@autobase/checkpoint":return E;case"@autobase/digest":return b;case"@autobase/node":return _;case"@autobase/oplog-message-v0":return B;case"@autobase/oplog-message-v1":return M;case"@autobase/oplog-message-v2":return v;case"@autobase/oplog-message":return w;case"@autobase/info-v1":return A;case"@autobase/info-v2":return U;case"@autobase/info":return T;case"@autobase/member":return Q;case"@autobase/linearizer-key":return le;case"@autobase/linearizer-update":return Y;case"@autobase/encryption-descriptor":return oe;case"@autobase/manifest-data":return ue;default:throw new Error("Encoder not found "+W)}}function G(W,$=p){const S=se(W);return{preencode(N,D){l=$,S.preencode(N,D)},encode(N,D){l=$,S.encode(N,D)},decode(N){return l=$,S.decode(N)}}}return Wu={resolveStruct:G,getStruct:G,getEnum:he,getEncoding:se,encode:P,decode:Z,setVersion:O,version:l},Wu}var Qu,qw;function ni(){if(qw)return Qu;qw=1;const n=qS();return Qu={Wakeup:n.resolveStruct("@autobase/wakeup"),Clock:n.resolveStruct("@autobase/clock"),Checkout:n.resolveStruct("@autobase/checkout"),BootRecord:n.resolveStruct("@autobase/boot-record"),OplogMessage:n.resolveStruct("@autobase/oplog-message"),Checkpoint:n.resolveStruct("@autobase/checkpoint"),Info:n.resolveStruct("@autobase/info"),Member:n.resolveStruct("@autobase/member"),ManifestData:n.resolveStruct("@autobase/manifest-data"),LINEARIZER_PREFIX:1,LinearizerKey:n.resolveStruct("@autobase/linearizer-key"),LinearizerUpdate:n.resolveStruct("@autobase/linearizer-update"),EncryptionDescriptor:n.resolveStruct("@autobase/encryption-descriptor")},Qu}var Xu,Cw;function e0(){if(Cw)return Xu;Cw=1;const n=et(),a=Ue(),p=ni(),l=a.from([p.LINEARIZER_PREFIX]),g=a.from([p.LINEARIZER_PREFIX+1]);return Xu=class{constructor(h){this.core=h,this.tx=null}static clear(h){const o=h.state.storage.write();return o.deleteLocalRange(l,g),o.flush()}static async moveTo(h,o){const c=await h.getUserData("autobase/boot"),s=o.state.storage.write();s.deleteLocalRange(l,g);for await(const u of h.state.storage.createLocalStream({gte:l,lt:g}))s.putLocal(u.key,u.value);s.putUserData("autobase/boot",c),await s.flush()}setBootRecord(h){this.tx===null&&(this.tx=this.core.state.storage.write()),this.tx.putUserData("autobase/boot",n.encode(p.BootRecord,h))}async listUpdates(){const h=[];for await(const o of this.core.state.storage.createLocalStream({gte:l,lt:g})){const c=n.decode(p.LinearizerUpdate,o.value),s=n.decode(p.LinearizerKey,o.key);c.seq=s,h.push(c)}return h}clearUpdates(){this.tx===null&&(this.tx=this.core.state.storage.write()),this.tx.deleteLocalRange(l,g)}deleteUpdate(h){this.tx===null&&(this.tx=this.core.state.storage.write()),this.tx.deleteLocal(n.encode(p.LinearizerKey,h.seq))}insertUpdate(h){this.tx===null&&(this.tx=this.core.state.storage.write()),this.tx.putLocal(n.encode(p.LinearizerKey,h.seq),n.encode(p.LinearizerUpdate,h))}flush(){if(!this.tx)return Promise.resolve();const h=this.tx.flush();return this.tx=null,h}},Xu}var Zu,Mw;function t0(){if(Mw)return Zu;Mw=1;const n=Ue();return Zu=class{constructor(p){this.m=p?new Map([...p.m]):new Map}get size(){return this.m.size}get(p){return n.isBuffer(p)&&(p=n.toString(p,"hex")),this.m.get(p)}set(p,l){return n.isBuffer(p)&&(p=n.toString(p,"hex")),this.m.set(p,l)}delete(p){return n.isBuffer(p)&&(p=n.toString(p,"hex")),this.m.delete(p)}has(p){return n.isBuffer(p)&&(p=n.toString(p,"hex")),this.m.has(p)}*[Symbol.iterator](){for(const[p,l]of this.m)yield[n.from(p,"hex"),l]}*keys(){for(const p of this.m.keys())yield n.from(p,"hex")}values(){return this.m.values()}clear(){return this.m.clear()}},Zu}var $u,Uw;function n0(){if(Uw)return $u;Uw=1;const n=t0();return $u=class{constructor(){this.seen=new n}get size(){return this.seen.size}has(p){return this.seen.has(p)}includes(p,l){return this.seen.has(p)&&this.seen.get(p)>=l}get(p){return this.seen.get(p)||0}set(p,l){return this.seen.set(p,l),l}add(p){for(const[l,g]of p)this.get(l)<g&&this.set(l,g)}[Symbol.iterator](){return this.seen[Symbol.iterator]()}},$u}var Ju,Ow;function CS(){if(Ow)return Ju;Ow=1;const n=t0(),a=n0(),p=0,l=1,g=2;return Ju=class{constructor(h){this.merges=new Set,this.majority=(h.length>>>1)+1,this.indexers=h,this.removed=new a,this.updated=!1,this.writers=new n;for(const o of this.indexers)this.writers.set(o.core.key,o)}addHead(h){if(h.writer.isActiveIndexer)return this._isMerge(h)&&this.merges.add(h),this.updated=!0,h}_tails(h,o){const c=new Set;for(const s of o)h.clock.includes(s.writer.core.key,s.length)&&c.add(s);return c}_tailsAndMerges(h,o){const c=this._tails(h,o);for(const s of this.merges)s!==h&&h.clock.includes(s.writer.core.key,s.length)&&c.add(s);return c}_isMerge(h){if(!h.writer.isActiveIndexer)return!1;const o=[];for(const c of this.indexers){let s=h.clock.get(c.core.key)-1;c===h.writer&&s--;const u=c.get(s);if(!u||this.removed.includes(u.writer.core.key,u.length))continue;let f=!0;for(let m=0;m<o.length;m++){const E=o[m];if(E!==u){if(E.clock.includes(u.writer.core.key,u.length)){f=!1;break}if(u.clock.includes(E.writer.core.key,E.length)){const b=o.pop();if(E===b)continue;o[m--]=b}}}f&&o.push(u)}return o.length>1}_indexerTails(){const h=new Set;for(const o of this.indexers){const c=this.removed.has(o.core.key)?this.removed.get(o.core.key):o.indexed,s=o.get(c);if(!s||this.removed.includes(s.writer.core.key,s.length))continue;let u=!0;for(const f of h){if(s.clock.includes(f.writer.core.key,f.length)){u=!1;break}f.clock.includes(s.writer.core.key,s.length)&&h.delete(f)}u&&h.add(s)}return h}_strictlyNewer(h,o){for(const[c,s]of o.clock){const u=this.removed.get(c);if(s<=u)continue;let f=h.clock.get(c);if(f<=u&&(f=u),s<f)return!1;if(s===f)continue;const m=this.writers.get(c),E=m&&m.get(f>=m.indexed?f:m.indexed);if(E&&!E.clock.includes(h.writer.core.key,h.length)&&o.clock.includes(E.writer.core.key,E.length))return!1}return o.clock.get(h.writer.core.key)>=h.length}_acks(h){const o=h.writer.isActiveIndexer?[h]:[];for(const c of this.indexers){if(c===h.writer)continue;let s=h.clock.get(c.core.key);s<c.nodes.offset&&(s=c.nodes.offset);const u=c.get(s>=c.indexed?s:c.indexed);u&&u.clock.includes(h.writer.core.key,h.length)&&this._strictlyNewer(h,u)&&o.push(u)}return o}acksFromNode(h,o){const c=new Set;if(!o||!o.clock.includes(h.writer.core.key,h.length))return c;c.add(o.writer);for(const s of this.indexers){if(s===o.writer)continue;const u=o.clock.get(s.core.key);if(!u||h.clock.includes(s.core.key,u))continue;const f=s.get(u-1);f&&f.clock.includes(h.writer.core.key,h.length)&&c.add(s)}return c}_ackedAt(h,o){let c=0,s=h.length;for(const u of h){if(s--,!o.clock.includes(u.writer.core.key,u.length)){if(c+s<this.majority)return!1;continue}if(++c>=this.majority)return!0}return!1}confirms(h,o,c,s){if(!s||this.removed.get(h.core.key)>=s)return p;let u=!0,f=!0;for(let m=s-1;m>=0;m--){const E=h.get(m);if(E===null)return p;let b=0;for(const _ of c)if(E.clock.includes(_.writer.core.key,_.length)&&++b>=this.majority)break;if(!f&&b<this.majority)break;if(this._strictlyNewer(o,E)){if(b<this.majority)return l}else{if(u){u=!1;let _=s-1,B=0;for(;_>B;){const M=_+B>>>1,z=h.get(M);z===null||!z.clock.includes(o.writer.core.key,o.length)||this._strictlyNewer(o,z)?B=M+1:_=M-1}B+1<m&&(m=B+2)}f=!1;continue}return g}return p}_isConfirmed(h,o=null){const c=this._acks(h),s=new Set;if(c.length<this.majority)return!1;let u=!0;for(const f of this.indexers){const m=o?o.writer===f?o.length-1:o.clock.get(f.core.key):f.length,E=this.confirms(f,h,c,m);if(E===g&&(s.add(f),s.size>=this.majority))return!0;E===p&&(u=!1)}return o?this._isConfirmableAt(h,o,c,s):u}_isConfirmableAt(h,o,c,s){if(!this._ackedAt(c,o))return!1;let u=s.size;for(const f of this.indexers){if(s.has(f))continue;const m=o.clock.get(f.core.key);if(!h.clock.includes(f.core.key,m)){const b=f.get(m-1);if(b&&!this.removed.includes(b.writer.core.key,b.length)&&!this._strictlyNewer(h,b))continue}if(++u>=this.majority)return!0}return!1}remove(h){return this.merges.delete(h),this.removed.set(h.writer.core.key,h.length),h}shift(){if(!this.updated)return[];const h=this._indexerTails();for(const o of h)if(this._isConfirmed(o))return[this.remove(o)];for(const o of this.merges)if(this._isConfirmed(o))return this._yieldNext(o,h);return this.updated=!1,[]}_yieldNext(h,o){for(;!o.has(h);){let c=null;for(const u of this._tailsAndMerges(h,o))if(this._isConfirmed(u,h)){c=u;break}if(c){h=c;continue}const s=[];for(const u of this._tails(h,o))s.push(this.remove(u));return s}return[this.remove(h)]}shouldAck(h){for(const o of this._indexerTails())if(o.writer!==h&&this._shouldAckNode(o,h))return!0;return!1}_shouldAckNode(h,o){const c=o.head(),s=h.clock.get(o.core.key),u=o.get(s>=o.indexed?s:o.indexed);if(!u&&o!==h.writer)return!0;if(u){if(!u.clock.includes(h.writer.core.key,h.length))return!c.clock.includes(h.writer.core.key,h.length);if(!this._strictlyNewer(h,u))return!1}const f=this._acks(h);return f.length>=this.majority?this.confirms(o,h,f,o.length)===p:!1}},Ju}var ed,Pw;function MS(){if(Pw)return ed;Pw=1;const n=Ue(),a=On();ed=class{constructor(){this.tip=[],this.undo=0,this.shared=0}static compare(_,B){return m(_,B)}static add(_,B,M){y(_,B,M)}mark(){this.shared=this.tip.length,this.undo=0}flush(_=[]){_.length&&this._applyIndexed(_);const B={shared:this.shared,undo:this.undo,length:_.length+this.tip.length,indexed:_,tip:this.tip};return this.mark(),B}print(){return this.tip.map(_=>_.writer.core.key.toString()+_.length)}_applyIndexed(_){a(_.length<=this.tip.length,"Indexed batch cannot exceed tip");let B=0;for(;B<_.length&&this.tip[B]===_[B];B++);B<_.length&&this._track(B);const M=[];for(let z=B;z<this.tip.length;z++){const j=this.tip[z];if(j.yielded)continue;const v=y(j,M,0);v!==M.length-1&&this._track(B+v)}this.tip=M}add(_){const B=y(_,this.tip,0);this._track(B)}_track(_){_<this.shared&&(this.undo+=this.shared-_,this.shared=_)}};function p(b){for(const _ of b.dependencies)if(_.optimistic)return!0;return!1}function l(b,_){const B=new Set,M=[b];for(;M.length>0;){const j=M.pop();if(!B.has(j)){j.optimistic&&j!==b&&B.add(j);for(const v of j.dependencies)v.optimistic&&M.push(v)}}const z=[];for(let j=_.length-1;B.size!==z.length&&j>=0;j--){const v=_[j];B.has(v)&&z.push(v)}return z.reverse()}function g(b,_,B){const M=l(b,_),z=new Uint32Array(M.length);for(let v=0;v<M.length;v++){const w=M[v];z[v]=w.index,h(w,_,B)}s(b,_,B);for(let v=M.length-1;v>=0;v--)o(M[v],_,B);let j=b.index;for(let v=0;v<M.length;v++){const w=z[v],R=M[v];w!==R.index&&(w<j&&(j=w),R.index<j&&(j=R.index))}return j}function y(b,_,B){return _.push(b),b.index=_.length-1,p(b)?g(b,_,B):(s(b,_,B),b.index)}function h(b,_,B){for(;b.index>B;){const M=_[b.index-1];if(u(b,M))break;_[M.index=b.index]=M,_[--b.index]=b}}function o(b,_,B){for(;b.index<_.length-1;){const M=_[b.index+1];if(u(M,b))break;_[M.index=b.index]=M,_[++b.index]=b}for(;b.index>B;){const M=_[b.index-1];if(!M.optimistic||m(M,b)<=0)break;_[M.index=b.index]=M,_[--b.index]=b}}function c(b,_,B){for(;b.index<_.length-1;){const M=_[b.index+1];if(f(b,M,_)<=0)break;_[M.index=b.index]=M,_[++b.index]=b}}function s(b,_,B){h(b,_,B),b.optimistic?o(b,_,B):c(b,_)}function u(b,_){return _.dependents.has(b)?!0:b.length>0&&_.length===b.length-1&&b.writer===_.writer}function f(b,_,B){if(!_.optimistic)return m(b,_);for(let M=_.index+1;M<B.length;M++){const z=B[M];if(!z.optimistic)return m(b,z)}return-1}function m(b,_){return u(_,b)?-1:E(b,_)}function E(b,_){const B=n.compare(b.writer.core.key,_.writer.core.key);return B===0?b.length<_.length?-1:1:B}return ed}var td,Iw;function i0(){if(Iw)return td;Iw=1;const n=Ue(),a=On(),p=n0(),l=CS(),g=MS();class y{constructor(u,f,m,E,b,_,B){this.writer=u,this.length=f,this.value=m,this.heads=E,this.actualHeads=E.slice(0),this.dependents=new Set,this.dependencies=_,this.index=0,this.optimistic=B&&b===1&&!!m,this.batch=b,this.dropped=0,this.clock=new p,this.yielded=!1,this.yielding=!1}isTail(){return this.dependencies.size===this.dropped}causalDependencies(u){const f=[this],m=[this];let E=null;for(;m.length>0;){const b=m.pop();for(const _ of b.dependencies)!_.writer.isRemoved||_.writer.isActiveIndexer||(E===null&&(E=new Set),!E.has(_)&&(E.add(_),m.push(_),f.push(_)))}return f}clear(){return this.clock=null,this.dependents=null,this}reset(){this.yielded=!1,this.yielding=!1;for(const u of this.dependents)u.dependencies.add(this);this.dependents.clear()}active(){for(const u of this.dependencies)u.yielded?this.dependencies.delete(u):(u.dependents.add(this),this.clock.add(u.clock));this.writer.isActiveIndexer&&this.clock.set(this.writer.core.key,this.length)}tieBreak(u){return h(this,u)}hasDependency(u){for(const f of this.actualHeads)if(c(f,u))return!0;return!1}get ref(){return this.writer.core.key.toString("hex").slice(0,2)+":"+this.length}}td=class{constructor(u,{heads:f=[],writers:m=new Map}={}){this.heads=new Set,this.tails=new Set,this.tip=new g,this.size=0,this.updated=!1,this.indexersUpdated=!1,this.writers=m,this.consensus=new l(u),this._initialHeads=f.slice(0),this._strictlyAdded=null;for(const{key:E,length:b}of f)this.consensus.removed.set(E,b)}get indexers(){return this.consensus.indexers}static createNode(u,f,m,E,b,_,B){return new y(u,f,m,E,b,_,B)}getHeads(){const u=this._initialHeads.slice(0);for(const f of this.heads)u.push({key:f.writer.core.key,length:f.length});return u}getBootstrapWriters(){const u=[];for(const f of this.heads)u.push(f.writer);for(let f=0;f<this.consensus.indexers.length;f++)u.push(this.consensus.indexers[f]);return u}addHead(u){u.active(),this._initialHeads.length>0&&this._updateInitialHeads(u),u.isTail()&&this.tails.add(u);for(const f of this.heads)u.hasDependency(f)&&this.heads.delete(f);return this.tip.add(u),u.writer.isActiveIndexer&&this.consensus.addHead(u),this.size++,this.heads.add(u),this.updated=!0,u}update(){if(!this.updated)return null;this.updated=!1;const u=[];for(;;){const f=this.consensus.shift();if(!f.length)break;this._yield(f,u)}return this.tip.flush(u)}_updateInitialHeads(u){for(const f of u.actualHeads)for(let m=0;m<this._initialHeads.length;m++){const{key:E,length:b}=this._initialHeads[m];b!==f.length||!n.equals(E,f.key)||this._initialHeads.splice(m--,1)}}shouldAck(u,f=!1){if(!u||!u.isActiveIndexer)return!1;for(const _ of this.indexers)if(_.length!==_.available)return!1;let m=!1;for(const _ of this.heads){if(!_.writer.isActiveIndexer)return!0;_.writer===u&&(m=!0)}if(this.heads.size===1&&m)return!1;const E=new Set;let b=!1;for(const _ of this.tails)if(f||this._nonNull(_,E)){b=!0;break}return b?this.consensus.shouldAck(u)?!0:this._shouldAckHeads(u,f):!1}_nonNull(u,f){const m=[u];for(;m.length;){const E=m.pop();if(!f.has(E)){if(E.value!==null)return!0;f.add(E);for(const b of E.dependents)m.push(b)}}return!1}_shouldAckHeads(u,f){const m=u.head();for(const E of this.heads){if(E.writer===u)continue;const b=[E],_=new Set;for(;b.length;){const B=b.pop();if(!_.has(B)){if(_.add(B),f||B.value!==null){const M=this.consensus.acksFromNode(B,E),z=this.consensus.acksFromNode(B,m);if(M.size>z.size)return!0;for(const j of M)if(!z.has(j))return!0;if(z.size&&M.size)continue}b.push(...B.dependencies)}}}return!1}_yield(u,f=[]){const m=f.length,E=[];for(;u.length;){const b=u.pop();b.yielding||(b.yielding=!0,b.isTail()&&E.push(b),u.push(...b.dependencies))}for(;E.length;){let b=E.pop();for(b of this._removeBatch(b))g.add(b,f,m);for(const _ of b.dependents)_.isTail()&&_.yielding&&E.push(_)}return f}_isFutureTail(u){let f=u.dropped;for(const m of u.dependencies)if(!m.yielded){if(f===0)return!1;f--}return!0}_removeNode(u){this.tails.delete(u),this.heads.delete(u),this.consensus.remove(u);for(const f of u.dependents)f.yielding&&f.dependencies.has(u)?f.dropped++:f.dependencies.delete(u),this._isFutureTail(f)&&this.tails.add(f);return u.yielded=!0,this.size--,this.heads.size===0&&this._initialHeads.push({key:u.writer.core.key,length:u.length}),u}_removeBatch(u){const f=[this._removeNode(u)];for(;u.batch!==1;){if(u.dependents.size===0){const m=u.writer.get(u.length);m&&m.batch===u.batch-1&&u.dependents.add(m)}a(u.dependents.size===1,"Batch is linked partially, which is not allowed"),u=o(u.dependents),f.push(this._removeNode(u))}return f}};function h(s,u){return g.compare(s,u)<0}function o(s){return s[Symbol.iterator]().next().value}function c(s,u){return n.equals(s.key,u.writer.core.key)&&s.length===u.length}return td}var nd,Kw;function s0(){if(Kw)return nd;Kw=1;const n=Ue();nd=l,l.ascii=y("ascii"),l.utf8=y("utf-8"),l.hex=y("hex"),l.base64=y("base64"),l.ucs2=y("ucs2"),l.utf16le=y("utf16le"),l.ndjson=g(!0),l.json=g(!1),l.binary={name:"binary",encode:function(o){return typeof o=="string"?n.from(o,"utf-8"):n.toBuffer(o)},decode:function(o){return n.toBuffer(o)}};function a(h){return!!(h.encode&&h.decode&&h.preencode)}function p(h){return{name:"compact-encoding",encode:function(c){const s={start:0,end:0,buffer:null,cache:null};return h.preencode(s,c),s.buffer=n.allocUnsafe(s.end),h.encode(s,c),s.buffer},decode:function(c){return h.decode({start:0,end:c.byteLength,buffer:c,cache:null})}}}function l(h,o){if(typeof h=="object"&&h)return a(h)?p(h):h;switch(h){case"ndjson":return l.ndjson;case"json":return l.json;case"ascii":return l.ascii;case"utf-8":case"utf8":return l.utf8;case"hex":return l.hex;case"base64":return l.base64;case"ucs-2":case"ucs2":return l.ucs2;case"utf16-le":case"utf16le":return l.utf16le}return o!==void 0?o:l.binary}function g(h){return{name:h?"ndjson":"json",encode:h?c:o,decode:function(u){return JSON.parse(n.toString(u))}};function o(s){return n.from(JSON.stringify(s))}function c(s){return n.from(JSON.stringify(s)+`
`)}}function y(h){return{name:h,encode:function(c){return typeof c!="string"&&(c=c.toString()),n.from(c,h)},decode:function(c){return n.toString(c,h)}}}return nd}var id,zw;function US(){if(zw)return id;zw=1;class n{constructor(g,y,h){this.key=g,this.index=y,this.map=h}}class a{constructor(g,y){this.entry=g,this.value=y}}class p{constructor({maxSize:g=65536,parent:y=null}={}){this.maxSize=y?.maxSize||g,this._array=y?._array||[],this._map=new Map}static from(g){return g?new this({parent:g}):new this}get globalSize(){return this._array.length}get size(){return this._map.size}sub(){return new p({parent:this})}set(g,y){const h=this._map.get(g);if(h!==void 0){h.value=y;return}this._array.length>=this.maxSize&&this._gc();const o=new n(g,this._array.length,this._map);this._array.push(o);const c=new a(o,y);this._map.set(g,c)}delete(g){const y=this._map.get(g);return y===void 0?!1:(this._delete(y.entry.index),!0)}get(g){const y=this._map.get(g);return y===void 0?void 0:y.value}*[Symbol.iterator](){for(const[g,{value:y}]of this._map)yield[g,y]}keys(){return this._map.keys()}*values(){for(const{value:g}of this._map.values())yield g}clear(){this._map.clear(),this._map=new Map}destroy(){this._map=null,this._array=null}_gc(){this._delete(Math.floor(Math.random()*this._array.length))}_delete(g){if(g>=this._array.length)throw new Error("Cannot delete unused index (logic bug?)");const y=this._array.pop();let h=y;g<this._array.length&&(h=this._array[g],y.index=g,this._array[g]=y),h.map.delete(h.key)}}return id=p,id}var sd,Hw;function OS(){if(Hw)return sd;Hw=1;const n=Ue();return sd=class{constructor(p,l,g={}){this.batch=p,this.stack=[],this.opened=!1,this.encoding=l||p.encoding,this._limit=typeof g.limit=="number"?g.limit:-1,this._gIncl=!g.gt,this._gKey=g.gt||g.gte||null,this._lIncl=!g.lt,this._lKey=g.lt||g.lte||null,this._reverse=!!g.reverse,this._version=0,this._checkpoint=g.checkpoint&&g.checkpoint.length?g.checkpoint:null,this._nexting=!1}snapshot(p=this.batch.version){const l=[];for(const g of this.stack){let{node:y,i:h}=g;this._nexting&&g===this.stack[this.stack.length-1]&&(h=this._reverse?h+1:h-1),y.block&&(h<0||l.push(y.block.seq,y.offset,h))}return{version:p,gte:this._gIncl?this._gKey:null,gt:this._gIncl?null:this._gKey,lte:this._lIncl?this._lKey:null,lt:this._lIncl?null:this._lKey,limit:this._limit,reverse:this._reverse,ended:this.opened&&!l.length,checkpoint:this.opened?l:[]}}async open(){await this._open(),this.opened=!0}async _open(){if(this._checkpoint){for(let y=0;y<this._checkpoint.length;y+=3){const h=this._checkpoint[y],o=this._checkpoint[y+1],c=this._checkpoint[y+2];this.stack.push({node:(await this.batch.getBlock(h)).getTreeNode(o),i:c})}return}this._nexting=!0;let p=await this.batch.getRoot(!1);if(!p){this._nexting=!1;return}const l=this._reverse?this._lIncl:this._gIncl,g=this._reverse?this._lKey:this._gKey;if(!g){this.stack.push({node:p,i:this._reverse?p.keys.length<<1:0}),this._nexting=!1;return}for(;;){const y={node:p,i:this._reverse?p.keys.length<<1:0};let h=0,o=p.keys.length,c;for(;h<o;){const u=h+o>>1;if(c=n.compare(g,await p.getKey(u)),c===0){l?y.i=u*2+1:y.i=u*2+(this._reverse?0:2),this.stack.push(y),this._nexting=!1;return}c<0?o=u:h=u+1}const s=c<0?o:h;if(y.i=2*s+(this._reverse?-1:1),y.i>=0&&y.i<=p.keys.length<<1&&this.stack.push(y),!p.children.length){this._nexting=!1;return}p=await p.getChildNode(s)}}async next(){this._nexting=!0;const p=this._reverse?this._gKey:this._lKey,l=this._reverse?this._gIncl:this._lIncl;for(;this.stack.length&&(this._limit===-1||this._limit>0);){const g=this.stack[this.stack.length-1],y=(g.i&1)===1,h=this._reverse?g.i<0?g.node.keys.length:g.i-->>1:g.i++>>1;if(!y){if(!g.node.children.length)continue;const s=await g.node.getChildNode(h);g.node.block.seq<this.batch.core.length&&(g.node.children[h].value=null),this.stack.push({i:this._reverse?s.keys.length<<1:0,node:s});continue}if(h>=g.node.keys.length){this.stack.pop();continue}const o=g.node.keys[h],c=await this.batch.getBlock(o.seq);if(p){const s=n.compare(c.key,p);if(s===0?!l:this._reverse?s<0:s>0){this._limit=0;break}}return this._limit>0&&this._limit--,this._nexting=!1,c.final(this.encoding)}return this._nexting=!1,null}close(){return this.batch._closeSnapshot()}},sd}var rd,Fw;function PS(){if(Fw)return rd;Fw=1,rd=class{constructor(g,y={}){if(this.batch=g,this.options=y,this.live=!!y.live,this.gte=0,this.lt=0,this.reverse=!!y.reverse,this.limit=typeof y.limit=="number"?y.limit:-1,this.encoding=y.encoding||g.encoding,this.live&&this.reverse)throw new Error("Cannot have both live and reverse enabled")}async open(){await this.batch.getRoot(!1),this.gte=a(this.options,this.batch.version),this.lt=this.live?1/0:p(this.options,this.batch.version)}async next(){return this.limit===0||(this.limit>0&&this.limit--,this.gte>=this.lt)?null:this.reverse?this.lt<=1?null:n(await this.batch.getBlock(--this.lt),this.encoding):n(await this.batch.getBlock(this.gte++),this.encoding)}close(){return this.batch._closeSnapshot()}};function n(l,g){return{type:l.isDeletion()?"del":"put",...l.final(g)}}function a(l,g){if(l.gt)return(l.gt<0?l.gt+g:l.gt)+1;const y=l.gte||l.since||1;return y<0?y+g:y}function p(l,g){if(l.lte===0||l.lt===0||l.end===0)return 0;if(l.lte)return(l.lte<0?l.lte+g:l.lte)+1;const y=l.lt||l.end||g;return y<0?y+g:y}return rd}var od,Vw;function IS(){if(Vw)return od;Vw=1;const n=Ue();class a{constructor(y,h){this.node=y,this.parent=h,this.isKey=y.children.length===0,this.i=this.isKey?1:0,this.n=0;const o=this.isKey?null:this.node.children[0];this.seq=o!==null?o.seq:this.node.keys[0].seq,this.offset=o!==null?o.offset:0}next(){return this.i++,this.isKey=(this.i&1)===1,!this.isKey&&!this.node.children.length&&this.i++,this.update()}async bisect(y,h){let o=0,c=this.node.keys.length,s;for(;o<c;){const f=o+c>>1;if(s=l(y,await this.node.getKey(f)),s===0)return h?this.i=f*2+1:this.i=f*2+(this.node.children.length?2:3),!0;s<0?c=f:o=f+1}const u=s<0?c:o;return this.i=2*u+(this.node.children.length?0:1),this.node.children.length===0}update(){if(this.isKey=(this.i&1)===1,this.n=this.i>>1,this.n>=(this.isKey?this.node.keys.length:this.node.children.length))return!1;const y=this.isKey?null:this.node.children[this.n];return this.seq=y!==null?y.seq:this.node.keys[this.n].seq,this.offset=y!==null?y.offset:0,!0}async key(){return this.n<this.node.keys.length?this.node.getKey(this.n):this.parent&&this.parent.key()}async compare(y){const[h,o]=await Promise.all([this.key(),y.key()]);return l(h,o)}}class p{constructor(y,h){this.batch=y,this.stack=[],this.lt=h.lt||h.lte||null,this.lte=!!h.lte,this.gt=h.gt||h.gte||null,this.gte=!!h.gte,this.seeking=!!this.gt,this.encoding=h.encoding||y.encoding}async open(){const y=await this.batch.getRoot(!1);if(!y||!y.keys.length)return;const h=new a(y,null);this.seeking&&!await this._seek(h)||this.stack.push(h)}async _seek(y){const h=await y.bisect(this.gt,this.gte),o=!y.update();return!((h||o)&&(this.seeking=!1,o))}peek(){return this.stack.length?this.stack[this.stack.length-1]:null}skip(){this.stack.length&&(this.stack[this.stack.length-1].next()||this.stack.pop())}async nextKey(){let y=null;for(;this.stack.length&&y===null;)y=await this.next();if(y===null)return null;if(!this.lt)return y.final(this.encoding);const h=l(y.key,this.lt);return(this.lte?h<=0:h<0)?y.final(this.encoding):(this.stack=[],null)}async next(){if(!this.stack.length)return null;const y=this.stack[this.stack.length-1],{isKey:h,n:o,seq:c}=y;if(y.next()||this.stack.pop(),h)return this.seeking=!1,this.batch.getBlock(c);const s=await y.node.getChildNode(o);y.node.children[o]=null;const u=new a(s,y);return this.seeking&&!await this._seek(u)||this.stack.push(u),null}close(){return this.batch._closeSnapshot()}}od=class{constructor(y,h,o={}){this.left=new p(y,o),this.right=new p(h,o),this.limit=typeof o.limit=="number"?o.limit:-1}async open(){await Promise.all([this.left.open(),this.right.open()])}async next(){if(this.limit===0)return null;const y=await this._next();return!y||y.left===null&&y.right===null?null:(this.limit--,y)}async _next(){const y=this.left,h=this.right;for(;;){const[o,c]=await Promise.all([y.peek(),h.peek()]);if(!o&&!c)return null;if(!o)return{left:null,right:await h.nextKey()};if(!c)return{left:await y.nextKey(),right:null};if(o.seq===c.seq&&o.isKey===c.isKey&&o.offset===c.offset){y.skip(),h.skip();continue}const s=await o.compare(c);if(o.isKey&&!c.isKey){await h.next();continue}if(!o.isKey&&c.isKey){await y.next();continue}if(o.isKey&&c.isKey)return s===0?{left:await y.nextKey(),right:await h.nextKey()}:s<0?{left:await y.nextKey(),right:null}:{left:null,right:await h.nextKey()};s===0?await Promise.all([y.next(),h.next()]):s<0?await h.next():await y.next()}}async close(){await Promise.all([this.left.close(),this.right.close()])}};function l(g,y){return g?y?n.compare(g,y):g?-1:0:y?1:0}return od}var Ws={},ad={},ld,jw;function KS(){if(jw)return ld;jw=1,ld=l;var n=128,a=-128,p=Math.pow(2,31);function l(g,y,h){y=y||[],h=h||0;for(var o=h;g>=p;)y[h++]=g&255|n,g/=128;for(;g&a;)y[h++]=g&255|n,g>>>=7;return y[h]=g|0,l.bytes=h-o+1,y}return ld}var cd,Gw;function zS(){if(Gw)return cd;Gw=1,cd=p;var n=128,a=127;function p(l,h){var y=0,h=h||0,o=0,c=h,s,u=l.length;do{if(c>=u)throw p.bytes=0,new RangeError("Could not decode varint");s=l[c++],y+=o<28?(s&a)<<o:(s&a)*Math.pow(2,o),o+=7}while(s>=n);return p.bytes=c-h,y}return cd}var hd,Yw;function HS(){if(Yw)return hd;Yw=1;var n=Math.pow(2,7),a=Math.pow(2,14),p=Math.pow(2,21),l=Math.pow(2,28),g=Math.pow(2,35),y=Math.pow(2,42),h=Math.pow(2,49),o=Math.pow(2,56),c=Math.pow(2,63);return hd=function(s){return s<n?1:s<a?2:s<p?3:s<l?4:s<g?5:s<y?6:s<h?7:s<o?8:s<c?9:10},hd}var ud,Ww;function r0(){return Ww||(Ww=1,ud={encode:KS(),decode:zS(),encodingLength:HS()}),ud}var co={},Qw;function FS(){if(Qw)return co;Qw=1;var n=r0();return co.encode=function a(p,l,g){p=p>=0?p*2:p*-2-1;var y=n.encode(p,l,g);return a.bytes=n.encode.bytes,y},co.decode=function a(p,l){var g=n.decode(p,l);return a.bytes=n.decode.bytes,g&1?(g+1)/-2:g/2},co.encodingLength=function(a){return n.encodingLength(a>=0?a*2:a*-2-1)},co}var Xw;function VS(){return Xw||(Xw=1,function(n){var a=r0(),p=FS(),l=Ue();n.make=g,n.name=function(h){for(var o=Object.keys(n),c=0;c<o.length;c++)if(n[o[c]]===h)return o[c];return null},n.skip=function(h,o,c){switch(h){case 0:return a.decode(o,c),c+a.decode.bytes;case 1:return c+8;case 2:var s=a.decode(o,c);return c+a.decode.bytes+s;case 3:case 4:throw new Error("Groups are not supported");case 5:return c+4}throw new Error("Unknown wire type: "+h)},n.bytes=g(2,function h(o,c,s){var u=s,f=y(o);return a.encode(f,c,s),s+=a.encode.bytes,l.isBuffer(o)?l.copy(o,c,s):l.write(c,o,s,f),s+=f,h.bytes=s-u,c},function h(o,c){var s=c,u=a.decode(o,c);c+=a.decode.bytes;var f=o.subarray(c,c+u);return c+=f.length,h.bytes=c-s,f},function(o){var c=y(o);return a.encodingLength(c)+c}),n.string=g(2,function h(o,c,s){var u=s,f=l.byteLength(o);return a.encode(f,c,s,"utf-8"),s+=a.encode.bytes,l.write(c,o,s,f),s+=f,h.bytes=s-u,c},function h(o,c){var s=c,u=a.decode(o,c);c+=a.decode.bytes;var f=l.toString(o,"utf-8",c,c+u);return c+=u,h.bytes=c-s,f},function(o){var c=l.byteLength(o);return a.encodingLength(c)+c}),n.bool=g(0,function h(o,c,s){return c[s]=o?1:0,h.bytes=1,c},function h(o,c){var s=o[c]>0;return h.bytes=1,s},function(){return 1}),n.int32=g(0,function h(o,c,s){return a.encode(o<0?o+4294967296:o,c,s),h.bytes=a.encode.bytes,c},function h(o,c){var s=a.decode(o,c);return h.bytes=a.decode.bytes,s>2147483647?s-4294967296:s},function(o){return a.encodingLength(o<0?o+4294967296:o)}),n.int64=g(0,function h(o,c,s){if(o<0){var u=s+9;for(a.encode(o*-1,c,s),s+=a.encode.bytes-1,c[s]=c[s]|128;s<u-1;)s++,c[s]=255;c[u]=1,h.bytes=10}else a.encode(o,c,s),h.bytes=a.encode.bytes;return c},function h(o,c){var s=a.decode(o,c);if(s>=Math.pow(2,63)){for(var u=9;o[c+u-1]===255;)u--;u=u||9;var f=l.allocUnsafe(u);l.copy(o,f,0,c,c+u),f[u-1]=f[u-1]&127,s=-1*a.decode(f,0),h.bytes=10}else h.bytes=a.decode.bytes;return s},function(o){return o<0?10:a.encodingLength(o)}),n.sint32=n.sint64=g(0,p.encode,p.decode,p.encodingLength),n.uint32=n.uint64=n.enum=n.varint=g(0,a.encode,a.decode,a.encodingLength),n.fixed64=n.sfixed64=g(1,function h(o,c,s){return l.copy(o,c,s),h.bytes=8,c},function h(o,c){var s=o.subarray(c,c+8);return h.bytes=8,s},function(){return 8}),n.double=g(1,function h(o,c,s){return l.writeDoubleLE(c,o,s),h.bytes=8,c},function h(o,c){var s=l.readDoubleLE(o,c);return h.bytes=8,s},function(){return 8}),n.fixed32=g(5,function h(o,c,s){return l.writeUInt32LE(c,o,s),h.bytes=4,c},function h(o,c){var s=l.readUInt32LE(o,c);return h.bytes=4,s},function(){return 4}),n.sfixed32=g(5,function h(o,c,s){return l.writeInt32LE(c,o,s),h.bytes=4,c},function h(o,c){var s=l.readInt32LE(o,c);return h.bytes=4,s},function(){return 4}),n.float=g(5,function h(o,c,s){return l.writeFloatLE(c,o,s),h.bytes=4,c},function h(o,c){var s=l.readFloatLE(o,c);return h.bytes=4,s},function(){return 4});function g(h,o,c,s){return o.bytes=c.bytes=0,{type:h,encode:o,decode:c,encodingLength:s}}function y(h){return l.isBuffer(h)?h.length:l.byteLength(h)}}(ad)),ad}var Zw;function o0(){if(Zw)return Ws;Zw=1;var n=VS(),a=Ue(),p=n.varint,l=n.skip,g=Ws.YoloIndex={buffer:!0,encodingLength:null,encode:null,decode:null},y=Ws.Header={buffer:!0,encodingLength:null,encode:null,decode:null},h=Ws.Node={buffer:!0,encodingLength:null,encode:null,decode:null},o=Ws.Extension={buffer:!0,encodingLength:null,encode:null,decode:null};c(),s(),u(),f();function c(){var E=g.Level={buffer:!0,encodingLength:null,encode:null,decode:null};b();function b(){E.encodingLength=z,E.encode=j,E.decode=v;function z(w){var R=0;if(m(w.keys)){for(var A=0,q=0;q<w.keys.length;q++)if(m(w.keys[q])){var U=n.varint.encodingLength(w.keys[q]);A+=U}A&&(R+=1+A+p.encodingLength(A))}if(m(w.children)){for(var A=0,q=0;q<w.children.length;q++)if(m(w.children[q])){var U=n.varint.encodingLength(w.children[q]);A+=U}A&&(R+=1+A+p.encodingLength(A))}return R}function j(w,R,A){A||(A=0),R||(R=a.allocUnsafe(z(w)));var q=A;if(m(w.keys)){for(var U=0,T=0;T<w.keys.length;T++)m(w.keys[T])&&(U+=n.varint.encodingLength(w.keys[T]));U&&(R[A++]=10,p.encode(U,R,A),A+=p.encode.bytes);for(var T=0;T<w.keys.length;T++)m(w.keys[T])&&(n.varint.encode(w.keys[T],R,A),A+=n.varint.encode.bytes)}if(m(w.children)){for(var U=0,T=0;T<w.children.length;T++)m(w.children[T])&&(U+=n.varint.encodingLength(w.children[T]));U&&(R[A++]=18,p.encode(U,R,A),A+=p.encode.bytes);for(var T=0;T<w.children.length;T++)m(w.children[T])&&(n.varint.encode(w.children[T],R,A),A+=n.varint.encode.bytes)}return j.bytes=A-q,R}function v(w,R,A){if(R||(R=0),A||(A=w.length),!(A<=w.length&&R<=w.length))throw new Error("Decoded message is not valid");for(var q=R,U={keys:[],children:[]};;){if(A<=R)return v.bytes=R-q,U;var T=p.decode(w,R);R+=p.decode.bytes;var Q=T>>3;switch(Q){case 1:var le=p.decode(w,R);for(R+=p.decode.bytes,le+=R;R<le;)U.keys.push(n.varint.decode(w,R)),R+=n.varint.decode.bytes;break;case 2:var le=p.decode(w,R);for(R+=p.decode.bytes,le+=R;R<le;)U.children.push(n.varint.decode(w,R)),R+=n.varint.decode.bytes;break;default:R=l(T&7,w,R)}}}}g.encodingLength=_,g.encode=B,g.decode=M;function _(z){var j=0;if(m(z.levels)){for(var v=0;v<z.levels.length;v++)if(m(z.levels[v])){var w=E.encodingLength(z.levels[v]);j+=p.encodingLength(w),j+=1+w}}return j}function B(z,j,v){v||(v=0),j||(j=a.allocUnsafe(_(z)));var w=v;if(m(z.levels))for(var R=0;R<z.levels.length;R++)m(z.levels[R])&&(j[v++]=10,p.encode(E.encodingLength(z.levels[R]),j,v),v+=p.encode.bytes,E.encode(z.levels[R],j,v),v+=E.encode.bytes);return B.bytes=v-w,j}function M(z,j,v){if(j||(j=0),v||(v=z.length),!(v<=z.length&&j<=z.length))throw new Error("Decoded message is not valid");for(var w=j,R={levels:[]};;){if(v<=j)return M.bytes=j-w,R;var A=p.decode(z,j);j+=p.decode.bytes;var q=A>>3;switch(q){case 1:var U=p.decode(z,j);j+=p.decode.bytes,R.levels.push(E.decode(z,j,j+U)),j+=E.decode.bytes;break;default:j=l(A&7,z,j)}}}}function s(){var E=y.Metadata={buffer:!0,encodingLength:null,encode:null,decode:null};b();function b(){E.encodingLength=z,E.encode=j,E.decode=v;function z(w){var R=0;if(m(w.contentFeed)){var A=n.bytes.encodingLength(w.contentFeed);R+=1+A}if(m(w.userData)){var A=n.bytes.encodingLength(w.userData);R+=1+A}return R}function j(w,R,A){A||(A=0),R||(R=a.allocUnsafe(z(w)));var q=A;return m(w.contentFeed)&&(R[A++]=10,n.bytes.encode(w.contentFeed,R,A),A+=n.bytes.encode.bytes),m(w.userData)&&(R[A++]=18,n.bytes.encode(w.userData,R,A),A+=n.bytes.encode.bytes),j.bytes=A-q,R}function v(w,R,A){if(R||(R=0),A||(A=w.length),!(A<=w.length&&R<=w.length))throw new Error("Decoded message is not valid");for(var q=R,U={contentFeed:null,userData:null};;){if(A<=R)return v.bytes=R-q,U;var T=p.decode(w,R);R+=p.decode.bytes;var Q=T>>3;switch(Q){case 1:U.contentFeed=n.bytes.decode(w,R),R+=n.bytes.decode.bytes;break;case 2:U.userData=n.bytes.decode(w,R),R+=n.bytes.decode.bytes;break;default:R=l(T&7,w,R)}}}}y.encodingLength=_,y.encode=B,y.decode=M;function _(z){var j=0;if(!m(z.protocol))throw new Error("protocol is required");var v=n.string.encodingLength(z.protocol);if(j+=1+v,m(z.metadata)){var v=E.encodingLength(z.metadata);j+=p.encodingLength(v),j+=1+v}return j}function B(z,j,v){v||(v=0),j||(j=a.allocUnsafe(_(z)));var w=v;if(!m(z.protocol))throw new Error("protocol is required");return j[v++]=10,n.string.encode(z.protocol,j,v),v+=n.string.encode.bytes,m(z.metadata)&&(j[v++]=18,p.encode(E.encodingLength(z.metadata),j,v),v+=p.encode.bytes,E.encode(z.metadata,j,v),v+=E.encode.bytes),B.bytes=v-w,j}function M(z,j,v){if(j||(j=0),v||(v=z.length),!(v<=z.length&&j<=z.length))throw new Error("Decoded message is not valid");for(var w=j,R={protocol:"",metadata:null},A=!1;;){if(v<=j){if(!A)throw new Error("Decoded message is not valid");return M.bytes=j-w,R}var q=p.decode(z,j);j+=p.decode.bytes;var U=q>>3;switch(U){case 1:R.protocol=n.string.decode(z,j),j+=n.string.decode.bytes,A=!0;break;case 2:var T=p.decode(z,j);j+=p.decode.bytes,R.metadata=E.decode(z,j,j+T),j+=E.decode.bytes;break;default:j=l(q&7,z,j)}}}}function u(){h.encodingLength=E,h.encode=b,h.decode=_;function E(B){var M=0;if(!m(B.index))throw new Error("index is required");var z=n.bytes.encodingLength(B.index);if(M+=1+z,!m(B.key))throw new Error("key is required");var z=n.bytes.encodingLength(B.key);if(M+=1+z,m(B.value)){var z=n.bytes.encodingLength(B.value);M+=1+z}return M}function b(B,M,z){z||(z=0),M||(M=a.allocUnsafe(E(B)));var j=z;if(!m(B.index))throw new Error("index is required");if(M[z++]=10,n.bytes.encode(B.index,M,z),z+=n.bytes.encode.bytes,!m(B.key))throw new Error("key is required");return M[z++]=18,n.bytes.encode(B.key,M,z),z+=n.bytes.encode.bytes,m(B.value)&&(M[z++]=26,n.bytes.encode(B.value,M,z),z+=n.bytes.encode.bytes),b.bytes=z-j,M}function _(B,M,z){if(M||(M=0),z||(z=B.length),!(z<=B.length&&M<=B.length))throw new Error("Decoded message is not valid");for(var j=M,v={index:null,key:null,value:null},w=!1,R=!1;;){if(z<=M){if(!w||!R)throw new Error("Decoded message is not valid");return _.bytes=M-j,v}var A=p.decode(B,M);M+=p.decode.bytes;var q=A>>3;switch(q){case 1:v.index=n.bytes.decode(B,M),M+=n.bytes.decode.bytes,w=!0;break;case 2:v.key=n.bytes.decode(B,M),M+=n.bytes.decode.bytes,R=!0;break;case 3:v.value=n.bytes.decode(B,M),M+=n.bytes.decode.bytes;break;default:M=l(A&7,B,M)}}}}function f(){var E=o.Get={buffer:!0,encodingLength:null,encode:null,decode:null},b=o.Iterator={buffer:!0,encodingLength:null,encode:null,decode:null},_=o.Cache={buffer:!0,encodingLength:null,encode:null,decode:null};B(),M(),z();function B(){E.encodingLength=R,E.encode=A,E.decode=q;function R(U){var T=0;if(m(U.version)){var Q=n.varint.encodingLength(U.version);T+=1+Q}if(m(U.key)){var Q=n.bytes.encodingLength(U.key);T+=1+Q}return T}function A(U,T,Q){Q||(Q=0),T||(T=a.allocUnsafe(R(U)));var le=Q;return m(U.version)&&(T[Q++]=8,n.varint.encode(U.version,T,Q),Q+=n.varint.encode.bytes),m(U.key)&&(T[Q++]=18,n.bytes.encode(U.key,T,Q),Q+=n.bytes.encode.bytes),A.bytes=Q-le,T}function q(U,T,Q){if(T||(T=0),Q||(Q=U.length),!(Q<=U.length&&T<=U.length))throw new Error("Decoded message is not valid");for(var le=T,Y={version:0,key:null};;){if(Q<=T)return q.bytes=T-le,Y;var oe=p.decode(U,T);T+=p.decode.bytes;var ue=oe>>3;switch(ue){case 1:Y.version=n.varint.decode(U,T),T+=n.varint.decode.bytes;break;case 2:Y.key=n.bytes.decode(U,T),T+=n.bytes.decode.bytes;break;default:T=l(oe&7,U,T)}}}}function M(){b.encodingLength=R,b.encode=A,b.decode=q;function R(U){var T=0;if(m(U.version)){var Q=n.varint.encodingLength(U.version);T+=1+Q}if(m(U.gte)){var Q=n.bytes.encodingLength(U.gte);T+=1+Q}if(m(U.gt)){var Q=n.bytes.encodingLength(U.gt);T+=1+Q}if(m(U.lte)){var Q=n.bytes.encodingLength(U.lte);T+=1+Q}if(m(U.lt)){var Q=n.bytes.encodingLength(U.lt);T+=1+Q}if(m(U.limit)){var Q=n.varint.encodingLength(U.limit);T+=1+Q}if(m(U.reverse)){var Q=n.bool.encodingLength(U.reverse);T+=1+Q}if(m(U.checkpoint)){for(var le=0,Y=0;Y<U.checkpoint.length;Y++)if(m(U.checkpoint[Y])){var Q=n.varint.encodingLength(U.checkpoint[Y]);le+=Q}le&&(T+=1+le+p.encodingLength(le))}return T}function A(U,T,Q){Q||(Q=0),T||(T=a.allocUnsafe(R(U)));var le=Q;if(m(U.version)&&(T[Q++]=8,n.varint.encode(U.version,T,Q),Q+=n.varint.encode.bytes),m(U.gte)&&(T[Q++]=18,n.bytes.encode(U.gte,T,Q),Q+=n.bytes.encode.bytes),m(U.gt)&&(T[Q++]=26,n.bytes.encode(U.gt,T,Q),Q+=n.bytes.encode.bytes),m(U.lte)&&(T[Q++]=34,n.bytes.encode(U.lte,T,Q),Q+=n.bytes.encode.bytes),m(U.lt)&&(T[Q++]=42,n.bytes.encode(U.lt,T,Q),Q+=n.bytes.encode.bytes),m(U.limit)&&(T[Q++]=48,n.varint.encode(U.limit,T,Q),Q+=n.varint.encode.bytes),m(U.reverse)&&(T[Q++]=56,n.bool.encode(U.reverse,T,Q),Q+=n.bool.encode.bytes),m(U.checkpoint)){for(var Y=0,oe=0;oe<U.checkpoint.length;oe++)m(U.checkpoint[oe])&&(Y+=n.varint.encodingLength(U.checkpoint[oe]));Y&&(T[Q++]=66,p.encode(Y,T,Q),Q+=p.encode.bytes);for(var oe=0;oe<U.checkpoint.length;oe++)m(U.checkpoint[oe])&&(n.varint.encode(U.checkpoint[oe],T,Q),Q+=n.varint.encode.bytes)}return A.bytes=Q-le,T}function q(U,T,Q){if(T||(T=0),Q||(Q=U.length),!(Q<=U.length&&T<=U.length))throw new Error("Decoded message is not valid");for(var le=T,Y={version:0,gte:null,gt:null,lte:null,lt:null,limit:0,reverse:!1,checkpoint:[]};;){if(Q<=T)return q.bytes=T-le,Y;var oe=p.decode(U,T);T+=p.decode.bytes;var ue=oe>>3;switch(ue){case 1:Y.version=n.varint.decode(U,T),T+=n.varint.decode.bytes;break;case 2:Y.gte=n.bytes.decode(U,T),T+=n.bytes.decode.bytes;break;case 3:Y.gt=n.bytes.decode(U,T),T+=n.bytes.decode.bytes;break;case 4:Y.lte=n.bytes.decode(U,T),T+=n.bytes.decode.bytes;break;case 5:Y.lt=n.bytes.decode(U,T),T+=n.bytes.decode.bytes;break;case 6:Y.limit=n.varint.decode(U,T),T+=n.varint.decode.bytes;break;case 7:Y.reverse=n.bool.decode(U,T),T+=n.bool.decode.bytes;break;case 8:var O=p.decode(U,T);for(T+=p.decode.bytes,O+=T;T<O;)Y.checkpoint.push(n.varint.decode(U,T)),T+=n.varint.decode.bytes;break;default:T=l(oe&7,U,T)}}}}function z(){_.encodingLength=R,_.encode=A,_.decode=q;function R(U){var T=0;if(!m(U.start))throw new Error("start is required");var Q=n.varint.encodingLength(U.start);if(T+=1+Q,!m(U.end))throw new Error("end is required");var Q=n.varint.encodingLength(U.end);if(T+=1+Q,m(U.blocks)){for(var le=0,Y=0;Y<U.blocks.length;Y++)if(m(U.blocks[Y])){var Q=n.varint.encodingLength(U.blocks[Y]);le+=Q}le&&(T+=1+le+p.encodingLength(le))}return T}function A(U,T,Q){Q||(Q=0),T||(T=a.allocUnsafe(R(U)));var le=Q;if(!m(U.start))throw new Error("start is required");if(T[Q++]=8,n.varint.encode(U.start,T,Q),Q+=n.varint.encode.bytes,!m(U.end))throw new Error("end is required");if(T[Q++]=16,n.varint.encode(U.end,T,Q),Q+=n.varint.encode.bytes,m(U.blocks)){for(var Y=0,oe=0;oe<U.blocks.length;oe++)m(U.blocks[oe])&&(Y+=n.varint.encodingLength(U.blocks[oe]));Y&&(T[Q++]=26,p.encode(Y,T,Q),Q+=p.encode.bytes);for(var oe=0;oe<U.blocks.length;oe++)m(U.blocks[oe])&&(n.varint.encode(U.blocks[oe],T,Q),Q+=n.varint.encode.bytes)}return A.bytes=Q-le,T}function q(U,T,Q){if(T||(T=0),Q||(Q=U.length),!(Q<=U.length&&T<=U.length))throw new Error("Decoded message is not valid");for(var le=T,Y={start:0,end:0,blocks:[]},oe=!1,ue=!1;;){if(Q<=T){if(!oe||!ue)throw new Error("Decoded message is not valid");return q.bytes=T-le,Y}var O=p.decode(U,T);T+=p.decode.bytes;var P=O>>3;switch(P){case 1:Y.start=n.varint.decode(U,T),T+=n.varint.decode.bytes,oe=!0;break;case 2:Y.end=n.varint.decode(U,T),T+=n.varint.decode.bytes,ue=!0;break;case 3:var Z=p.decode(U,T);for(T+=p.decode.bytes,Z+=T;T<Z;)Y.blocks.push(n.varint.decode(U,T)),T+=n.varint.decode.bytes;break;default:T=l(O&7,U,T)}}}}o.encodingLength=j,o.encode=v,o.decode=w;function j(R){var A=0;if(m(R.cache)){var q=_.encodingLength(R.cache);A+=p.encodingLength(q),A+=1+q}if(m(R.get)){var q=E.encodingLength(R.get);A+=p.encodingLength(q),A+=1+q}if(m(R.iterator)){var q=b.encodingLength(R.iterator);A+=p.encodingLength(q),A+=1+q}return A}function v(R,A,q){q||(q=0),A||(A=a.allocUnsafe(j(R)));var U=q;return m(R.cache)&&(A[q++]=10,p.encode(_.encodingLength(R.cache),A,q),q+=p.encode.bytes,_.encode(R.cache,A,q),q+=_.encode.bytes),m(R.get)&&(A[q++]=18,p.encode(E.encodingLength(R.get),A,q),q+=p.encode.bytes,E.encode(R.get,A,q),q+=E.encode.bytes),m(R.iterator)&&(A[q++]=26,p.encode(b.encodingLength(R.iterator),A,q),q+=p.encode.bytes,b.encode(R.iterator,A,q),q+=b.encode.bytes),v.bytes=q-U,A}function w(R,A,q){if(A||(A=0),q||(q=R.length),!(q<=R.length&&A<=R.length))throw new Error("Decoded message is not valid");for(var U=A,T={cache:null,get:null,iterator:null};;){if(q<=A)return w.bytes=A-U,T;var Q=p.decode(R,A);A+=p.decode.bytes;var le=Q>>3;switch(le){case 1:var Y=p.decode(R,A);A+=p.decode.bytes,T.cache=_.decode(R,A,A+Y),A+=_.decode.bytes;break;case 2:var Y=p.decode(R,A);A+=p.decode.bytes,T.get=E.decode(R,A,A+Y),A+=E.decode.bytes;break;case 3:var Y=p.decode(R,A);A+=p.decode.bytes,T.iterator=b.decode(R,A,A+Y),A+=b.decode.bytes;break;default:A=l(Q&7,R,A)}}}}function m(E){return E!=null&&(typeof E!="number"||!isNaN(E))}return Ws}var dd,$w;function jS(){if($w)return dd;$w=1;const{Extension:n}=o0(),a=128,p=2048,l=p+a;class g{constructor(s,u){this.blocks=[],this.start=0,this.end=0,this.outgoing=s,this.from=u}push(s){const u=this.blocks.push(s);(u===1||s<this.start)&&(this.start=s),(u===1||s>=this.end)&&(this.end=s+1),u>=a&&(this.send(),this.clear())}send(){this.blocks.length&&this.outgoing.send(n.encode({cache:{blocks:this.blocks,start:this.start,end:this.end}}),this.from)}clear(){this.start=this.end=0,this.blocks=[]}}class y{constructor(s){this.encoding=null,this.outgoing=null,this.db=s,this.active=0}get(s,u){this.outgoing.broadcast(n.encode({get:{version:s,key:u}}))}iterator(s){s.ended||s.limit!==0&&(s.limit===-1&&(s.limit=0),this.outgoing.broadcast(n.encode({iterator:s})))}onmessage(s,u){const f=h(s);f&&(f.cache&&this.oncache(f.cache,u),f.get&&this.onget(f.get,u),f.iterator&&this.oniterator(f.iterator,u))}oncache(s,u){s.blocks.length&&this.db.core.download(s)}onget(s,u){if(!s.version||s.version>this.db.version)return;const f=new g(this.outgoing,u),m=this.db.checkout(s.version);m.get(s.key,{extension:!1,wait:!1,update:!1,onseq:b}).then(E,E);function E(){m.close().catch(o),f.send()}function b(_){f.push(_)}}async oniterator(s,u){if(!s.version||s.version>this.db.version)return;const f=new g(this.outgoing,u),m=new Set;let E=s.checkpoint.length,b=0;const _=this.db.checkout(s.version),B=_.createRangeIterator({...s,wait:!1,extension:!1,update:!1,limit:s.limit===0?-1:s.limit,onseq(M){E&&E--||m.has(M)||(b++,m.add(M),f.push(M))}});try{for(await B.open();b<l&&await B.next(););}catch{}finally{B.close().catch(o),_.close().catch(o),f.send()}}static register(s){const u=new this(s);return u.outgoing=s.core.registerExtension("hyperbee",u),u}}y.BATCH_SIZE=p,dd=y;function h(c){try{return n.decode(c)}catch{return null}}function o(){}return dd}var fd,Jw;function Qf(){if(Jw)return fd;Jw=1;const n=s0(),{Readable:a}=Sn(),p=qv(),l=Ue(),g=jt(),y=Rn(),h=Lv(),o=US(),{all:c}=Xt(),s=OS(),u=PS(),f=IS(),m=jS(),{YoloIndex:E,Node:b,Header:_}=o0(),{BLOCK_NOT_AVAILABLE:B,DECODING_ERROR:M}=Lt(),j=5-1,v=j*2+1,w=l.alloc(1),R=l.alloc(0);class A{constructor(L,V){this.seq=L,this.value=V}}class q{constructor(L,V,te){this.seq=L,this.offset=V,this.value=te}}class U{constructor(L){this.keys=L,this.length=0}get(L){return this.keys.get(L)||null}set(L,V){this.keys.set(L,V),L>=this.length&&(this.length=L+1)}gc(L){if(this.length-L>128)this.keys.clear();else for(let V=L;V<this.length;V++)this.keys.delete(V);this.length=L}}class T{constructor(L){this.levels=L.levels.map(V=>{const te=[],de=[];for(let C=0;C<V.keys.length;C++)de.push(new A(V.keys[C],null));for(let C=0;C<V.children.length;C+=2)te.push(new q(V.children[C],V.children[C+1],null));return{keys:de,children:te}})}get(L){return this.levels[L]}hasKey(L){for(const V of this.levels)for(const te of V.keys)if(te.seq===L)return!0;return!1}}function Q(I){return I.inflated===null&&(I.inflated=E.decode(I.index),I.index=null),new T(I.inflated)}function le(I){const L=I.map(V=>{const te=[],de=[];for(let C=0;C<V.value.keys.length;C++)te.push(V.value.keys[C].seq);for(let C=0;C<V.value.children.length;C++)de.push(V.value.children[C].seq,V.value.children[C].offset);return{keys:te,children:de}});return E.encode({levels:L})}class Y{constructor(L,V,te,de){this.block=L,this.offset=de,this.keys=V,this.children=te,this.changed=!1,this.preload()}preload(){if(this.block===null)return;const L=k(this.block.tree.core);if(!L)return;const V=L.core.bitfield,te=[];for(let de=0;de<this.keys.length;de++){const C=this.keys[de];C.value||C.seq>=L.signedLength||V&&V.get(C.seq)||te.push(C.seq)}for(let de=0;de<this.children.length;de++){const C=this.children[de];C.value||C.seq>=L.signedLength||V&&V.get(C.seq)||te.push(C.seq)}te.length&&L.download({blocks:te})}async insertKey(L,V,te,de,C,ee){let fe=0,ve=this.keys.length,we;for(;fe<ve;){const ne=fe+ve>>1;if(we=l.compare(L.value,await this.getKey(ne)),we===0){if(ee){const ye=await this.getKeyNode(ne);if(!await ee(ye.final(C),de))return!0}if(!this.block.tree.tree.alwaysDuplicate){const ye=await this.getKeyNode(ne);if(X(ye.value,V))return!0}return this.changed=!0,this.keys[ne]=L,!0}we<0?ve=ne:fe=ne+1}const F=we<0?ve:fe;return this.keys.splice(F,0,L),te&&this.children.splice(F+1,0,new q(0,0,te)),this.changed=!0,this.keys.length<v}removeKey(L){this.keys.splice(L,1),this.children.length&&(this.children[L+1].seq=0,this.children.splice(L+1,1)),this.changed=!0}async siblings(L){for(let V=0;V<L.children.length;V++)if(L.children[V].value===this){const[te,de]=await Promise.all([V?L.getChildNode(V-1):null,V<L.children.length-1?L.getChildNode(V+1):null]);return{left:te,index:V,right:de}}throw new Error("Bad parent")}merge(L,V){this.changed=!0,this.keys.push(V);for(let te=0;te<L.keys.length;te++)this.keys.push(L.keys[te]);for(let te=0;te<L.children.length;te++)this.children.push(L.children[te])}async split(){const L=this.keys.length>>1,V=Y.create(this.block);for(;V.keys.length<L;)V.keys.push(this.keys.pop());V.keys.reverse(),await this.getKey(this.keys.length-1);const te=this.keys.pop();if(this.children.length){for(;V.children.length<L+1;)V.children.push(this.children.pop());V.children.reverse()}return this.changed=!0,{left:this,median:te,right:V}}getKeyNode(L){return this.block.tree.getBlock(this.keys[L].seq)}async getChildNode(L){const V=this.children[L];if(V.value)return V.value;const te=V.seq===this.block.seq?this.block:await this.block.tree.getBlock(V.seq);return V.value=te.getTreeNode(V.offset)}setKey(L,V){this.keys[L]=V,this.changed=!0}async getKey(L){const V=this.keys[L];if(V.value)return V.value;const te=V.seq===this.block.seq?this.block.key:await this.block.tree.getKey(V.seq);return V.value=te}indexChanges(L,V){const te=L.push(null)-1;this.changed=!1;for(const de of this.children)!de.value||!de.value.changed||(de.seq=V,de.offset=de.value.indexChanges(L,V),L[de.offset]=de);return te}updateChildren(L,V){for(const te of this.children)!te.value||te.seq!==L||(te.value.block=V,te.value.updateChildren(L,V))}static create(L){const V=new Y(L,[],[],0);return V.changed=!0,V}}class oe{constructor(L,V,te){this.seq=L,this.tree=V,this.index=null,this.entry=te,this.key=te.key,this.value=te.value}isTarget(L){return l.equals(this.key,L)}isDeletion(){return this.value!==null?!1:(this.index===null&&(this.index=Q(this.entry)),!this.index.hasKey(this.seq))}final(L){return{seq:this.seq,key:L.key?L.key.decode(this.key):this.key,value:this.value&&(L.value?L.value.decode(this.value):this.value)}}getTreeNode(L){this.index===null&&(this.index=Q(this.entry));const V=this.index.get(L);return new Y(this,V.keys,V.children,L)}}class ue extends oe{constructor(L,V,te,de,C){super(L,V,{key:te,value:de,index:null,inflated:null}),this.pendingIndex=C}isTarget(L){return!1}getTreeNode(L){return this.pendingIndex[L].value}}class O extends y{constructor(L,V={}){super(),this.feed=L,this.core=L,this.keyEncoding=V.keyEncoding?n(V.keyEncoding):null,this.valueEncoding=V.valueEncoding?n(V.valueEncoding):null,this.extension=V.extension!==!1?V.extension||m.register(this):null,this.metadata=V.metadata||null,this.lock=V.lock||p(),this.sep=V.sep||w,this.readonly=!!V.readonly,this.prefix=V.prefix||null,this.alwaysDuplicate=V.alwaysDuplicate!==!1,this._unprefixedKeyEncoding=this.keyEncoding,this._sub=!!this.prefix,this._checkout=V.checkout||0,this._view=!!V._view,this._onappendBound=this._view?null:this._onappend.bind(this),this._ontruncateBound=this._view?null:this._ontruncate.bind(this),this._watchers=this._onappendBound?[]:null,this._entryWatchers=this._onappendBound?[]:null,this._sessions=V.sessions!==!1,this._keyCache=null,this._nodeCache=null,this._batches=[],this._watchers&&(this.core.on("append",this._onappendBound),this.core.on("truncate",this._ontruncateBound)),this.prefix&&V._sub&&(this.keyEncoding=ce(this.prefix,this.keyEncoding)),this.ready().catch(g)}async _open(){this.core.opened===!1&&await this.core.ready(),this._checkout===-1&&(this._checkout=Math.max(1,this.core.length));const L=o.from(this.core.globalCache);this._keyCache=new U(L),this._nodeCache=new U(o.from(L))}get version(){return Math.max(1,this._checkout||this.core.length)}get id(){return this.core.id}get key(){return this.core.key}get discoveryKey(){return this.core.discoveryKey}get writable(){return this.core.writable}get readable(){return this.core.readable}replicate(L,V){return this.core.replicate(L,V)}update(L){return this.core.update(L)}peek(L,V){return N(this.createRangeIterator(L,{...V,limit:1}))}createRangeIterator(L,V={}){V=V?{...V,...L}:L;const te=V.extension===!1&&V.limit!==0?null:this.extension,de=V.keyEncoding?n(V.keyEncoding):this.keyEncoding;if(te){const{onseq:ee,onwait:fe}=V;let ve=0,we=0;V=D(de,{...V,sub:this._sub,onseq(F){ve||(ve=F+1),we&&we--,ee&&ee(F)},onwait(F){we||(we=m.BATCH_SIZE,te.iterator(C.snapshot(ve))),fe&&fe(F)}})}else V=D(de,{...V,sub:this._sub});const C=new s(new P(this,this._makeSnapshot(),null,!1,V),null,V);return C}createReadStream(L,V){const te=V&&V.signal||null;return S(this.createRangeIterator(L,V),te)}createHistoryStream(L){const V=L&&L.live?this.core.session():this._makeSnapshot(),te=L&&L.signal||null;return S(new u(new P(this,V,null,!1,L),L),te)}createDiffStream(L,V,te){typeof L=="number"&&(L=this.checkout(Math.max(1,L),{reuseSession:!0})),te=te?{...te,...V}:V;const de=te&&te.signal||null,C=te&&te.keyEncoding?n(te.keyEncoding):this.keyEncoding;C&&(te=D(C,{...te,sub:this._sub}));let ee,fe,ve;const we=this,F=new a({signal:de,eagerOpen:!0,async open(me){try{L.opened===!1&&await L.ready(),we.opened===!1&&await we.ready()}catch(qe){me(qe);return}if(fe){me(null);return}if(we.core.closing||L.core.closing){me(new Error("Bee closed"));return}const Ee=L.version>we.version?L._makeSnapshot():we._makeSnapshot();ee=me,ve=new f(new P(we,Ee,null,!1,te),new P(L,Ee,null,!1,te),te),ve.open().then(ne,ne)},read(me){ee=me,ve.next().then(ye,ne)},predestroy(){ve?(fe=ve.close(),fe.catch(ie)):fe=Promise.resolve()},destroy(me){ee=me,fe||(fe=ve.close()),fe.then(ne,ne)}});return F;function ne(me){ee(me)}function ye(me){F.push(me),ee(null)}}get(L,V){return new P(this,this._makeSnapshot(),null,!0,V).get(L)}getBySeq(L,V){return new P(this,this._makeSnapshot(),null,!0,V).getBySeq(L)}put(L,V,te){return new P(this,this.core,null,!0,te).put(L,V,te)}batch(L){return new P(this,this.core,p(),!0,L)}del(L,V){return new P(this,this.core,null,!0,V).del(L,V)}watch(L,V){if(!this._watchers)throw new Error("Can only watch the main bee instance");return new he(this,L,V)}async getAndWatch(L,V){if(!this._watchers)throw new Error("Can only watch the main bee instance");const te=new Z(this,L,V);if(await te._debouncedUpdate(),this.closing)throw await te.close(),new Error("Bee closed");return te}_onappend(){for(const L of this._watchers)L._onappend();for(const L of this._entryWatchers)L._onappend()}_ontruncate(L){for(const V of this._watchers)V._ontruncate();for(const V of this._entryWatchers)V._ontruncate();this._nodeCache.gc(L),this._keyCache.gc(L)}_makeSnapshot(){return this._sessions===!1?this.core:this._checkout<=this.core.length||this._checkout<=1?this.core.snapshot():this.core.session({snapshot:!1})}checkout(L,V={}){L===0&&(L=1);const te=V.reuseSession||this._sessions===!1?this.core:L<=this.core.length||L<=1?this.core.snapshot():this.core.session({snapshot:!1});return new O(te,{_view:!0,_sub:!1,prefix:this.prefix,sep:this.sep,lock:this.lock,checkout:L,keyEncoding:V.keyEncoding||this.keyEncoding,valueEncoding:V.valueEncoding||this.valueEncoding,extension:this.extension!==null?this.extension:!1})}snapshot(L){return this.checkout(this.core.opened===!1||this._checkout<=0?-1:Math.max(1,this.version),L)}sub(L,V={}){let te=V.sep||this.sep;l.isBuffer(te)||(te=l.from(te)),L=l.concat([this.prefix||R,l.from(L),te]);const de=n(V.valueEncoding||this.valueEncoding),C=n(V.keyEncoding||this._unprefixedKeyEncoding);return new O(this.core,{_view:!0,_sub:!0,prefix:L,sep:this.sep,lock:this.lock,checkout:this._checkout,valueEncoding:de,keyEncoding:C,extension:this.extension!==null?this.extension:!1,metadata:this.metadata})}async getHeader(L){const V=await this.core.get(0,L);try{return V&&_.decode(V)}catch{throw M()}}async _close(){if(this._watchers)for(this.core.off("append",this._onappendBound),this.core.off("truncate",this._ontruncateBound);this._watchers.length;)await this._watchers[this._watchers.length-1].close();if(this._entryWatchers)for(;this._entryWatchers.length;)await this._entryWatchers[this._entryWatchers.length-1].close();for(;this._batches.length;)await this._batches[this._batches.length-1].close();return this.core.close()}static async isHyperbee(L,V){await L.ready();const te=await L.get(0,V);if(te===null)throw B();try{return _.decode(te).protocol==="hyperbee"}catch{return!1}}}class P{constructor(L,V,te,de,C={}){this.tree=L,this.feed=V,this.core=V,this.index=L._batches.push(this)-1,this.blocks=de?new Map:null,this.autoFlush=!te,this.rootSeq=0,this.root=null,this.length=0,this.checkout=C.checkout===void 0?-1:C.checkout,this.options=C,this.locked=null,this.batchLock=te,this.onseq=this.options.onseq||ie,this.appending=null,this.isSnapshot=this.core!==this.tree.core,this.shouldUpdate=this.options.update!==!1,this.updating=null,this.encoding={key:C.keyEncoding?n(C.keyEncoding):L.keyEncoding,value:C.valueEncoding?n(C.valueEncoding):L.valueEncoding}}async ready(){this.core.opened===!1&&await this.core.ready(),this.tree.opened===!1&&await this.tree.ready()}async lock(){if(this.tree.readonly)throw new Error("Hyperbee is marked as read-only");this.locked===null&&(this.locked=await this.tree.lock())}get version(){return this.checkout!==-1?Math.max(1,this.checkout):Math.max(1,this.tree._checkout||this.core.length+this.length)}async getRoot(L){return await this.ready(),L&&this.core.length===0&&this.core.writable&&!this.tree.readonly&&await this.core.append(_.encode({protocol:"hyperbee",metadata:this.tree.metadata})),this.tree._checkout===0&&this.checkout===-1&&this.shouldUpdate&&(this.updating===null&&(this.updating=this.core.update()),await this.updating),this.version<2?null:(await this.getBlock(this.version-1)).getTreeNode(0)}async getKey(L){const V=this.core.fork===this.tree.core.fork?this.tree._keyCache.get(L):null;if(V!==null)return V;const te=(await this.getBlock(L)).key;return this.core.fork===this.tree.core.fork&&this.tree._keyCache.set(L,te),te}async _getNode(L){const V=this.tree._nodeCache!==null&&this.core.fork===this.tree.core.fork?this.tree._nodeCache.get(L):null;if(V!==null)return V;const te=await this.core.get(L,{...this.options,valueEncoding:b});if(te===null)throw B();const de=J(te);return this.core.fork===this.tree.core.fork&&this.tree._nodeCache!==null&&this.tree._nodeCache.set(L,de),de}async getBlock(L){this.rootSeq===0&&(this.rootSeq=L);let V=this.blocks&&this.blocks.get(L);if(V)return V;this.onseq(L);const te=await this._getNode(L);return V=new oe(L,this,te),this.blocks&&this.blocks.size-this.length<128&&this.blocks.set(L,V),V}_onwait(L){this.options.onwait=null,this.tree.extension.get(this.rootSeq+1,L)}_getEncoding(L){return L?{key:L.keyEncoding?n(L.keyEncoding):this.encoding.key,value:L.valueEncoding?n(L.valueEncoding):this.encoding.value}:this.encoding}peek(L,V){return N(this.createRangeIterator(L,{...V,limit:1}))}createRangeIterator(L,V={}){V=V?{...V,...L}:L;const te=this._getEncoding(V);return new s(this,te,D(te.key,{...V,sub:this.tree._sub}))}createReadStream(L,V){const te=V&&V.signal||null;return S(this.createRangeIterator(L,V),te)}async getBySeq(L,V){const te=this._getEncoding(V);try{const de=(await this.getBlock(L)).final(te);return{key:de.key,value:de.value}}finally{await this._closeSnapshot()}}async get(L,V){const te=this._getEncoding(V);try{return await this._get(L,te)}finally{await this._closeSnapshot()}}async _get(L,V){L=_e(V.key,L),this.tree.extension!==null&&this.options.extension!==!1&&(this.options.onwait=this._onwait.bind(this,L));let te=await this.getRoot(!1);if(!te)return null;for(;;){if(te.block.isTarget(L))return te.block.isDeletion()?null:te.block.final(V);let de=0,C=te.keys.length,ee;for(;de<C;){const ve=de+C>>1;if(ee=l.compare(L,await te.getKey(ve)),ee===0)return(await this.getBlock(te.keys[ve].seq)).final(V);ee<0?C=ve:de=ve+1}if(!te.children.length)return null;const fe=ee<0?C:de;te=await te.getChildNode(fe)}}async put(L,V,te){const de=this.batchLock?await this.batchLock():null,C=te&&te.cas||null,ee=this._getEncoding(te);if(this.locked||await this.lock(),!de)return this._put(L,V,ee,C);try{return await this._put(L,V,ee,C)}finally{de()}}async _put(L,V,te,de){const C={seq:0,key:L,value:V};L=_e(te.key,L),V=_e(te.value,V);const ee=[];let fe,ve=fe=await this.getRoot(!0);ve||(ve=fe=Y.create(null));const we=C.seq=this.core.length+this.length,F=new A(we,L);for(;ve.children.length;){ee.push(ve),ve.changed=!0;let ye=0,me=ve.keys.length,Ee;for(;ye<me;){const Oe=ye+me>>1;if(Ee=l.compare(F.value,await ve.getKey(Oe)),Ee===0){if(de){const Pe=await ve.getKeyNode(Oe);if(!await de(Pe.final(te),C))return this._unlockMaybe()}if(!this.tree.alwaysDuplicate){const Pe=await ve.getKeyNode(Oe);if(X(Pe.value,V))return this._unlockMaybe()}return ve.setKey(Oe,F),this._append(fe,we,L,V)}Ee<0?me=Oe:ye=Oe+1}const qe=Ee<0?me:ye;ve=await ve.getChildNode(qe)}let ne=!await ve.insertKey(F,V,null,C,te,de);if(!ve.changed)return this._unlockMaybe();for(;ne;){const ye=ee.pop(),{median:me,right:Ee}=await ve.split();ye?(ne=!await ye.insertKey(me,V,Ee,null,te,null),ve=ye):(fe=Y.create(ve.block),fe.changed=!0,fe.keys.push(me),fe.children.push(new q(0,0,ve),new q(0,0,Ee)),ne=!1)}return this._append(fe,we,L,V)}async del(L,V){const te=this.batchLock?await this.batchLock():null,de=V&&V.cas||null,C=this._getEncoding(V);if(this.locked||await this.lock(),!te)return this._del(L,C,de);try{return await this._del(L,C,de)}finally{te()}}async _del(L,V,te){const de={seq:0,key:L,value:null};L=_e(V.key,L);const C=[];let ee=await this.getRoot(!0);if(!ee)return this._unlockMaybe();const fe=de.seq=this.core.length+this.length;for(;;){C.push(ee);let ve=0,we=ee.keys.length,F;for(;ve<we;){const ye=ve+we>>1;if(F=l.compare(L,await ee.getKey(ye)),F===0){if(te){const me=await ee.getKeyNode(ye);if(!await te(me.final(V),de))return this._unlockMaybe()}ee.children.length?await W(ee,ye,C):ee.removeKey(ye);for(const me of C)me.changed=!0;return this._append(await $(C),fe,L,null)}F<0?we=ye:ve=ye+1}if(!ee.children.length)return this._unlockMaybe();const ne=F<0?we:ve;ee=await ee.getChildNode(ne)}}async _closeSnapshot(){this.isSnapshot&&(await this.core.close(),this._finalize())}async close(){if(this.isSnapshot)return this._closeSnapshot();this.root=null,this.blocks&&this.blocks.clear(),this.length=0,this._unlock()}destroy(){this.close().catch(ie)}toBlocks(){if(this.appending)return this.appending;const L=new Array(this.length);for(let V=0;V<this.length;V++){const te=this.core.length+V,{pendingIndex:de,key:C,value:ee}=this.blocks.get(te);if(V<this.length-1){de[0]=null;let fe=0;for(;fe<de.length;){const ve=de[fe];if(ve!==null&&ve.seq===te){ve.offset=fe++;continue}fe===de.length-1?de.pop():de[fe]=de.pop()}}L[V]=b.encode({key:C,value:ee,index:le(de)})}return this.appending=L,L}flush(){if(!this.length)return this.close();const L=this.toBlocks();return this.root=null,this.blocks.clear(),this.length=0,this._appendBatch(L)}_unlockMaybe(){this.autoFlush&&this._unlock()}_unlock(){const L=this.locked;this.locked=null,L!==null&&L(),this._finalize()}_finalize(){if(this.index>=this.tree._batches.length||this.tree._batches[this.index]!==this)return;const L=this.tree._batches.pop();L!==this&&(L.index=this.index,this.tree._batches[L.index]=L)}_append(L,V,te,de){const C=[];if(L.indexChanges(C,V),C[0]=new q(V,0,L),!this.autoFlush){const ee=new ue(V,this,te,de,C);L.block=ee,this.root=L,this.length++,this.blocks.set(V,ee),L.updateChildren(V,ee);return}return this._appendBatch(b.encode({key:te,value:de,index:le(C)}))}async _appendBatch(L){try{await this.core.append(L)}finally{this._unlock()}}}class Z extends y{constructor(L,V,te={}){super(),this.keyEncoding=te.keyEncoding||L.keyEncoding,this.valueEncoding=te.valueEncoding||L.valueEncoding,this.index=L._entryWatchers.push(this)-1,this.bee=L,this.key=V,this.node=null,this._forceUpdate=!1,this._debouncedUpdate=h(this._processUpdate.bind(this))}_close(){const L=this.bee._entryWatchers.pop();L!==this&&(L.index=this.index,this.bee._entryWatchers[L.index]=L)}_onappend(){this._debouncedUpdate()}_ontruncate(){this._forceUpdate=!0,this._debouncedUpdate()}async _processUpdate(){const L=this._forceUpdate;this._forceUpdate=!1;let V;try{V=await this.bee.get(this.key,{keyEncoding:this.keyEncoding,valueEncoding:this.valueEncoding})}catch(te){if(te.code==="SNAPSHOT_NOT_AVAILABLE")return;if(this.bee.closing){this.close().catch(g);return}this.emit("error",te);return}(L||V?.seq!==this.node?.seq)&&(this.node=V,this.emit("update"))}}class he extends y{constructor(L,V,te={}){super(),this.keyEncoding=te.keyEncoding||L.keyEncoding,this.valueEncoding=te.valueEncoding||L.valueEncoding,this.index=L._watchers.push(this)-1,this.bee=L,this.core=L.core,this.latestDiff=0,this.range=V,this.map=te.map||G,this.current=null,this.previous=null,this.currentMapped=null,this.previousMapped=null,this.stream=null,this._lock=p(),this._flowing=!1,this._resolveOnChange=null,this._differ=te.differ||d,this._eager=!!te.eager,this._onchange=te.onchange||null,this.on("newListener",se),this.ready().catch(g)}async _consume(){if(!this._flowing)try{for await(const L of this);}catch{}}async _open(){await this.bee.ready();const L={keyEncoding:this.keyEncoding,valueEncoding:this.valueEncoding};this.current=this._eager?this.bee.checkout(1,L):this.bee.snapshot(L),await this.current.ready(),this._onchange&&(this._eager&&await this._onchange(),this._consume())}[Symbol.asyncIterator](){return this._flowing=!0,this}_ontruncate(){this._onappend()}_onappend(){const L=this._resolveOnChange;this._resolveOnChange=null,L&&L()}async _waitForChanges(){this.current.version<this.bee.version||this.closing||await new Promise(L=>{this._resolveOnChange=L})}async next(){try{return await this._next()}catch(L){if(this.closing)return{value:void 0,done:!0};throw await this.close(),L}}async _next(){const L=await this._lock();try{if(this.closing)return{value:void 0,done:!0};for(this.opened||await this.ready();;){if(await this._waitForChanges(),this.closing)return{value:void 0,done:!0};if(await this._closePrevious(),this.previous=this.current.snapshot(),await this._closeCurrent(),this.current=this.bee.snapshot({keyEncoding:this.keyEncoding,valueEncoding:this.valueEncoding}),await this.current.ready(),await this.previous.ready(),this.current.core.fork!==this.previous.core.fork)return await this._yield();this.stream=this._differ(this.current,this.previous,this.range);try{for await(const V of this.stream)return await this._yield()}finally{this.stream=null}}}finally{L()}}async _yield(){if(this.currentMapped=this.map(this.current),this.previousMapped=this.map(this.previous),this._onchange)try{await this._onchange()}catch(L){g(L)}return this.emit("update"),{done:!1,value:[this.currentMapped,this.previousMapped]}}async return(){return await this.close(),{done:!0}}async _close(){const L=this.bee._watchers.pop();L!==this&&(L.index=this.index,this.bee._watchers[L.index]=L),this.stream&&!this.stream.destroying&&this.stream.destroy(),this._onappend(),await this._closeCurrent().catch(g),await this._closePrevious().catch(g),(await this._lock())()}destroy(){return this.close()}async _closeCurrent(){this.currentMapped&&await this.currentMapped.close(),this.current&&await this.current.close(),this.current=this.currentMapped=null}async _closePrevious(){this.previousMapped&&await this.previousMapped.close(),this.previous&&await this.previous.close(),this.previous=this.previousMapped=null}}function se(I){I==="update"&&this._consume()}function G(I){return I}async function re(I,L){for(;I.children.length;)I=await I.getChildNode(L?0:I.children.length-1);return I.keys.length}async function W(I,L,V){let[te,de]=await Promise.all([I.getChildNode(L),I.getChildNode(L+1)]);const[C,ee]=await Promise.all([re(te,!1),re(de,!0)]);if(C<ee){for(V.push(de);de.children.length;)V.push(de=de.children[0].value);I.keys[L]=de.keys.shift()}else{for(V.push(te);te.children.length;)V.push(te=te.children[te.children.length-1].value);I.keys[L]=te.keys.pop()}}async function $(I){const L=I[0];for(;I.length>1;){const V=I.pop(),te=I[I.length-1];if(V.keys.length>=j)return L;let{left:de,index:C,right:ee}=await V.siblings(te);if(de&&de.keys.length>j)return de.changed=!0,V.keys.unshift(te.keys[C-1]),de.children.length&&V.children.unshift(de.children.pop()),te.keys[C-1]=de.keys.pop(),L;if(ee&&ee.keys.length>j)return ee.changed=!0,V.keys.push(te.keys[C]),ee.children.length&&V.children.push(ee.children.shift()),te.keys[C]=ee.keys.shift(),L;de?(C--,ee=V):de=V,de.merge(ee,te.keys[C]),te.removeKey(C)}return!L.keys.length&&L.children.length?L.getChildNode(0):L}function S(I,L){let V,te;const de=new a({signal:L,open(fe){V=fe,I.open().then(C,C)},read(fe){V=fe,I.next().then(ee,C)},predestroy(){te=I.close(),te.catch(ie)},destroy(fe){V=fe,te||(te=I.close()),te.then(C,C)}});return de;function C(fe){V(fe)}function ee(fe){de.push(fe),V(null)}}async function N(I){try{return await I.open(),await I.next()}finally{await I.close()}}function D(I,L){if(!I)return L;if(I.encodeRange){const V=I.encodeRange({gt:L.gt,gte:L.gte,lt:L.lt,lte:L.lte});return L.gt=V.gt,L.gte=V.gte,L.lt=V.lt,L.lte=V.lte,L}return L.gt!==void 0&&(L.gt=_e(I,L.gt)),L.gte!==void 0&&(L.gte=_e(I,L.gte)),L.lt!==void 0&&(L.lt=_e(I,L.lt)),L.lte!==void 0&&(L.lte=_e(I,L.lte)),L.sub&&!L.gt&&!L.gte&&(L.gt=_e(I,w)),L.sub&&!L.lt&&!L.lte&&(L.lt=H(_e(I,R))),L}function H(I){return I[I.length-1]++,I}function _e(I,L){return L==null?null:I!==null?I.encode(L):typeof L=="string"?l.from(L):L}function ce(I,L){return{encode(V){return l.concat([I,l.isBuffer(V)?V:_e(L,V)])},decode(V){const te=V.slice(I.length,V.length);return L?L.decode(te):te}}}function J(I){let L=I.key,V=I.value,te=I.index;if(2*(L.byteLength+(V===null?0:V.byteLength)+(te===null?0:te.byteLength))<L.buffer.byteLength){const[C,ee,fe]=c([I.key,I.value,I.index]);L=C,V=ee,te=fe}return{key:L,value:V,index:te,inflated:null}}function d(I,L,V){return I.createDiffStream(L,V)}function k(I){return I.core?I:I.getBackingCore?I.getBackingCore().session:null}function X(I,L){return I===L||I!==null&&L!==null&&l.equals(I,L)}function ie(){}return fd=O,fd}var gd,eb;function l0(){if(eb)return gd;eb=1;const n=s0(),a=Ue(),p=a.alloc(1),l=a.from([1]),g=a.alloc(0);gd=class a0{constructor(c,s,u=null){this.userEncoding=n(s),this.prefix=c!=null?y(c,u):null,this.lt=this.prefix&&a.concat([this.prefix.subarray(0,this.prefix.byteLength-1),l])}_encodeRangeUser(c){if(this.userEncoding.encodeRange)return this.userEncoding.encodeRange(c);const s={};return c.gt!=null&&(s.gt=this.userEncoding.encode(c.gt)),c.gte!=null&&(s.gte=this.userEncoding.encode(c.gte)),c.lte!=null&&(s.lte=this.userEncoding.encode(c.lte)),c.lt!=null&&(s.lt=this.userEncoding.encode(c.lt)),s}_addPrefix(c){return this.prefix?a.concat([this.prefix,c]):c}encode(c){return this._addPrefix(this.userEncoding.encode(c))}encodeRange(c){const s=this._encodeRangeUser(c);return s.gt?s.gt=this._addPrefix(s.gt):s.gte?s.gte=this._addPrefix(s.gte):this.prefix&&(s.gte=this.prefix),s.lt?s.lt=this._addPrefix(s.lt):s.lte?s.lte=this._addPrefix(s.lte):this.prefix&&(s.lt=this.lt),s}decode(c){return this.userEncoding.decode(this.prefix?c.subarray(this.prefix.byteLength):c)}sub(c,s){return new a0(c||g,h(s),this.prefix)}};function y(o,c){return o=typeof o=="string"?a.from(o):o,o&&c?a.concat([c,o,p]):o?a.concat([o,p]):c?a.concat([c,p]):p}function h(o){return o&&o.keyEncoding?o.keyEncoding:o}return gd}var pd,tb;function yo(){if(tb)return pd;tb=1;const n=_t(),a=2,p=1,l=2,g=3,[y,h,o,c]=n.namespace("autobase",4);return pd={OPLOG_VERSION:a,DEFAULT_AUTOBASE_VERSION:p,MAX_AUTOBASE_VERSION:l,BOOT_RECORD_VERSION:g,NS_SIGNER_NAMESPACE:y,NS_VIEW_BLOCK_KEY:h,NS_HASH_KEY:o,NS_ENCRYPTION:c},pd}var yd,nb;function _o(){if(nb)return yd;nb=1;const n=Qf(),a=l0(),p=Rn(),l=Ue(),g=et(),y=_t(),{Info:h,Member:o}=ni(),{DEFAULT_AUTOBASE_VERSION:c}=yo(),s=new a,u=s.sub(l.from([0])),f=s.sub(l.from([1])),m=u.encode("info"),[E,b]=y.namespace("autobase/entropy",2);yd=class nl extends p{constructor(w,{checkout:R=0,empty:A=!1}={}){super(),this.core=w,this.db=new n(w,{keyEncoding:"binary",extension:!1,checkout:R,sessions:typeof w.session=="function"}),this.version=c,this.members=0,this.pendingIndexers=[],this.indexers=[],this.heads=[],this.views=[],this.encryptionLength=0,this.entropy=null,this.indexerUpdate=!1,this._empty=A,this._fork=0,this._length=0,this._changes=[],this._indexerMap=new Map,this._clockUpdates=new Map}static GENESIS_ENTROPY=E;static async getIndexedInfo(w,R){const A=new this(w.session());try{return await A.getIndexedInfo(R)}finally{await A.close()}}static async*flushes(w,{reverse:R,lt:A=w.length,gte:q=0,wait:U=!0}={}){if(A<=0)return;await w.get(A-1);const T=new nl(w);try{for await(const Q of T.db.createHistoryStream({lt:A,gte:q,wait:U,reverse:!0})){if(!l.equals(Q.key,m))continue;const le=g.decode(h,Q.value);yield{length:Q.seq+1,info:le}}}finally{await T.close()}}get bootstrapping(){return this.members===0}async checkout(w){const R=new nl(this.core.session(),{checkout:w,empty:w===0});return await R.ready(),R}async _open(){const w=this._empty?null:await this.db.get("info",{valueEncoding:h,keyEncoding:u,update:!1,wait:!1});await this._reset(w)}async _close(){await this.db.close()}async getIndexedInfo(w=this.core.signedLength){if(this.opened===!1&&await this.ready(),w===this.core.length)return{version:this.version,members:this.members,pendingIndexers:this.pendingIndexers,indexers:this.indexers,heads:this.heads,views:this.views,encryptionLength:this.encryptionLength,entropy:this.entropy};const R=w===0?null:await this.db.getBySeq(w-1);return R===null?{version:c,members:0,pendingIndexers:[],indexers:[],heads:[],views:[],encryptionLength:0,entropy:null}:g.decode(h,R.value)}static sameIndexers(w,R){if(w.length!==R.length)return!1;for(let A=0;A<w.length;A++)if(!l.equals(w[A].key,R[A].core.key))return!1;return!0}sameIndexers(w){return nl.sameIndexers(this.indexers,w)}async history(w){const R=this.db.checkout(w),A=new Map,q=[],U=[],T=w===0?null:await this.db.getBySeq(w-1);let Q=T===null?null:g.decode(h,T.value),le=0;for await(const Y of this.db.createHistoryStream({gte:w})){if(l.equals(Y.key,m)){const he=g.decode(h,Y.value);U.push({batch:le,indexers:Q===null||!M(he,Q),systemLength:Y.seq+1}),Q=he,le=0;continue}const oe=Y.key.subarray(2),ue=l.toString(oe,"hex"),O=g.decode(o,Y.value).length;if(!A.has(ue)){const he=await R.get(Y.key);if(he===null)A.set(ue,0);else{const{length:se}=g.decode(o,he.value);A.set(ue,se)}}const P=A.get(ue),Z=O-P;if(A.set(ue,O),Z!==0){if(le+=Z,q.length>0){const he=q[q.length-1];if(l.equals(he.key,oe)){he.length=O,he.batch+=Z;continue}}q.push({key:oe,length:O,batch:Z})}}return await R.close(),{updates:U,nodes:q}}async update(){return this.opened===!1&&await this.ready(),this._fork===this.core.fork&&this._length===this.core.length?!1:(await this._reset(this._empty?null:await this.db.get("info",{valueEncoding:h,keyEncoding:u})),!0)}async _reset(w){this.version=w===null?c:w.value.version,this.members=w===null?0:w.value.members,this.pendingIndexers=w===null?[]:w.value.pendingIndexers,this.indexers=w===null?[]:w.value.indexers,this.heads=w===null?[]:w.value.heads,this.views=w===null?[]:w.value.views,this.encryptionLength=w===null?0:w.value.encryptionLength,this.entropy=w===null?null:w.value.entropy,this.indexerUpdate=!1,this._indexerMap.clear(),this._clockUpdates.clear(),this._length=this.core.length,this._fork=this.core.fork,this._changes=[];for(const R of this.indexers)this._indexerMap.set(l.toString(R.key,"hex"),R)}flushLength(){const w=this.core.length?0:1;let R=this._changes.length+this._clockUpdates.size;for(const{key:A}of this._changes){const q=l.toString(A,"hex");this._clockUpdates.has(q)&&R--}return w+this.core.length+R+1}async flush(w){const R=this.db.batch({update:!1});for(let U=0;U<this._changes.length;U++){const T=this._changes[U];this._clockUpdates.has(l.toString(T.key,"hex"))||await R.put(T.key,T.value,{valueEncoding:o,keyEncoding:f})}for(const[U,T]of this._clockUpdates){const Q=this._indexerMap.get(U)!==void 0,le=l.from(U,"hex"),Y=await this._get(le,0),oe={isIndexer:Q,isRemoved:Y?Y.isRemoved:!0,length:T};await R.put(le,oe,{valueEncoding:o,keyEncoding:f})}this.indexerUpdate&&this._refreshEntropy(this.core.length+R.length+1),this._clockUpdates.clear();let A=-1;for(const U of w)U.mappedIndex>A&&(A=U.mappedIndex);for(;this.views.length>A+1;)this.views.pop();for(const U of w){const T=U.core?U.core.length:U.length;if(!T)continue;const Q={key:U.key,length:T};U.mappedIndex!==-1?this.views[U.mappedIndex]=Q:U.mappedIndex=this.views.push(Q)-1}const q={version:this.version,members:this.members,pendingIndexers:this.pendingIndexers,indexers:this.indexers,heads:this.heads,views:this.views,encryptionLength:this.encryptionLength,entropy:this.entropy};await R.put("info",q,{valueEncoding:h,keyEncoding:u}),await R.flush(),this._length=this.core.length,this._changes=[],this.indexerUpdate&&(this.indexerUpdate=!1)}getEntropy(w,R){return j(w,R,this.entropy)}_refreshEntropy(w){this.version<2||(this.entropy=this.getEntropy(this.indexers,w))}checkpoint(){return{version:this.version,members:this.members,pendingIndexers:this.pendingIndexers.slice(0),indexers:z(this.indexers),heads:z(this.heads),views:z(this.views),indexerUpdate:this.indexerUpdate,encryptionLength:this.encryptionLength,entropy:this.entropy?l.from(this.entropy):null,changes:this._changes.slice(0),clockUpdates:new Map([...this._clockUpdates])}}applyCheckpoint(w){this.version=w.version,this.members=w.members,this.pendingIndexers=w.pendingIndexers,this.indexers=w.indexers,this.heads=w.heads,this.views=w.views,this.indexerUpdate=w.indexerUpdate,this.encryptionLength=w.encryptionLength,this.entropy=w.entropy,this._changes=w.changes,this._clockUpdates=w.clockUpdates,this._indexerMap=new Map;for(const R of this.indexers)this._indexerMap.set(l.toString(R.key,"hex"),R)}addHead(w){const R={key:w.writer.core.key,length:w.length};for(let U=0;U<this.heads.length;U++){const T=this.heads[U];if(!_(w,T)){if(!l.equals(w.writer.core.key,T.key))continue;if(T.length>R.length)return!1}const Q=this.heads.pop();Q!==T&&(this.heads[U--]=Q)}this.heads.push(R);const A=l.toString(R.key,"hex");if(this._clockUpdates.set(A,R.length),this.pendingIndexers.length>0){for(let U=0;U<this.pendingIndexers.length;U++)if(l.equals(this.pendingIndexers[U],R.key))return this._updateIndexer(R.key,R.length,!0,U),!0}const q=this._indexerMap.get(A);return q!==void 0&&(q.length=R.length),!1}_updateIndexer(w,R,A,q){const U=l.toString(w,"hex");if(!A){const Q=this._indexerMap.get(U);Q&&(this.indexerUpdate=!0,this.indexers.splice(this.indexers.indexOf(Q),1),this._indexerMap.delete(U));return}for(;q<this.pendingIndexers.length&&!l.equals(this.pendingIndexers[q],w);q++);if(R===0){q>=this.pendingIndexers.length&&this.pendingIndexers.push(w);return}if(q<this.pendingIndexers.length){const Q=this.pendingIndexers.pop();q<this.pendingIndexers.length&&(this.pendingIndexers[q]=Q)}const T=this._indexerMap.get(U);if(T===void 0){const Q={key:w,length:R};this._indexerMap.set(U,Q),this.indexers.push(Q),this.bootstrapping||(this.indexerUpdate=!0)}else T.length=R}_seenLength(w){return this._clockUpdates.get(l.toString(w,"hex"))||0}async ack(w){const R=await this._get(w,0),A=this._seenLength(w);if(R&&R.length===A)return;const q=R?R.isIndexer:!1,U=R?R.isRemoved:!0;this._changes.push({key:w,value:{isIndexer:q,isRemoved:U,length:A}})}async add(w,{isIndexer:R=!1,length:A=this._seenLength(w)}={}){let q=null,U=!1,T=!0;for(let Y=this._changes.length-1;Y>=0;Y--){const oe=this._changes[Y];if(l.equals(w,oe.key)){q=oe.value,U=!0;break}}if(!U){const Y=await this.db.get(w,{valueEncoding:o,keyEncoding:f});Y&&(q=Y.value,U=!0)}let Q=!1,le=!1;U&&(q.isRemoved||(Q=!0),q.isIndexer&&(le=!0),A<q.length&&(A=q.length),q.length===A&&q.isIndexer===R&&q.isRemoved===!1&&(T=!1)),T&&this._changes.push({key:w,value:{isIndexer:R,isRemoved:!1,length:A}}),Q||this.members++,(le||R)&&this._updateIndexer(w,A,R,0)}async remove(w){let R=!1;for(const le of this.indexers)if(R=l.equals(le.key,w),R)break;R&&this._updateIndexer(w,null,!1,0);let A=null,q=!1;for(let le=this._changes.length-1;le>=0;le--){const Y=this._changes[le];if(l.equals(w,Y.key)){A=Y.value,q=!0;break}}if(!q){const le=await this.db.get(w,{valueEncoding:o,keyEncoding:f});le&&(A=le.value,q=!0)}const U=!q||!A.isRemoved,T=q&&!A.isRemoved,Q=q?A.length:0;return U&&this._changes.push({key:w,value:{isIndexer:!1,isRemoved:!0,length:Q}}),T&&this.members--,R}async linkable(w,R){const A=this._seenLength(w);if(A>0)return R>A;const q=await this._get(w,0),U=q?q.length:0;return R>U}async has(w,R){return await this.get(w,R)!==null}async _get(w,R){let A=null,q=!1;for(let U=this._changes.length-1;U>=0;U--){const T=this._changes[U];if(l.equals(w,T.key)){A=T.value,q=!0;break}}if(!q){const U=await this.db.get(w,{timeout:R,valueEncoding:o,keyEncoding:f});U&&(A=U.value,q=!0)}return q?A:null}async get(w,R={}){if(this._empty)return null;let A=await this._get(w,R.timeout||0);if(R.unflushed){const q=l.toString(w,"hex");for(let U=this._changes.length-1;U>=0;U--){const T=this._changes[U];l.equals(T.key,w)&&(A=T.value)}this._clockUpdates.has(q)&&(A.length=this._clockUpdates.get(q))}return R.onlyActive!==!1||!A.isRemoved?A:null}async hasLocal(w){if(this._empty)return!1;try{return await this.db.get(w,{valueEncoding:o,keyEncoding:f,update:!1,wait:!1})!==null}catch{return!1}}async getLocalLength(w){if(this._empty)return 0;try{const R=await this.db.get(w,{valueEncoding:o,keyEncoding:f,update:!1,wait:!1});return R===null?0:R.value.length}catch{return 0}}list(){return this.db.createReadStream({valueEncoding:o,keyEncoding:f})}async isIndexed(w,R){const A=this.db.checkout(this.core.indexedLength);try{const q=await A.get(w,{valueEncoding:o,keyEncoding:f});return q!==null&&q.value.length>=R}finally{await A.close()}}async fork(w,R,A,q){this.indexers=[],this.pendingIndexers=[],this.views=q,this.version<2&&(this.version=2);for(const{key:Y}of w){const{length:oe}=await this.get(Y);this.indexers.push({key:Y,length:oe})}this._refreshEntropy(this.core.length);const U=[];let T=this.core.length-1;for await(const Y of this.db.createHistoryStream({lt:T,reverse:!0})){if(l.equals(Y.key,m)){T=Y.seq+1;break}U.push(Y)}await this.core.truncate(T,this.core.fork);const Q=this.db.batch({update:!1});await Q.ready();for(const{key:Y,value:oe}of U)await Q.put(Y,oe);const le={version:this.version,members:this.members,pendingIndexers:this.pendingIndexers,indexers:this.indexers,heads:this.heads,views:this.views,encryptionLength:A,entropy:this.entropy};return await Q.put("info",le,{valueEncoding:h,keyEncoding:u}),await Q.flush(),await this._reset(await this.db.get("info",{valueEncoding:h,keyEncoding:u})),T}};function _(v,w){for(const R of v.actualHeads)if(B(R,w))return!0;return!1}function B(v,w){return l.equals(v.key,w.key)&&v.length===w.length}function M(v,w){if(v.views.length>0&&w.views.length>0)return l.equals(v.views[0].key,w.views[0].key);if(v.indexers.length!==w.indexers.length)return!1;for(let R=0;R<v.indexers.length;R++)if(!l.equals(v.indexers[R].key,w.indexers[R].key))return!1;return!0}function z(v){const w=[];for(let R=0;R<v.length;R++)w.push({key:v[R].key,length:v[R].length});return w}function j(v,w,R){const A=l.alloc(40+v.length*32),q={start:0,end:A.byteLength,buffer:A};g.uint64.encode(q,w),g.fixed32.encode(q,R||E);for(const{key:U}of v)g.fixed32.encode(q,U);return y.hash([b,A])}return yd}var _d,ib;function mo(){if(ib)return _d;ib=1;const n=Jv(),a=sn(),p=_t(),l=et(),g=Ue(),y=go(),h=Rn(),o=_o(),{EncryptionDescriptor:c,ManifestData:s}=ni(),{NS_VIEW_BLOCK_KEY:u,NS_HASH_KEY:f,NS_ENCRYPTION:m}=yo(),E=g.alloc(a.crypto_stream_NONCEBYTES),b=E.subarray(0,a.crypto_generichash_BYTES_MIN);class _{static PADDING=8;constructor(T){this.encryption=T,this.compat=null,this.keys=null,this.keysById=new Map}get id(){return this.keys?this.keys.id:0}padding(){return _.PADDING}isCompat(){return!1}load(T){this.keys===null&&(this.keys=T)}async update(T){if(this.id!==0&&this.id===this.encryption.id)return;const Q=await this.get(this.encryption.id,T);Q&&(this.keys=Q)}async get(T,Q){if(this.keysById.has(T))return this.keysById.get(T);const le=await this.getKeys(T,Q);return this.keysById.set(T,le),le}async getKeys(T,Q){const le=await this.encryption.get(T);if(!le)return null;const Y=this.blockKey(le,Q),oe=p.hash([f,Y]);return{id:T,block:Y,hash:oe}}blockKey(T,Q){return this.encryption.blockKey(T,Q)}async _ensureCompat(T){this.compat||(this.compat=this.compatKeys(T))}compatKeys(){throw new Error("Compatability method is not specified")}async encrypt(T,Q,le,Y){if(this.isCompat(Y,T))return this._ensureCompat(Y),n.encrypt(T,Q,le,this.compat.block,this.compat.blinding);await this.update(Y),q(T,Q,this.keys.id,this.keys.block,this.keys.hash)}async decrypt(T,Q,le){if(this.isCompat(le,T))return this._ensureCompat(le),n.decrypt(T,Q,this.compat.block);const Y=Q.subarray(0,_.PADDING);switch(Q=Q.subarray(_.PADDING),Y[0]){case 0:return Q;case 1:break;default:throw new Error("Unrecognised encryption type")}const ue=l.uint32.decode({start:4,end:8,buffer:Y}),O=await this.get(ue,le);l.uint64.encode({start:0,end:8,buffer:E},T),E.set(Y,8,16),v(Q,E,O.block)}}class B extends _{constructor(T,Q){super(T),this.name=Q}isCompat(T,Q){if(T.manifest.version<=1)return!0;if(!T.manifest.userData)return!1;const{legacyBlocks:le}=l.decode(s,T.manifest.userData);return Q<le}compatKeys(){const{bootstrap:T,encryptionKey:Q}=this.encryption.base,le=R(T,Q,this.name);return{block:le,blinding:p.hash(le)}}blockKey(T){return R(this.encryption.base.bootstrap,T,this.name)}}class M extends _{isCompat(T){return T.manifest.version<=1}compatKeys(T){return n.deriveKeys(this.encryption.base.encryptionKey,T.key)}blockKey(T,Q){if(Q.manifest.userData){const le=l.decode(s,Q.manifest.userData);if(le.namespace!==null)return this.encryption.blockKey(T,{key:le.namespace})}return this.encryption.blockKey(T,Q)}}class z extends h{constructor(T,Q){super(),this.base=T,this.core=Q||null,this.sessions=new Map,this._initialising=null}async _open(){await this.initialised(),await this.core.ready()}initialised(){return this.core!==null?this.core.ready():this._initialising?this._initialising:(this._initialising=y(),this._initialising.promise)}_close(){if(this._initialising&&(this._initialising.reject(new Error("Encryption closed")),this._initialising=null),this.core)return this.core.close()}get bootstrapped(){return!!(this.core&&this.core.length>0)}get id(){return this.core?this.core.length:0}_createPayload(T){return T}async reload(T){this.core&&await this.core.close(),this.core=T,await this.core.ready(),this._initialising&&(this._initialising.resolve(),this._initialising=null)}unpack(T,Q){if(T>0)throw new Error("Unsupported version");return Q}async update(T){const le={type:0,payload:await this._createPayload(T)};await this.core.append(l.encode(c,le))}async _preload(){return await this.ready(),this.id()}getViewEncryption(T){if(this.sessions.has(T))return this.sessions.get(T);const Q=new B(this,T);return this.sessions.set(T,Q),Q}getWriterEncryption(){return new M(this)}async encryptAnchor(T,Q){const le=await this.get(this.id);if(!le)return null;const Y=this.blockKey(le,{key:Q}),oe=p.hash([f,T]);q(0,T,this.id,Y,oe)}blockKey(T,Q){return w(this.base.bootstrap,this.base.encryptionKey,T,Q.key)}async get(T){if(T===0)return o.GENESIS_ENTROPY;this.core||await this.initialised();const Q=T-1,le=await this.core.get(Q),{type:Y,payload:oe}=l.decode(c,le);return this.unpack(Y,oe)}getSystemEncryption(){return this.getViewEncryption("_system")}static namespace(T){return p.hash([m,T])}static getBlockKey(T,Q,le,Y){return w(T,Q,le,Y)}static getSystemEncryption(T,Q){return new z(T,Q).getSystemEncryption()}static async setSystemEncryption(T,Q,le){if(T.encryptionKey===null)return null;if(await Q.ready(),Q.manifest.version===1){const ue=R(T.bootstrap,T.encryptionKey,"_system");return Q.setEncryptionKey(ue,{block:!0})}if(!Q.manifest.linked.length)throw new Error("System manifest does not link encryption view");const Y=T.store.get({key:Q.manifest.linked[0],active:!1}),oe=z.getSystemEncryption(T,Y);return await Q.setEncryption(oe,le),Y}}_d={AutobaseEncryption:_,EncryptionView:z};function j(U,T,Q){a.crypto_stream_xor(U,U,T,Q)}function v(U,T,Q){return j(U,T,Q)}function w(U,T,Q,le){return T&&p.hash([u,U,T,Q,le])}function R(U,T,Q){return typeof Q=="string"?R(U,T,g.from(Q)):T&&p.hash([u,U,T,Q])}function A(U,T,Q){a.crypto_generichash(b,U,Q),T.set(b.subarray(0,8)),b.fill(0)}function q(U,T,Q,le,Y){const oe=T.subarray(0,_.PADDING);T=T.subarray(_.PADDING),A(T,oe,Y),l.uint32.encode({start:4,end:8,buffer:oe},Q),l.uint64.encode({start:0,end:8,buffer:E},U),oe[0]=1,E.set(oe,8,16),j(T,E,le)}return _d}var md,sb;function c0(){return sb||(sb=1,md=class{constructor(a){this.base=a,this.byName=new Map,this.tracking=null}get discoveryKey(){return this.base.discoveryKey}get key(){return this.base.key}get id(){return this.base.id}get system(){return this.base.system}track(a){if(this.tracking=[],this.byName.clear(),!!a){for(const p of a.views)p.ref&&this._add(p.ref);this._add(a.systemView.ref),this._add(a.encryptionView.ref)}}_add(a){this.tracking.push({ref:a,from:a.atomicBatch?a.atomicBatch.length:0})}finalise(){if(this.tracking!==null){for(const{ref:a,from:p}of this.tracking){const l=a.atomicBatch||a.batch,g=a.atomicBatch?a.atomicBatch.state.lastTruncation:null;this.byName.set(a.name,{from:p,to:l?l.length:p,shared:g?g.to:p})}this.tracking=null}}get(a){return this.byName.get(a)}}),md}var wd,rb;function GS(){if(rb)return wd;rb=1;const n=jt(),a=2*60*1e3,p=10*1e3;wd=class{constructor(o,c,s={}){this.handler=o||y,this.interval=c||p,this.limit=s.limit||a,this._executing=null,this._limit=g(this.limit),this._timer=null,this._resolve=null,this._start=0,this._stopped=!1,this._asap=!1,this._standalone=new Set,this._unref=s.unref!==!1,this._timerCallback=this._executeBackground.bind(this)}_executeBackground(){this._executing=this._execute(),this._executing.catch(n)}async _execute(){this._asap=!1,await this.handler(),this._start=0,this._executing=null,this.bump()}bump(){if(this._stopped||this._executing||this._asap)return;if(!this._start)this._start=Date.now();else if(Date.now()-this._start>this._limit)return;const o=g(this.interval);clearTimeout(this._timer),this._timer=setTimeout(this._timerCallback,o),this._unref&&this._timer.unref&&this._timer.unref()}async trigger(){this._stopped||(this._executing&&await this._executing,!this._stopped&&(clearTimeout(this._timer),this._timer=null,this._executeBackground(),await this._executing))}async flush(){this._executing&&await this._executing}bau(){this._asap&&(this._asap=!1,this.bump())}asap(){if(this._asap)return;this._asap=!0;const o=Math.floor(Math.random()*this.interval/3);clearTimeout(this._timer),this._timer=setTimeout(this._timerCallback,o),this._unref&&this._timer.unref&&this._timer.unref()}stop(){this._timer&&clearTimeout(this._timer),this._timer=null,this._start=0,this._asap=!1,this._stopped=!0;for(const{timer:o,resolve:c}of this._standalone)clearTimeout(o),c();this._standalone.clear()}asapStandalone(){const o=Math.floor(Math.random()*this.interval/3);return new Promise(c=>{const s={timer:null,resolve:c};s.timer=setTimeout(l,o,s,this._standalone),s.timer.unref&&s.timer.unref(),this._standalone.add(s)})}unref(){this._timer&&this._timer.unref&&this._timer.unref()}};function l(h,o){o.delete(h),h.resolve()}function g(h){return Math.floor(h+Math.random()*h)}function y(){}return wd}var bd,ob;function YS(){if(ob)return bd;ob=1;const n=32;return bd=class{constructor(p,l){this.hwm=l||n,this.defaultHwm=this.hwm,this.mask=this.hwm-1,this.top=0,this.btm=0,this.buffer=new Array(this.hwm),this.offset=p||0,this.length=this.offset}get size(){return this.length-this.offset}isEmpty(){return this.length===this.offset}isFull(){return this.size===this.buffer.length}grow(){this.hwm<<=1;const p=this.size,l=new Array(this.hwm),g=this.hwm-1;for(let y=0;y<p;y++)l[y]=this.buffer[this.btm+y&this.mask];this.mask=g,this.top=p,this.btm=0,this.buffer=l}push(p){return this.isFull()&&this.grow(),this.buffer[this.top]=p,this.top=this.top+1&this.mask,this.length++}shift(){if(this.isEmpty())return null;const p=this.buffer[this.btm];return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,this.offset++,this.isEmpty()&&this.hwm!==this.defaultHwm&&(this.buffer=new Array(this.defaultHwm),this.hwm=this.buffer.length,this.mask=this.hwm-1,this.top=this.btm=0),p}get(p){return p<this.offset||p>=this.length?null:this.buffer[this.btm+(p-this.offset)&this.mask]}},bd}var vd,ab;function WS(){if(ab)return vd;ab=1;const n=et(),a=Ue(),p=Rn(),l=On(),g=Dv(),y=i0(),h=YS(),o=4,c=256;vd=class extends p{constructor(m,E,b,_){super(),this.base=m,this.core=E,this.isRemoved=_,this.updated=!1,this.range=null,this.nodes=new h(b),this.node=null,this.isActive=!1,this.isCurrentlyCoupled=!1,this.isCoupled=!1,this.isBootstrap=!1,this.isActiveIndexer=!1,this.available=b,this.length=b,this.seenLength=0,this.recover=!1,this.frozen=!1,this.syncSignal=null}_pause(){this.range&&(this.range.destroy(),this.range=null)}_resume(){if(this.range){if(this.range.range.end===this.nodes.length+c)return;this.range.destroy()}this.range=this.core.download({start:this.nodes.length,end:this.nodes.length+c,linear:!0})}_updateCoupling(){!this.base._coupler||this.isCoupled===this.isCurrentlyCoupled||(this.isCurrentlyCoupled?this.base._coupler.remove(this.core):this.base._coupler.add(this.core),this.isCurrentlyCoupled=this.isCoupled)}_removeCouple(){this.base._coupler&&!this.isCoupled&&this.isCurrentlyCoupled&&(this.isCurrentlyCoupled=!1,this.base._coupler.remove(this.core))}updateActivity(){this.core.opened&&(this.seenLength>this.core.length||this.length<this.core.length||this.isBootstrap?(this.isActive=!0,this.core.setActive(!0)):this.length===this.core.length&&(this.isActive=!1,this.core.setActive(!1)),this._updateCoupling(),!this.core.writable&&(this.base.isFastForwarding()||!this.isActive?this._pause():this._resume()))}setBootstrap(m){this.isBootstrap=m,this.updateActivity()}seen(m){m>this.seenLength&&(this.seenLength=m),this.updateActivity()}waitForSynced(){return this.core.length===this.length?Promise.resolve():(this.syncSignal===null&&(this.syncSignal=new g),this.syncSignal.wait())}async _open(){await this.core.ready(),await this.core.setUserData("referrer",this.base.key),!this.base.closing&&(this.recover=u(this.core),await this.base._wakeup.add(this.core.core),this.updateActivity(),this.core.length>this.length&&this.base._queueBump(),this.base.emit("writer",this))}_close(){return this.syncSignal!==null&&this.syncSignal.notify(),this.core.close()}get indexed(){return this.nodes.offset}idle(){return this.length===this.available&&this.length===this.core.length&&this.core.opened}flushed(){return this.seenLength<=this.length&&this.length===this.available&&this.length===this.core.length&&this.shiftable()===!1&&!this.core.core.upgrading&&this.core.opened}compare(m){return a.compare(this.core.key,m.core.key)}head(){return this.nodes.get(this.length-1)}advance(){return this.syncSignal!==null&&this.length+1===this.core.length&&this.syncSignal.notify(),this.length<this.available?this.nodes.get(this.length++):null}shiftable(){return this.length>this.nodes.offset}shift(){if(this.shiftable()===!1)return!1;let m=this._shiftAndClear();for(;m.batch>1;)m=this._shiftAndClear();return!0}get(m){return m<this.length?this.nodes.get(m):null}append(m,E,b,_,B){const M=y.createNode(this,this.nodes.length+1,m,E,b,_,B);return M.actualHeads=M.heads.slice(0),this.nodes.push(M),this.available++,this.length++,M}async update(m){if(this.opened===!1&&await this.ready(),this.frozen)return!1;const E=m?1:o;for(;this.available-this.length<E&&!(this.nodes.length===this.core.length||this.core.length===0||this.node===null&&!await this._loadNextNode()||!await this._ensureNodeDependencies(m));)this.recover&&(this.node.value=null),this.nodes.push(this.node),this.node.batch===1&&(this.available=this.nodes.length),this.node=null;return this.updateActivity(),this.length<this.available}_shiftAndClear(){const m=this.nodes.shift();return m.clear(),m}async _loadNextNode(){const m=this.nodes.length;if(!await this.core.has(m))return!1;try{const{node:E,optimistic:b}=await this.core.get(m,{wait:!1}),_=E.value==null?null:n.decode(this.base.valueEncoding,E.value);return this.node=y.createNode(this,m+1,_,E.heads,E.batch,new Set,b),!0}catch(E){throw this.frozen=!0,E}}async _ensureNodeDependencies(m){for(;this.node.dependencies.size<this.node.heads.length;){const b=this.node.heads[this.node.dependencies.size],_=await this.base._getWriterByKey(b.key,-1,b.length,!0,!1,m);if(_!==this&&(_===null||_.length<b.length))return m||this.base._ensureWakeup(_),!1;let B=_.nodes.get(b.length-1);if(!B){for(const M of this.base.linearizer.heads)if(s(M,b)){B=M;break}}if(l(!this.node.dependencies.has(B),"Corrupted DAG"),B===null){this.node.heads.splice(this.node.dependencies.size,1);continue}this.node.dependencies.add(B)}const E=this.node.length-1;return E>this.indexed&&this.node.dependencies.add(this.nodes.get(E-1)),!0}};function s(f,m){return f.length!==m.length?!1:a.equals(f.writer.core.key,m.key)}function u(f){switch(l(f.opened),f.id){case"ghrpexaboutdm46ombqho7mroxknassnntrxx3cubfux4qi6w6hy":case"qoaanao71s4he1rcd197d336qepykk4467geo1uq8cwnzmpb786o":case"fomhdxgn4j4tzjqy6y7iskhffimzokt7kraddyd8orcht3r8q61o":case"d8f5taxxrit51apftoi38e5b86hb98cgfd7dfp3uo1uoh95qt49o":case"objyf75uggsqpjcut69xdgj46ks8r71jjrq7oxdfsz95sstchkno":return!0}return!1}return vd}var kd,lb;function h0(){if(lb)return kd;lb=1;const n=_t(),a=et(),p=Ue(),{OPLOG_VERSION:l}=yo(),{OplogMessage:g}=ni(),{EncryptionView:y}=mo();kd={encodeValue:h,decodeValue:o};function h(c,s={}){const u={start:0,end:0,buffer:null},f={version:s.version||l,digest:null,checkpoint:null,optimistic:!!s.optimistic,node:{heads:s.heads||[],batch:1,value:c}};if(g.preencode(u,f),s.padding&&(u.start=s.padding,u.end+=s.padding),u.buffer=p.alloc(u.end),g.encode(u,f),!s.encrypted)return u.buffer;if(!s.optimistic)throw new Error("Encoding an encrypted value is not supported");const m=p.alloc(16);return n.hash(u.buffer,m),m[0]=0,p.concat([m.subarray(0,8),u.buffer])}async function o(c,{autobase:s,encryptionKey:u,key:f,manifest:m,index:E=0}={}){return u&&(await new y({encryptionKey:u,bootstrap:s}).getWriterEncryption().decrypt(E,c,{key:f,manifest:m}),c=c.subarray(8)),a.decode(g,c).node.value}return kd}var Sd,cb;function QS(){if(cb)return Sd;cb=1;const n=Ue();return Sd=class{constructor(){this.map=new Map}get size(){return this.map.size}[Symbol.iterator](){return this.map.values()}get(p){return this.map.get(n.toString(p,"hex"))||null}has(p){return this.get(p)!==null}add(p){this.map.set(n.toString(p.core.key,"hex"),p)}delete(p){this.map.delete(n.toString(p.core.key,"hex"))}updateActivity(){for(const p of this.map.values())p.updateActivity()}clear(){const p=[];for(const l of this.map.values())p.push(l.close());return this.map.clear(),Promise.all(p)}},Sd}var xd,hb;function XS(){if(hb)return xd;hb=1;const n=Ue(),a=et(),p=jt(),l=Rn(),g={preencode(h,o){a.fixed32.preencode(h,o.key),a.uint.preencode(h,o.length)},encode(h,o){a.fixed32.encode(h,o.key),a.uint.encode(h,o.length)},decode(h){return{key:a.fixed32.decode(h),length:a.uint.decode(h)}}};xd=class extends l{constructor(o){super(),this.base=o,this.flushing=null,this._rootStore=this.base.store,this._addBound=this.add.bind(this),this._preupdateBound=this._preupdate.bind(this),this._needsFlush=!1,this._map=new Map}[Symbol.iterator](){return this._map.values()}async _preupdate(o,c){this.queue(c,o.length),await this.flush(),this.base._onwakeup()}async _save(){const o=n.allocUnsafe(8+this._map.size*40),c={start:0,end:0,buffer:o};a.uint.encode(c,this._map.size);for(const s of this._map.values())g.encode(c,s);await this.base.local.setUserData("autobase/wakeup",o.subarray(0,c.start))}async _load(){const o=await this.base.local.getUserData("autobase/wakeup");if(!o)return;const c={start:0,end:o.byteLength,buffer:o};let s=a.uint.decode(c);for(;s-- >0;){const u=g.decode(c);this._map.set(n.toString(u.key,"hex"),u)}}async _open(){await this._load(),this._rootStore.watch(this._addBound);for(const o of this._rootStore.cores)o.opened===!1&&await o.ready().catch(y),o.closing||this.add(o)}async _close(){this._rootStore.unwatch(this._addBound);for(const o of this._rootStore.cores)o.opened&&!o.closing&&this.remove(o);for(this._map.clear();this.flushing;)try{await this.flushing}catch{}}queue(o,c){const s=n.toString(o,"hex"),u=this._map.get(s);return u&&u.length>c?!1:(this._needsFlush=!0,this._map.set(s,{key:o,length:c}),!0)}unqueue(o,c){const s=n.toString(o,"hex"),u=this._map.get(s);return u?u.length>c?!1:(this._needsFlush=!0,this._map.delete(s),!0):!0}async flush(){if(this.closing)throw new Error("Closing");if(this.flushing&&await this.flushing,this.flushing)return this.flushing;if(this._needsFlush!==!1){this._needsFlush=!1;try{return this.flushing=this._save(),await this.flushing}finally{this.flushing=null}}}add(o){return this._add(o).catch(p)}remove(o){return this._remove(o)}async _add(o){if(o.opened===!1&&await o.ready(),o.closing||o===this.base.local.core)return!1;const c=o.storage.read(),s=c.getUserData("referrer"),u=c.getUserData("autobase/view");c.tryFlush();const[f,m]=await Promise.all([s,u]);return m||f===null||!n.equals(f,this.base.key)?!1:(o.preupdate=this._preupdateBound,!0)}_remove(o){return o.preupdate!==this._preupdateBound?!1:(o.preupdate=null,!0)}};function y(){}return xd}var Ed,ub;function ZS(){if(ub)return Ed;ub=1;const n=go(),a=jt(),p=_o(),{EncryptionView:l}=mo(),g=5e3,y=16;return Ed=class{constructor(o,c,{timeout:s=g,verified:u=!0,minimum:f=y,force:m=!1}={}){this.base=o,this.key=c,this.timeout=s,this.force=m,this.core=o.store.get({key:c,active:!0,encryption:null}),this.length=0,this.views=[],this.encryption=null,this.entropy=null,this.indexers=[],this.minimum=f,this.verified=u,this.waiting=new Set,this.cores=[this.core],this.system=null,this.destroyed=!1,this.upgrading=null,this.failed=!1}static MINIMUM=y;async upgrade(){this.upgrading||(this.upgrading=this._upgrade());try{return await this.upgrading?{length:this.length,force:this.force,key:this.key,indexers:this.indexers,views:this.views,entropy:this.entropy,manifestVersion:this.core.manifest.version,minimum:this.minimum}:null}catch(o){return a(o),this.failed=!0,null}finally{await this.close()}}_waitForAppend(o){if(o.length>0)return Promise.resolve();const c=n(),s=setTimeout(this.close.bind(this),this.timeout),u={promise:c,timeout:s};return this.waiting.add(u),o.once("append",()=>{this.waiting.delete(u),clearTimeout(s),c.resolve()}),c.promise}_minLength(){return this.base.core.length+this.minimum}async _upgrade(){if(await this.core.ready(),this.verified||await this._waitForAppend(this.core),this.destroyed)return!1;if(this.core.manifest.linked){const c=[];for(const s of this.core.manifest.linked){const u=this.base.store.get({key:s,active:!0});this.cores.push(u),await u.ready(),c.push(this._waitForAppend(u))}await Promise.all(c)}if(this.length=this.core.length,!this.force&&(this.length===0||this.length<this._minLength())||(await this.core.get(this.length-1,{timeout:this.timeout}),await this.base.ready(),this.destroyed)||this.base.encryptionKey&&!await this._ensureEncryption()||this.destroyed||(this.system=new p(this.core,{checkout:this.length}),await this.system.ready(),this.destroyed))return!1;if(this.entropy=this.system.entropy,this.core.manifest.version>=2){const c=this.core.manifest.linked;if(this.system.encryptionLength===0||c===null||!c.length)return!1;this.views.push({key:c[0],length:this.system.encryptionLength})}const o=[];o.push(this.system.get(this.base.local.key,{timeout:this.timeout})),this.encryption&&this.encryption.core&&o.push(this.encryption.core.get(this.system.encryptionLength-1,{timeout:this.timeout}));for(const c of this.system.views){this.views.push(c);const s=this.base.store.get({key:c.key,active:!0});this.cores.push(s),c.length&&o.push(s.get(c.length-1,{timeout:this.timeout}))}for(const c of this.system.indexers){if(this.indexers.push(c),c.length===0)continue;const s=this.base.store.get({key:c.key,active:!0});this.cores.push(s),o.push(s.get(c.length-1,{timeout:this.timeout})),o.push(this.system.get(c.key,{timeout:this.timeout}))}for(const c of this.system.heads)o.push(this.system.get(c.key,{timeout:this.timeout}));return await Promise.all(o),!this.destroyed}async _ensureEncryption(){if(this.core.encryption!==null)return!0;const o=this.core.manifest.version<=1?null:this.cores[1];this.encryption=new l(this.base,o);const c=this.encryption.getViewEncryption("_system");return await this.core.setEncryption(c),!0}async close(){this.destroyed=!0;for(const{promise:o,timeout:c}of this.waiting)clearTimeout(c),o.resolve();this.system&&await this.system.close(),this.encryption&&await this.encryption.close();for(const o of this.cores)await o.close();await this.core.close()}},Ed}var Ad,db;function $S(){if(db)return Ad;db=1;const n=Ue(),a=et(),p=_t(),l=Wf(),g=ni(),y=1,h=1,o=n.alloc(0),[c]=p.namespace("autobase",1);class s{constructor(b,_){this.base=b,this.core=_,this.unlinked=!1,this.extension=this.core.registerExtension("autobase",{onmessage:this._onmessage.bind(this)}),this.core.opened?this._onready():this.core.ready().then(this._onready.bind(this),m)}_onready(){if(!this.core.manifest||!this.core.manifest.signers.length)return;const b=a.encode(g.Wakeup,{version:1,type:0});this.core.on("peer-add",_=>{if(this.base.isFastForwarding()){this.base._needsWakeupRequest=!0;return}this.extension.send(b,_)}),this._broadcastRequest(b)}_broadcastRequest(b){if(this.base.isFastForwarding()){this.base._needsWakeupRequest=!0;return}for(const _ of this.core.peers)this.extension.send(b,_)}broadcast(){const b=a.encode(g.Wakeup,{version:1,type:0});this._broadcastRequest(b)}unlink(){this.unlinked=!0}_onmessage(b,_){if(!b)return;let B=null;try{B=a.decode(g.Wakeup,b)}catch{return}B.type!==0&&(this.unlinked||this.base.isFastForwarding()||!this.core.manifest||!this.core.manifest.signers.length||this.base.hintWakeup(B.writers))}}class u{constructor(b,_,B){this.name=b,this.core=null,this.batch=null,this.atomicBatch=null,this.compatExtension=null,this.migrated(B,_)}getCore(){return this.atomicBatch||this.batch||this.core}migrated(b,_){if(this.core=_,this.name==="_system"){const B=b._queueFastForward.bind(b);this.core.on("append",B),this.core.ready().then(B,B),(!this.compatExtension||this.compatExtension.core!==_)&&(this.compatExtension&&this.compatExtension.unlink(),this.compatExtension=new s(b,_))}}async matchesKey(b){return this.core.opened||await this.core.ready(),n.equals(this.core.key,b)}async matchesNamespace(b){if(this.core.opened||await this.core.ready(),this.core.manifest&&this.core.manifest.signers.length>0){const _=this.core.manifest.signers[0].namespace;if(n.equals(_,b))return!0}return!1}async commit(b,_,B){await this.core.commit(this._getAtomicBatch(b),{length:_,signature:B})}async release(){if(!this.atomicBatch)return;await this.atomicBatch.ready();const b=this.atomicBatch.state.sessions;for(let _=b.length-1;_>=0&&b[_];_--)await b[_].close();await this.atomicBatch.close(),this.atomicBatch=null}_getAtomicBatch(b){return this.atomicBatch===null&&(this.atomicBatch=this.batch.session({atom:b,writable:!0})),this.atomicBatch}async catchup(b,_){await this.release();const B=this._getAtomicBatch(b);await B.ready(),await B.state.catchup(_)}createSession(b,_){return this.batch===null&&(this.batch=this.core.session({name:"batch",writable:!0})),b?this._getAtomicBatch(b).session({valueEncoding:_,writable:!0}):this.batch.session({valueEncoding:_,writable:!1})}}class f{constructor(b,_){this.base=b,this.store=b.store,this.byName=_||new Map,this.opened=[],this.atom=null,this.local=null}async close(){this.local&&await this.local.close();for(const b of this.byName.values())await b.release();if(!this.atom)for(const b of this.byName.values())b.core&&await b.core.close(),b.batch&&await b.batch.close()}atomize(){const b=new f(this.base,this.byName);return b.atom=this.store.storage.createAtom(),b}async updateLocal(){this.local&&(await this.local.close(),this.local=null)}flush(){return this.atom?this.atom.flush():Promise.resolve()}get(b,_){typeof b=="string"&&(b={name:b}),_&&(b={...b,..._});const{name:B,valueEncoding:M=null}=b;if(!B)throw new Error("name is required");return this.getViewByName(B).createSession(this.atom,M)}getViewByName(b){let _=this.byName.get(b);if(!_){const B=this._preload(b),M=this.base.store.get({preload:B});_=new u(b,M,this.base),this.byName.set(b,_)}return this.opened.indexOf(_)===-1&&this.opened.push(_),_}getLocal(){return this.local!==null?this.local:(this.local=this.base.local.session({atom:this.atom,valueEncoding:g.OplogMessage,encryption:this.base.getWriterEncryption(this.base.local.key),active:!1}),this.local)}getViews(){return[...this.byName.values()]}getSystemView(){return this.getViewByName("_system")}getSystemCore(){return this.getSystemView().core}getEncryption(b){return!this.base.encryptionKey||b==="_encryption"?null:this.base.encryption.getViewEncryption(b)}async getIndexerManifests(b){const _=[];for(const{key:B}of b){const M=this.store.get({key:B,active:!1});await M.ready(),M.manifest&&(_.push(M.manifest),await M.close())}return _}getViewCore(b,_,B,M,z,j,v){const w=this._createManifest(b,_,B,M,z,j,v);return this.base.store.get({manifest:w,exclusive:!1,encryption:this.getEncryption(_)})}listViews(){const b=[];for(const[_,B]of this.byName){const M=B.batch||B.core;b.push({name:_,key:M.key,length:M.length,signedLength:M.signedLength})}return b}createAnchorCore(b,_){const B={version:2,hash:"blake2b",prologue:b,allowPatch:!1,quorum:0,signers:[],userData:_,linked:null};return this.store.get({manifest:B,active:!1})}async createView(b,_,B,M,z,j,v){const w=this._createManifest(b,_,B,M,z,j,v),R=this.store.get({key:l.key(w),manifest:w,active:!1});await R.ready();const A=R.key;return await R.close(),A}async _preload(b){if(await Promise.resolve(),!this.base.opening)throw new Error("Autobase failed to open");await this.base._preopen;const _=await this.base._getSystemInfo()||{key:this.getBootstrapSystemKey(),indexers:[],views:[],entropy:null},B=await this.getIndexerManifests(_.indexers);if(_.indexers.length===0)return this._freshCorePreload(B,b,_.entropy);if(b==="_system")return{key:_.key,exclusive:!1,encryption:this.getEncryption(b)};if(b==="_encryption"){const z=this.getSystemCore();return await z.ready(),z.manifest.linked?{key:z.manifest.linked[0],exclusive:!1,encryption:null}:this._freshCorePreload(B,b,_.entropy)}const M=await this.findViewByName(B,_.views,b,_.entropy);return M===null?this._freshCorePreload(B,b,_.entropy):{key:M.key,exclusive:!1,encryption:this.getEncryption(b)}}_freshCorePreload(b,_,B){return _==="_system"?this._freshSystemPreload(b,B):{manifest:this._createManifest(b,_,null,y,B,[],null),exclusive:!0,encryption:this.getEncryption(_)}}_freshSystemPreload(b,_){return{manifest:this._createSystemManifest(b,null,y,_,null),exclusive:!0,encryption:this.getEncryption("_system")}}_deriveStaticHash(b){return p.hash([this.base.key,n.from(b)])}_deriveNamespace(b,_){const B=p.hash(this.base.encryptionKey||o),M=a.encode(a.uint,h),z=this.base.key;return p.hash([c,M,z,B,_,n.from(b)])}async _getCoreManifest(b){const _=this.store.get({key:b,active:!1});await _.ready();const B=_.manifest;return await _.close(),B}getBootstrapSystemKey(){return l.key(this._createSystemManifest([],null,y,null))}async findViewByKey(b,_,B,M){for(const w of this.byName.values())if(await w.matchesKey(b))return w;const z=await this._getCoreManifest(b),j=z&&z.signers.length?z.signers[0].namespace:null;if(j){for(const w of this.byName.values())if(await w.matchesNamespace(j))return w}const v=await this.getIndexerManifests(_);if(M===null&&(M=v[0].signers[0].namespace),j)for(const w of this.byName.values()){const R=this._deriveNamespace(w.name,M);if(n.equals(R,j))return w}for(const w of this.byName.values()){const R=w.core?w.core.manifest.userData:null,A=this._createManifest(v,w.name,null,B,M,[],R),q=l.key(A);if(!n.equals(q,b))continue;const U=this.store.get({key:q,manifest:A,active:!1});return await U.ready(),await U.close(),w}return null}async findViewByName(b,_,B,M){if(b.length===0)return null;M===null&&(M=b[0].signers[0].namespace);const z=this._deriveNamespace(B,M);for(const j of _){const v=await this._getCoreManifest(j.key);if(v.signers.length===0)continue;const w=v.signers[0];if(n.equals(w.namespace,z))return j}return null}_createManifest(b,_,B,M,z,j,v){b.length?B&&B.length===0&&(B=null):B={hash:this._deriveStaticHash(_),length:0};const w=[];b.length&&z===null&&(z=b[0].signers[0].namespace);for(const R of b){const A=R.signers[0];w.push({namespace:this._deriveNamespace(_,z),signature:"ed25519",publicKey:A.publicKey})}return{version:M,hash:"blake2b",prologue:B,allowPatch:!0,quorum:Math.min(w.length,(w.length>>1)+1),signers:w,userData:v,linked:M>1?j:null}}_createSystemManifest(b,_,B,M,z){if(_!==null)throw new Error("Can only derive fresh system core");const j=[];if(B>y){const v=this._createManifest(b,"_encryption",null,B,M,[],z);j.push(l.key(v))}return this._createManifest(b,"_system",null,B,M,j,z)}}Ad=f;function m(){}return Ad}var Rd,fb;function u0(){if(fb)return Rd;fb=1;class n{constructor(g){this.base=g,this.internal=!1}get discoveryKey(){return this.base.discoveryKey}get key(){return this.base.key}get id(){return this.base.id}async addWriter(){throw new Error("Not allowed on the public view")}async ackWriter(){throw new Error("Not allowed on the public view")}async removeWriter(){throw new Error("Not allowed on the public view")}preferFastForward(){throw new Error("Not allowed on the public view")}interrupt(){throw new Error("Not allowed on the public view")}removeable(){throw new Error("Not allowed on the public view")}fork(){throw new Error("Not allowed on the public view")}anchor(){throw new Error("Not allowed on the public view")}}class a extends n{constructor(g){super(g.base),this.state=g,this.internal=!0}get system(){return this.state.system}async addWriter(g,{indexer:y=!0,isIndexer:h=y}={}){await this.state.system.add(g,{isIndexer:h}),await this.base._addWriter(g,this.state.system)}async ackWriter(g){await this.state.system.ack(g)}async removeWriter(g){if(!this.state.removeable(g))throw new Error("Not allowed to remove the last indexer");await this.state.system.remove(g),this.base._removeWriter(g)}preferFastForward(){this.base._preferFastForward()}interrupt(g){this.base._interrupt(g)}removeable(g){return this.state.removeable(g)}async fork(g,y){if(!await this.state.validateFork(g,y))return!1;const h=g.map(p);return this.state.pendingFork={indexers:h,length:y.length},!0}async createAnchor(){return await this.state.createAnchor()}}Rd={PublicApplyCalls:n,PrivateApplyCalls:a};function p(l){return{key:l,length:0}}return Rd}var Ld,gb;function JS(){if(gb)return Ld;gb=1;const n=et(),a=_o(),{EncryptionView:p}=mo(),{ManifestData:l}=ni();Ld=class{constructor(h,o,c,s){this.base=h,this.store=o,this.state=c,this.indexers=s.indexers,this.length=s.length,this.system=null,this.encryption=null,this.manifests=null,this.cores=[]}async upgrade(){try{return await this._upgrade(),!0}catch{return!1}finally{await this.close()}}async _upgrade(){this.manifests=await this.store.getIndexerManifests(this.indexers),this.system=new a(await this._get("_system",this.length)),this.encryption=new p(this,await this._get("_encryption",-1)),await this.system.ready(),await this.encryption.ready(),this.entropy=this.system.getEntropy(this.indexers,this.length),this.manifestVersion=Math.max(this.system.core.manifest.version,2);const h=[];for(const m of this.state.views){const E=this.getViewFromSystem(m,this.system),b=E?E.length:0,_=await this._get(m.name,b);await _.ready();const B=await this.createView(m.name,_,null);await B.ready(),await this._migrate(m.ref,B,m.core,b),h.push({key:B.key,length:b})}const o=p.namespace(this.entropy);await this.encryption.update(o);const c=this.store.getViewByName("_system"),s=this.store.getViewByName("_encryption"),u=await this.createView("_encryption",this.encryption.core,null);await u.ready(),await this._migrate(s,u,this.encryption.core,this.encryption.core.length),await this.system.fork(this.indexers,this.manifests,this.encryption.core.length,h);const f=await this.createView("_system",this.system.core,[u.key]);await f.ready(),await this._migrate(c,f,this.system.core,this.system.core.length)}async createView(h,o,c){const s=await g(o),u=this._manifestData(o);return this.store.getViewCore(this.manifests,h,s,this.manifestVersion,this.entropy,c,u)}async _get(h,o){const c=this.store.get({name:h});return this.cores.push(c),o!==-1&&await c.truncate(o),c}getViewFromSystem(h){return h.mappedIndex===-1||h.mappedIndex>=this.system.views.length?null:this.system.views[h.mappedIndex]}_manifestData(h){return h.manifest.version>1?h.manifest.userData:n.encode(l,{version:0,legacyBlocks:h.length})}async _migrate(h,o,c,s){s>0&&await o.core.copyPrologue(c.state);const u=o.session({name:"batch",overwrite:!0,checkout:s});if(await u.ready(),c!==null)for(;u.length<c.length;)await u.append(await c.get(u.length));await h.batch.state.moveTo(u,u.length),await u.close(),h.migrated(this.base,o)}async _ensureEncryption(){if(this.core.encryption!==null)return!0;const h=this.core.manifest.version<=1?null:this.cores[1];this.encryption=new p(this.base,h);const o=this.encryption.getViewEncryption("_system");return await this.core.setEncryption(o),!0}async close(){this.destroyed=!0,this.system&&await this.system.close(),this.encryption&&await this.encryption.close();for(const h of this.cores)await h.close()}};async function g(y){return y.length?{hash:await y.treeHash(),length:y.length}:null}return Ld}var Td,pb;function ex(){if(pb)return Td;pb=1;const n=Rn(),a=On(),p=et(),l=_t(),g=Ue(),y=jt(),{partialSignature:h}=Qv(),o=_o(),{AutobaseEncryption:c}=mo(),s=c0(),u=ni(),{PrivateApplyCalls:f}=u0(),{encodeValue:m}=h0(),E=JS(),b=e0(),{OPLOG_VERSION:_,BOOT_RECORD_VERSION:B}=yo(),M=16;class z{constructor(O,P,Z,he){this.view=O,this.core=P,this.signer=Z,this.length=0,this.digest=null,this.signatures={system:null,encryption:null,user:[]},this.closed=!1,this.paused=he}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.updateBackground())}async update(){await this.updateCheckpoints()&&await this.view.maybeSigned()}async updateCheckpoints(){if(this.core.length<=this.length||this.closed||this.paused)return!1;const O=this.core.length,P=await this.core.get(O-1);if(O<=this.length||this.closed||!P.digest||this.paused)return!1;const[Z,he]=await Promise.all([this._inflateDigest(O,P.digest),this._inflateAllCheckpoints(O,P.checkpoint)]);if(O<=this.length||this.closed||!Z||!he||this.paused)return!1;for(let se=0;se<he.length;se++)if(he[se]===null)return!1;return this.length=O,this.digest=Z,this.signatures=he,!0}updateBackground(){return this.update().catch(y)}updateInternalSignatures(O,P){this.signatures.system=Q(O,P.system,this.signatures.system),this.signatures.encryption=Q(O,P.encryption,this.signatures.encryption)}updateUserSignatures(O,P){this.signatures.user=le(O,P,this.signatures.user)}makeCheckpoints(O){return{system:Y(O,this.signatures.system),encryption:Y(O,this.signatures.encryption),user:oe(O,this.signatures.user)}}makeDigest(O,P){return this.digest&&(this.digest.key===P||g.equals(this.digest.key,P))?{key:null,pointer:O-this.digest.at}:(this.digest={key:P,at:O},{key:P,pointer:0})}async ready(){await this.core.ready(),this.core.on("append",this.updateBackground.bind(this)),this.core.writable&&await this.updateCheckpoints(),this.updateBackground()}signedLength(){return this.signatures.system?this.signatures.system.length:0}close(){return this.closed=!0,this.core.close()}async _inflateDigest(O,P){if(!P)return null;if(P.pointer===0)return{key:P.key,at:O};const Z=O-P.pointer;if(this.digest&&Z===this.digest.at)return this.digest;if(Z<=0)return null;const{digest:he}=await this.core.get(Z-1);return!he||!he.key?null:{key:he.key,at:Z}}_sameSignatures(O,P){return R(P.system,O.system)&&R(P.encryption,O.encryption)&&A(P.user,O.user)}async _inflateAllCheckpoints(O,P){if(!P)return{system:null,encryption:null,user:[]};if(this._sameSignatures(P,this.signatures))return this.signatures;const Z=this._inflateSystemCheckpoint(P.system,O),he=this._inflateEncryptionCheckpoint(P.encryption,O),se=P.user?new Array(P.user.length):[];for(let G=0;G<se.length;G++){const re=P.user[G];se[G]=this._inflateUserCheckpoint(re,G,O)}return{system:await Z,encryption:await he,user:await Promise.all(se)}}async _inflateSystemCheckpoint(O,P){if(O.checkpoint){const{signature:re,length:W}=O.checkpoint;return{signature:re,length:W,at:P}}const Z=P-O.checkpointer;if(this.signatures.system&&this.signatures.system.at===Z)return this.signatures.system;if(Z<=0)return null;const{checkpoint:he}=await this.core.get(Z-1);if(!he||!he.system||!he.system.checkpoint)return null;const{signature:se,length:G}=he.system.checkpoint;return{signature:se,length:G,at:Z}}async _inflateEncryptionCheckpoint(O,P){if(!O)return{length:0,signature:null,at:0};if(O.checkpoint){const{signature:re,length:W}=O.checkpoint;return{signature:re,length:W,at:P}}const Z=P-O.checkpointer;if(this.signatures.encryption&&this.signatures.encryption.at===Z)return this.signatures.encryption;if(Z<=0)return null;const{checkpoint:he}=await this.core.get(Z-1);if(!he||!he.encryption||!he.encryption.checkpoint)return null;const{signature:se,length:G}=he.encryption.checkpoint;return{signature:se,length:G,at:Z}}async _inflateUserCheckpoint(O,P,Z){if(O.checkpoint){const{signature:W,length:$}=O.checkpoint;return{signature:W,length:$,at:Z}}const he=Z-O.checkpointer;if(P<this.signatures.user.length&&this.signatures.user[P].at===he)return this.signatures.user[P];if(he<=0)return null;const{checkpoint:se}=await this.core.get(he-1);if(!se||P>=se.user.length||!se.user[P].checkpoint)return null;const{signature:G,length:re}=se.user[P].checkpoint;return{signature:G,length:re,at:he}}}Td=class extends n{constructor(O){super(),this.base=O,this.encryption=this.base.encryption,this.valueEncoding=O.valueEncoding,this.store=O._viewStore.atomize(),this.key=null,this.system=null,this.view=null,this.views=[],this.systemView=null,this.encryptionView=null,this.hostcalls=null,this.changes=O._hasUpdate?new s(O):null,this.updates=[],this.local=null,this.localState=null,this.fastForwarding=!1,this.indexersUpdated=!1,this.quorum=0,this.stretchedThreshold=0,this.needsIndexedLengthUpdate=!1,this.interrupted=!1,this.applying=null,this.applyBatch=null,this.localCheckpoint=null,this.localIndexer=!1,this.systemUpgrade=null,this.checkpoints=[],this.pendingViews=null,this.pendingFork=null,this.dirty=!1}shouldFlush(){return this.dirty}shouldWrite(){if(!this.localIndexer||!this.localCheckpoint||!this.localCheckpoint.opened||!this.localCheckpoint.signedLength()<this.indexedLength+this.stretchedThreshold)return!1;const O=Math.min(this.localCheckpoint.signatures.length,this.views.length+1);for(let P=1;P<O;P++){const Z=this.localCheckpoint.signatures[P],he=this.views[P-1].core;if(he&&Z.length>he.length)return!0}return!1}get indexedLength(){return this.systemView.indexedLength}get systemRef(){return this.systemView.ref}async validateFork(O,P){if(!g.equals(P.key,this.system.core.key)||this.pendingIndexedLength()<P.length)return!1;for(const Z of O){const he=await this.system.get(Z);if(!he||!he.length||he.isRemoved)return!1}return!0}async shouldMigrate(){if(!this.fastForwarding&&!this.indexersUpdated||this.system.indexers.length===0)return!1;if(!this.system.core.manifest||!this.system.core.manifest.signers||this.system.indexers.length!==this.system.core.manifest.signers.length)return!0;const O=await this.store.getIndexerManifests(this.system.indexers);for(let P=0;P<this.system.core.manifest.signers.length;P++){const{publicKey:Z}=this.system.core.manifest.signers[P];if(!g.equals(Z,O[P].signers[0].publicKey))return!0}return!1}isLocalPendingIndexer(){if(this.system.pendingIndexers.length===0)return!1;const O=this.base.local.key;for(const P of this.system.pendingIndexers)if(g.equals(P,O))return!g.equals(this.base.key,O)&&this.base.local.length===0;return!1}removeable(O){return this.system.indexers.length!==1?!0:!g.equals(this.system.indexers[0].key,O)}isLocalIndexer(){return!!this.localCheckpoint}_createCheckpointCore(O,P,Z,he){const se=this.base.getWriterEncryption(O),G=this.base.store.get({key:O,valueEncoding:u.OplogMessage,encryption:se,active:P});return new z(this,G,Z,he)}async _openInternalView(O,P){const Z=this.store.get({name:O});return await Z.ready(),await Z.setUserData("referrer",this.base.key),await Z.setUserData("autobase/view",g.from(O)),{ref:this.store.getViewByName(O),core:Z,indexedLength:P}}async _open(){const O=await this.base._getBootRecord();this.systemView=await this._openInternalView("_system",O.systemLength),this.encryptionView=await this._openInternalView("_encryption",-1);const P=this.systemView.core;P.manifest.version>=2&&this.encryption!==null&&await this.encryption.reload(this.encryptionView.core);const Z=new o(P);await Z.ready(),this.store.opened=[],this.hostcalls=new f(this);const he=this.base._hasOpen?this.base._handlers.open(this.store,this.hostcalls):null;for(const $ of this.store.opened)await $.atomicBatch.ready();this.system=Z,this.key=Z.core.key,this.view=he,this.fastForwarding=O.fastForwarding,this.indexersUpdated=O.indexersUpdated,this.stretchedThreshold=this.system.indexers.length*M,this.quorum=P.manifest?P.manifest.quorum:0;const se=new Set;for(let $=0;$<Z.views.length;$++){const{key:S,length:N}=Z.views[$],D=await this.store.findViewByKey(S,Z.indexers,P.manifest.version,Z.entropy);if(D===null){this.views.push({name:null,key:S,length:N,core:null,ref:null,mappedIndex:$});continue}await D.atomicBatch.ready(),await D.core.setUserData("referrer",this.base.key),await D.core.setUserData("autobase/view",g.from(D.name)),this.views.push({name:D.name,key:S,length:N,core:D.atomicBatch,ref:D,mappedIndex:$}),se.add(D)}for(const $ of this.store.opened){if(se.has($))continue;const S=$.atomicBatch;this.views.push({name:$.name,key:S.key,length:S.length,core:S,ref:$,mappedIndex:-1})}this.local=this.store.getLocal(),await this.local.ready(),this.localState=new b(this.local);let G=!1;const re=this.base.isFastForwarding();for(let $=0;$<Z.indexers.length;$++){const S=Z.indexers[$],N=this._createCheckpointCore(S.key,!0,$,re);await N.ready(),this.checkpoints.push(N),g.equals(S.key,this.base.local.key)&&(G=!0)}this.quorum>0&&G&&(this.localIndexer=!0,await this._startLocalCheckpoint()),await this._refreshWriters(),this.maybeSigned().catch(v)}async _startLocalCheckpoint(){for(const O of this.checkpoints)if(O.core.id===this.base.local.id){this.localCheckpoint=O;return}this.localCheckpoint=this._createCheckpointCore(this.base.local.key,!1,0,!1),await this.localCheckpoint.ready()}interrupt(){this.interrupted=!0,this.pause()}pause(){for(const O of this.checkpoints)O!==this.localCheckpoint&&O.pause()}resume(){for(const O of this.checkpoints)O!==this.localCheckpoint&&O.resume()}_checkSystemUpgrade(){if(this.systemUpgrade)return;const O=new Map;for(const P of this.checkpoints){if(P.signedLength()<=this.system.core.signedLength||!P.digest)continue;const Z=g.toString(P.digest.key,"hex"),he=(O.get(Z)||0)+1;if(he>=this.quorum){this.systemUpgrade=P.digest.key,this.base._queueStaticFastForward(this.systemUpgrade);return}O.set(Z,he)}}mapIndexToView(O){for(const{mappedIndex:P,ref:Z}of this.views)if(P===O)return Z}async maybeSigned(){if(this.opened===!1&&await this.ready(),this.interrupted)return;const O=this.checkpoints.length-this.quorum;if(O<0||this.checkpoints.length<=O)return;this.checkpoints.sort(w);const P=this.checkpoints[O].signedLength();if(P<=this.system.core.signedLength)return;const Z=this.system.core.key;if(P>this.indexedLength){g.equals(Z,this.checkpoints[O].digest.key)||this._checkSystemUpgrade(),this.needsIndexedLengthUpdate=!0;return}for(let G=O;G<this.checkpoints.length;G++){const re=this.checkpoints[G];if(!g.equals(Z,re.digest.key)){this._checkSystemUpgrade();return}if(!re.signatures.system||re.signatures.system.length>this.indexedLength){this.needsIndexedLengthUpdate=!0;return}}this.needsIndexedLengthUpdate=!1;const he=[];for(let G=O;G<this.checkpoints.length;G++)he.push({signer:this.checkpoints[G].signer,signatures:this.checkpoints[G].signatures});const{system:se}=this.checkpoints[O].signatures;await this._assembleMultisig(se.length,he)}async _assembleMultisig(O,P){const Z=new Array(this.views.length+2),he=await this.system.getIndexedInfo(O);if(this.interrupted||this.pendingViews&&this.pendingViews[0].length>=O)return;Z[0]=q(O,this.systemView,P.length),he.encryptionLength&&(Z[1]=q(he.encryptionLength,this.encryptionView,P.length));const se=2;for(let re=se;re<Z.length;re++){const W=this.views[re-se],$=W.core,S=this.getViewFromSystem(W,he),N=S?S.length:0;if(!$||N<=$.signedLength)continue;const D=W.mappedIndex+se;Z[D]=q(N,W,P.length)}for(let re=0;re<P.length;re++)U(Z,P,re);const G=[];for(const re of Z)if(re)for(let W=0;W<re.signatures.length;W++)G.push(T(re,W));await Promise.all(G);for(const re of Z)if(re){for(let W=0;W<re.signatures.length;W++)if(!re.partials[W])return}this.interrupted||this.pendingViews&&this.pendingViews[0].length>=O||Z[0]&&(this.pendingViews=Z,this.dirty=!0,this.base._queueBump())}async _close(){this.interrupted=!0,this.applying&&this._postApply();for(const P of this.checkpoints)await P.close();this.localCheckpoint&&await this.localCheckpoint.close(),this.base._hasClose&&await this.base._handlers.close(this.view),this.system&&await this.system.close();const O=[];for(const P of this.views)P.ref&&O.push(P.ref.release());O.push(this.systemView.ref.release()),O.push(this.encryptionView.ref.release()),await Promise.all(O),await this.store.close()}_pushUpdate(O){O.version=1,O.seq=this.updates.length===0?0:this.updates[this.updates.length-1].seq+1,O.systemLength=this.systemView.core.length,this.updates.push(O),this.localState.insertUpdate(O)}async catchup(O){if(this.opened||await this.ready(),!this.system.heads.length)return;const P=new Map,Z=await this.localState.listUpdates(),he=await this.system.checkout(this.indexedLength);for(const se of Z){const G=g.toString(se.key,"hex");let re=P.get(G);for(re===void 0&&(re=await this.base._getWriterByKey(se.key,-1,0,!0,!1,he),P.set(G,re)),a(re.length<se.length,"Update expects writer to be consumed here");re.length<se.length;){await re.update(he);const W=re.advance();a(W,"Node must exist for catchup"),O.addHead(W)}}if(await he.close(),this.updates=Z,this.indexersUpdated)for(this.indexersUpdated=!1,await this.truncate(this.indexedLength),await this._rollbackViews(),this.tx===null&&(this.tx=this.local.state.storage.write());this.updates.length>0&&this.updates[this.updates.length-1].systemLength>=this.indexedLength;){const se=this.updates.pop();this.localState.deleteUpdate(se)}else O.update();await this._refreshWriters()}async getIndexedSystem(){this.opened===!1&&await this.ready();const O=this.pendingFork?this.pendingFork.length:this.indexedLength,P=await this.system.checkout(O);return await P.ready(),P}getViewFromSystem(O,P=this.system){return O.mappedIndex===-1||O.mappedIndex>=P.views.length?null:P.views[O.mappedIndex]}async recoverAt(){await this.systemRef.core.ready();const O=this.systemRef.core.signedLength;for await(const{length:P,info:Z}of o.flushes(this.systemRef.core,{reverse:!0,lt:O}))for(let he=0;he<Z.views.length;he++)if(!(he>=this.views.length)&&g.equals(Z.views[he].key,this.views[he].key)&&!(Z.views[he].length>this.views[he].core.signedLength))return{length:P,force:!0,key:this.system.core.key,indexers:Z.indexers,views:Z.views};return null}bootstrap(){return this.system.add(this.base.key,{isIndexer:!0,isPending:!1})}async undo(O){if(!O)return;let P=!1;for(;O>0;){const se=this.updates.pop();this.localState.deleteUpdate(se),O-=se.batch,se.indexers&&(P=!0)}const Z=this.updates.length===0?null:this.updates[this.updates.length-1],he=Z?Z.systemLength:this.indexedLength;await this.truncate(he),P&&await this._rollbackViews()}async truncate(O){if(this.opened===!1&&await this.ready(),O===this.system.core.length)return;await this.system.core.truncate(O);const P=await this.system.update();this.encryptionView.core.length!==this.system.encryptionLength&&await this.encryptionView.core.truncate(this.system.encryptionLength);for(const Z of this.views){if(!Z.core)continue;const he=this.getViewFromSystem(Z);he&&Z.core.length===he.length||(he===null&&(Z.mappedIndex=-1),await Z.core.truncate(he?he.length:0))}P&&(await this._refreshWriters(),await this._rollbackViews())}async _refreshWriters(){for(const O of this.base.activeWriters){const P=await this.system.get(O.core.key),Z=this.system.core.length===0&&g.equals(O.core.key,this.base.key),he=P?P.isRemoved:!Z;O.isRemoved=he}}async _updateSystem(){await this.system.update()&&(await this._refreshWriters(),await this._rollbackViews())}async _signViewCore(O,P){const Z=await O.signable(P,0);return{signature:l.sign(Z,this.base.local.keyPair.secretKey),length:P}}async _signInternalViewCores(O){return{system:await this._signViewCore(this.systemView.core,this.systemView.indexedLength),encryption:await this._signViewCore(this.encryptionView.core,O.encryptionLength)}}async _signUserViewCores(O){const P=new Array(O.views.length);for(let Z=0;Z<this.views.length;Z++){const he=this.views[Z],se=this.getViewFromSystem(he,O),G=se?se.length:0;if(!G)continue;const re=he.mappedIndex;P[re]=this._signViewCore(he.ref.atomicBatch,G)}return Promise.all(P)}async finalize(O){this.localState.setBootRecord({version:B,key:O,systemLength:this.systemView.indexedLength,indexersUpdated:!0,fastForwarding:!1,recoveries:this.base.recoveries}),await this.localState.flush(),await this.store.flush(),await this.close()}async _flush(O){if(O&&await this._appendLocalNodes(O),this.localState.setBootRecord({version:B,key:this.key,systemLength:this.systemView.indexedLength,indexersUpdated:!1,fastForwarding:!1,recoveries:this.base.recoveries}),await this.localState.flush(),this.localCheckpoint&&(await this.store.flush(),await this.localCheckpoint.update()),this.pendingViews){const P=this.pendingViews;this.pendingViews=null;for(let Z=P.length-1;Z>=0;Z--){const he=P[Z];if(!he||he.length<=he.core.signedLength)continue;const se=he.core.core.verifier.assemble(he.partials);try{await he.ref.commit(this.store.atom,he.length,se)}catch(G){this.base.closing||this.base._warn(G)}}}await this.store.flush(),this.fastForwarding=!1,this.pendingViews===null&&(this.dirty=!1)}_indexUpdates(O){let P=0;for(;O>0;)O-=this.updates[P++].batch;const Z=this.updates[P-1];this.systemView.indexedLength=Z.systemLength;for(let he=0;he<P;he++)this.localState.deleteUpdate(this.updates[he]);this.updates.splice(0,P),this.needsIndexedLengthUpdate&&this.maybeSigned().catch(v)}pendingIndexedLength(){let O=this.applying.indexed.length;if(!this.applying||!this.updates.length||!O)return this.indexedLength;let P=0;for(;O>0&&P<this.updates.length;)O-=this.updates[P++].batch;return this.updates[P-1].systemLength}async _assertNode(O,P){const Z=await this.system.get(O.writer.core.key)||{length:0,isRemoved:!1},he=Z.length+P;O.length!==he&&(console.trace("INVALID_INSERTION","length=",O.length,"key=",O.writer.core.key,"local=",O.writer.core.writable,"batch=",P,"dag=",Z),process.exit(1))}_postApply(){this.applyBatch=this.applying=null,this.base._postApply()}async _optimisticApply(O,P,Z){const he=this.system.checkpoint();this.system.addHead(P);const se=[],G=P.writer.core.key;se.push({indexed:Z,optimistic:!0,from:P.writer.core,length:P.length,value:P.value,heads:P.actualHeads});const re=await this.system.get(G),W=re?re.length:0;let $=!1;this.applying=O,this.applyBatch=se;try{await this.base._handlers.apply(se,this.view,this.hostcalls)}catch{$=!0}if(this._postApply(),!$){const S=await this.system.get(G);(!S||W===S.length)&&($=!0)}if(!$)return await this._refreshWriters(),!0;this.system.applyCheckpoint(he),this.encryptionView.core.length!==this.system.encryptionLength&&await this.encryptionView.core.truncate(this.system.encryptionLength);for(const S of this.views){const N=S.core?S.core.length:S.length,D=this.getViewFromSystem(S),H=D?D.length:0;H!==N&&await S.core.truncate(H)}return await this._refreshWriters(),await this._rollbackViews(),!1}async update(O,P){this.changes!==null&&this.changes.track(this);let Z=0,he=[],se=0,G=0,re=0,W=-1;for(;re<Math.min(O.indexed.length,O.shared);){const S=O.indexed[re++];if(S.batch>1)continue;if(this.base._shiftWriter(S.writer),this.updates[G++].indexers){se=re;break}}for(O.undo&&await this.undo(O.undo),this.system.bootstrapping&&await this.bootstrap(),await this._updateSystem(),re=O.shared;re<O.length;re++){const S=re<O.indexed.length,N=S?O.indexed[re]:O.tip[re-O.indexed.length];if(Z++,!(N.writer.isRemoved&&N.optimistic&&Z===1&&this.base._hasOptimisticApply===!0&&await this._optimisticApply(O,N,S))){if(N.writer.isRemoved&&!N.writer.isActiveIndexer){if(N.batch>1)continue;const ce={seq:0,key:N.writer.core.key,length:N.length,batch:Z,systemLength:0,indexers:!1};this._pushUpdate(ce),Z=0,a(he.length===0,"Apply batch should not have been modified");continue}const _e=N.causalDependencies();for(let ce=_e.length-1;ce>=1;ce--){const J=_e[ce];await this.system.linkable(J.writer.core.key,J.length,!0)&&this.system.addHead(_e[ce])}if(this.system.addHead(_e[0]),N.value!==null&&!N.writer.isRemoved&&he.push({indexed:S,optimistic:!1,from:N.writer.core,length:N.length,value:N.value,heads:N.actualHeads}),N.batch>1)continue;he.length&&this.base._hasApply===!0&&(this.applying=O,this.applyBatch=he,await this.base._handlers.apply(he,this.view,this.hostcalls),W===-1&&this.pendingFork&&(W=re),this._postApply())}const H={seq:0,key:N.writer.core.key,length:N.length,batch:Z,systemLength:0,indexers:!1};H.indexers=!!this.system.indexerUpdate,this.system.indexerUpdate&&await this._generateNextViews(),await this.system.flush(this.views),await this.system.update(),Z=0,he=[],this._pushUpdate(H),!(!S||se)&&(this.base._shiftWriter(N.writer),H.indexers&&(se=re+1))}if(this.pendingFork){const S=this.pendingFork;if(S.length>this.indexedLength&&this._indexUpdates(O.indexed.length),!await new E(this.base,this.store,this,S).upgrade())throw new Error("Fork failed");return await this._flush(P),{reboot:!0,migrated:!1}}O.indexed.length&&this._indexUpdates(se||O.indexed.length);const $=se!==0;return $&&(this.key=await this.base._premigrate()),this.changes!==null&&(this.changes.finalise(),await this.base._handlers.update(this.view,this.changes)),await this._flush(P),{reboot:$,migrated:$}}flush(){return this._flush(null)}async _appendLocalNodes(O){if(O.length===0)return;const P=new Array(O.length),Z=this.local;Z.opened||await Z.ready();for(let he=0;he<P.length;he++){const{value:se,heads:G,batch:re,optimistic:W}=O[he];P[he]={version:_,maxSupportedVersion:this.base.maxSupportedVersion,checkpoint:null,digest:null,optimistic:W,node:{heads:G,batch:re,value:se===null?null:p.encode(this.base.valueEncoding,se)},trace:[]}}if(this.localIndexer){const he=this.localCheckpoint.signedLength(),se=this.local;let G=0,re=null,W=null;if(this.indexedLength>he){const $=await this.system.getIndexedInfo(this.indexedLength);re=await this._signInternalViewCores($),W=await this._signUserViewCores($),G=se.length+P.length}for(let $=0;$<P.length;$++){const S=se.length+$+1;S===G&&(this.localCheckpoint.updateInternalSignatures(S,re),this.localCheckpoint.updateUserSignatures(S,W));const N=P[$];N.checkpoint=this.localCheckpoint.makeCheckpoints(S),N.digest=this.localCheckpoint.makeDigest(S,this.key)}}else{this.localCheckpoint||await this._startLocalCheckpoint();for(let he=0;he<P.length;he++){const se=Z.length+he+1;P[he].digest=this.localCheckpoint.makeDigest(se,this.key)}}await Z.append(P)}async _rollbackViews(){for(const O of this.views){const P=this.getViewFromSystem(O);P?O.key=P.key:await this._resetView(O)}}async createAnchor(){const O=this.applyBatch[this.applyBatch.length-1],P=O.from.key,Z=O.length,he=await this.system.get(P,{unflushed:!0});if(!he||he.length<Z)throw new Error("Anchor node is not in system");const se={start:0,end:40,buffer:g.alloc(40)};p.fixed32.encode(se,P),p.uint64.encode(se,Z);const G=l.hash(se.buffer),re=p.encode(u.ManifestData,{version:0,legacyBlocks:0,namespace:G}),W=this.encryption?c.PADDING:0,$=m(null,{heads:[{key:P,length:Z}],padding:W});this.encryption&&await this.encryption.encryptAnchor($,G);const S={index:0,size:$.byteLength,hash:l.data($)},D={hash:l.tree([S]),length:1},H=this.store.createAnchorCore(D,re);await H.ready(),H.length===0&&await H.append($,{writable:!0,maxLength:1}),await this.system.add(H.key,{isIndexer:!1,length:0}),await this.base._addWriter(H.key,this.system);const _e={key:H.key,length:H.length};return await H.close(),await this.base.hintWakeup(_e),_e}async _resetView(O){const P=await this.store.getIndexerManifests(this.system.indexers),Z=O.core?O.core.manifest.userData:null;O.key=await this.store.createView(P,O.name,null,this.system.core.manifest.version,this.system.entropy,null,Z),O.length=0}async _generateNextViews(){const O=this.system,P=await this.store.getIndexerManifests(O.indexers),Z=O.version<2?null:O.getEntropy(O.indexers,O.flushLength());for(const he of this.views){const se=he.core?he.core.manifest.userData:null,G=await j(he),re=await this.store.createView(P,he.name,G,O.core.manifest.version,Z,null,se);he.key=re}}};async function j(ue){const O=ue.core?ue.core.length:ue.length;return O?{hash:await ue.core.treeHash(O),length:O}:null}function v(){}function w(ue,O){return ue.signedLength()-O.signedLength()}function R(ue,O){return!ue||!O?ue===O:ue.length===O.length}function A(ue,O){if(!ue||!O)return ue===O;if(ue.length!==O.length)return!1;for(let P=0;P<ue.length;P++)if(ue[P].length!==O[P].length)return!1;return!0}function q(ue,O,P){return{length:ue,core:O.core,ref:O.ref,signatures:new Array(P),partials:new Array(P)}}function U(ue,O,P){const{signer:Z,signatures:he}=O[P];ue[0].signatures[P]={signature:he.system.signature,length:he.system.length,signer:Z},ue[1]&&(ue[1].signatures[P]={signature:he.encryption.signature,length:he.encryption.length,signer:Z});for(let se=2;se<ue.length;se++){if(!ue[se])continue;const{length:G,signature:re}=he.user[se-2];ue[se].signatures[P]={signature:re,length:G,signer:Z}}}async function T(ue,O){const P=ue.signatures[O];P.length<ue.length&&P.length>0&&await ue.core.get(P.length-1),ue.partials[O]=await h(ue.core,P.signer,ue.length,P.length,P.signature)}function Q(ue,O,P){return O?{signature:O.signature,length:O.length,at:ue}:P}function le(ue,O,P){const Z=new Array(O.length);for(let he=0;he<Z.length;he++)Z[he]=Q(ue,O[he],he<P.length?P[he]:null);return Z}function Y(ue,O){if(!O)return null;const P=ue-O.at;return{checkpointer:P,checkpoint:P===0?{signature:O.signature,length:O.length}:null}}function oe(ue,O){if(!O.length)return null;const P=new Array(O.length);for(let Z=0;Z<O.length;Z++)P[Z]=Y(ue,O[Z]);return P}return Td}var Dd,yb;function tx(){if(yb)return Dd;yb=1;const n=et(),a=ni();return Dd=async function(l,g,{encrypt:y,encryptionKey:h,keyPair:o,exclusive:c=!0}={}){const s={key:null,local:null,bootstrap:null,encryptionKey:null,boot:null},u=o?{version:l.manifestVersion,signers:[{publicKey:o.publicKey}]}:null;if(g){s.key=g;const E=l.get({key:g,active:!1,valueEncoding:a.OplogMessage});await E.ready();const b=await E.getUserData("autobase/local");if(o)s.local=l.get({keyPair:o,active:!1,exclusive:c,valueEncoding:a.OplogMessage,manifest:u});else if(E.writable&&!b)s.local=E.session({active:!1,exclusive:c,valueEncoding:a.OplogMessage});else{const _=b?l.get({key:b,active:!1,exclusive:c,valueEncoding:a.OplogMessage}):l.get({name:"local",active:!1,exclusive:c,valueEncoding:a.OplogMessage});await _.ready(),s.local=_}s.bootstrap=E}else{s.local=o?l.get({keyPair:o,manifest:u,active:!1,exclusive:c,valueEncoding:a.OplogMessage}):l.get({name:"local",active:!1,exclusive:c,valueEncoding:a.OplogMessage}),await s.local.ready();const E=await s.local.getUserData("referrer");E?(s.key=E,s.bootstrap=l.get({key:E,active:!1,valueEncoding:a.OplogMessage}),await s.bootstrap.ready()):(s.key=s.local.key,s.bootstrap=s.local.session({active:!1,valueEncoding:a.OplogMessage}),await s.bootstrap.setUserData("autobase/local",s.local.key))}(g||o)&&(await s.bootstrap.setUserData("referrer",s.key),await s.bootstrap.setUserData("autobase/local",s.local.key),await s.local.setUserData("referrer",s.key));const[f,m]=await Promise.all([s.local.getUserData("autobase/encryption"),s.local.getUserData("autobase/boot")]);return m&&(s.boot=n.decode(a.BootRecord,m)),f&&(s.encryptionKey=f),!s.encryptionKey&&(h||y)&&(h||(h=(await l.createKeyPair("autobase/encryption")).secretKey.subarray(0,32)),await s.bootstrap.setUserData("autobase/encryption",h),await s.local.setUserData("autobase/encryption",h),s.encryptionKey=h),s},Dd}var Bd,_b;function nx(){if(_b)return Bd;_b=1;const n=Ue(),a=Rn(),p=Lv(),l=et(),g=jt(),y=ol(),h=On(),o=Dv(),c=N1(),s=qv(),u=U1(),f=go(),m=Wf(),E=e0(),b=i0(),_=_o(),{EncryptionView:B}=mo(),M=c0(),z=ni(),j=GS(),v=WS(),{encodeValue:w,decodeValue:R}=h0(),A=QS(),q=XS(),U=ZS(),T=$S(),Q=ex(),{PublicApplyCalls:le}=u0(),Y=tx(),{MAX_AUTOBASE_VERSION:oe,BOOT_RECORD_VERSION:ue}=yo(),O=Symbol.for("nodejs.util.inspect.custom"),P=new Error("Apply interrupted"),Z=l.from("binary"),he=3,se=1,G=1e4,re=4,W=64,$=3e5;class S{constructor(I,L){this.active=!0,this.discoveryKey=L,this.base=I}onpeeractive(I,L){this.base._bumpWakeupPeer(I)}onlookup(I,L,V){const te=this.base._getWakeup();te.length!==0&&V.announce(L,te)}onannounce(I,L,V){if(this.base.isFastForwarding()){this.base._needsWakeupRequest=!0;return}this.base.hintWakeup(I)}}Bd=class extends a{constructor(I,L,V={}){Array.isArray(L)&&(L=L[0]),L&&typeof L!="string"&&!n.isBuffer(L)&&(V=L,L=null),super();const te=L?N(L):null;this.id=null,this.key=te,this.discoveryKey=null,this.keyPair=null,this.valueEncoding=l.from(V.valueEncoding||"binary"),this.store=I,this.globalCache=I.globalCache||null,this.migrated=!1,this.encrypted=V.encrypted||!!V.encryptionKey,this.encrypt=!!V.encrypt,this.encryptionKey=V.encryptionKey||null,this.encryption=null,this.local=null,this.localWriter=null,this.isIndexer=!1,this.activeWriters=new A,this.linearizer=null,this.updating=!1,this.nukeTip=!!V.nukeTip,this.wakeupOwner=!V.wakeup,this.wakeupCapability=null,this.wakeupProtocol=V.wakeup||new u,this.wakeupSession=null,this._primaryBootstrap=null,this.fastForwardEnabled=V.fastForward!==!1,this.fastForwarding=null,this.fastForwardTo=null,this.fastForwardFailedAt=0,this.fastForwardMinimum=U.MINIMUM,this._bootstrapWriters=[],this._bootstrapWritersChanged=!1,this._flushSignal=new o,this._flushing=0,this._checkWriters=[],this._optimistic=-1,this._appended=0,this._appending=null,this._wakeup=new q(this),this._wakeupHints=new Map,this._wakeupPeerBound=this._wakeupPeer.bind(this),this._coupler=null,this._updateLocalCore=null,this._lock=s(),this._needsWakeupRequest=!1,this._needsWakeup=!0,this._needsWakeupHeads=!0,this._updates=[],this._handlers=V||{},this._warn=k.bind(this),this._draining=!1,this._writable=null,this._advancing=null,this._interrupting=!1,this._caughtup=!1,this.paused=!1,this._bump=p(()=>(this._advancing=this._advance(),this._advancing)),this._onremotewriterchangeBound=this._onremotewriterchange.bind(this),this._onlocalwriterchangeBound=this._onlocalwriterchange.bind(this),this._preopen=null,this._hasOpen=!!this._handlers.open,this._hasApply=!!this._handlers.apply,this._hasOptimisticApply=!!this._handlers.optimistic,this._hasUpdate=!!this._handlers.update,this._hasClose=!!this._handlers.close,this._viewStore=new T(this),this._applyState=null,this.view=null,this.core=null,this.version=-1,this.interrupted=null,this.recoveries=he;const{ackInterval:de=G,ackThreshold:C=re}=V;this._ackInterval=de,this._ackThreshold=C,this._ackTickThreshold=C,this._ackTick=0,this._ackTimer=null,this._acking=!1,this._waiting=new o,this._bootRecovery=!1,this.view=this._hasOpen?this._handlers.open(this._viewStore,new le(this)):null,this.core=this._viewStore.get({name:"_system"}),this.fastForwardEnabled&&d(V.fastForward)&&this._runFastForward(new U(this,V.fastForward.key,{verified:!1})).catch(ce),this.ready().catch(g)}[O](I,L){let V="";if(typeof L.indentationLvl=="number")for(;V.length<L.indentationLvl;)V+=" ";return V+"Autobase { ... }"}get bootstrap(){return this.key}get bootstraps(){return[this.bootstrap]}get writable(){return this.localWriter!==null&&!this.localWriter.isRemoved}get ackable(){return this.localWriter!==null&&this.localWriter.isActiveIndexer}get signedLength(){return this.core.signedLength}get indexedLength(){return this._applyState?this._applyState.indexedLength:0}get length(){return this.core.length}get flushing(){return this._flushing>0}hash(){return this.core.treeHash()}getSystemKey(){return this.core.key}get system(){return this._applyState&&this._applyState.system}async getIndexedInfo(){return this.opened===!1&&await this.ready(),this._applyState&&this._applyState.system.getIndexedInfo(this._applyState.indexedLength)}_isActiveIndexer(){return this.localWriter?this.localWriter.isActiveIndexer:!1}replicate(I,L){const V=this.store.replicate(I,L);return this.wakeupProtocol.addStream(V),V}heads(){if(!this._applyState||!this._applyState.opened)return[];const I=new Array(this._applyState.system.heads.length);for(let L=0;L<this._applyState.system.heads.length;L++)I[L]=this._applyState.system.heads[L];return I.sort(H)}hintWakeup(I){Array.isArray(I)||(I=[I]);for(const{key:L,length:V}of I){const te=n.toString(L,"hex"),de=this._wakeupHints.get(te);(!de||V===-1||de<V)&&this._wakeupHints.set(te,V)}this._queueBump()}_queueBump(){this._bump().catch(g)}async _runPreOpen(){this._handlers.wait&&await this._handlers.wait(),await this.store.ready(),this.keyPair=await this._handlers.keyPair||null;const I=await Y(this.store,this.key,{encryptionKey:this.encryptionKey,encrypt:this.encrypt,keyPair:this.keyPair}),L=await I.local.getUserData("autobase/boot");if(L){const{recoveries:V}=l.decode(z.BootRecord,L);this.recoveries=V}this._primaryBootstrap=I.bootstrap,this.local=I.local,this.key=I.bootstrap.key,this.discoveryKey=I.bootstrap.discoveryKey,this.id=I.bootstrap.id,this.encryptionKey=I.encryptionKey,this.encrypted&&h(this.encryptionKey!==null,"Encryption key is expected"),this.encryptionKey&&(this.encryption=new B(this,null),this.local.setEncryption(this.getWriterEncryption()),this._primaryBootstrap.setEncryption(this.getWriterEncryption())),this.nukeTip&&await this._nukeTip(),this.local.on("append",this._onlocalwriterchangeBound),this.wakeupCapability=await this._handlers.wakeupCapability||{key:this.key,discoveryKey:this.discoveryKey},this.setWakeup(this.wakeupCapability.key,this.wakeupCapability.discoveryKey)}async _nukeTipBatch(I,L){const V=this.store.get({key:I,active:!1});await V.ready();const te=V.session({name:"batch"});await te.ready(),te.length>L&&await te.truncate(L),await te.close(),await V.close()}async _nukeTip(){const I=await this.local.getUserData("autobase/boot");if(!I)return;const L=l.decode(z.BootRecord,I);await E.clear(this.local),await this._nukeTipBatch(L.key,L.systemLength);const V=this.store.get({key:L.key,active:!1,encryption:null}),te=await B.setSystemEncryption(this,V),de=V.session({name:"batch"});await de.ready();const C=await _.getIndexedInfo(de,L.systemLength);await de.close();for(const ee of C.views)await this._nukeTipBatch(ee.key,ee.length);L.heads&&this.hintWakeup(L.heads),this.local.length&&this.hintWakeup([{key:this.local.key,length:this.local.length}]),await V.close(),te&&await te.close()}_bumpWakeupPeer(I){this._coupler&&this._coupler.update(I.stream)}async _rotateLocalWriter(I){h(!this.writable,"Cannot rotate a newLocal writer if a current one is open");const L=this.local;this._applyState&&await this._applyState.close(),this.local=I,this.local.on("append",this._onlocalwriterchangeBound),this.localWriter=null,this._updateLocalCore=null;const V=this._viewStore.atomize(),te=V.getLocal();await te.ready(),await E.moveTo(L,te),await te.setUserData("referrer",this.key),this.encryptionKey&&await te.setUserData("autobase/encryption",this.encryptionKey),await V.flush(),await V.close(),await this._primaryBootstrap.setUserData("autobase/local",te.key),await this._clearWriters(),await L.close(),await this._viewStore.updateLocal(),await this._clearWriters(),this._applyState=new Q(this),await this._applyState.ready(),await this._makeLinearizerFromViewState(),this._caughtup=!1,this._rebooted()}async setLocal(I,{keyPair:L}={}){this.opened||await this.ready();const V=L?{version:this.store.manifestVersion,signers:[{publicKey:L.publicKey}]}:null;if(I||(I=m.key(V)),n.equals(I,this.local.key))return;const te=this.encryptionKey?this.getWriterEncryption():null,de=this.store.get({key:I,manifest:V,active:!1,exclusive:!0,encryption:te,valueEncoding:z.OplogMessage});await de.ready(),this._updateLocalCore=de,await this._bump()}setWakeup(I,L){this.wakeupSession&&this.wakeupSession.destroy(),!L&&n.equals(I,this.key)&&(L=this.discoveryKey),this.wakeupSession=this.wakeupProtocol.session(I,new S(this,L||null));for(const V of this.wakeupSession.peers)V.active&&this._bumpWakeupPeer(V)}async _getMigrationPointer(I,L){const V=this.store.get({key:I,active:!1,encryption:null}),te=await B.setSystemEncryption(this,V),de=V.manifest&&V.manifest.prologue?V.manifest.prologue.length:0;for(let C=L-1;C>=de;C--){if(!await V.has(C))continue;const ee=new _(V,{checkout:C+1});await ee.ready();let fe=!0;for(const ve of ee.views){const we=this.store.get({key:ve.key,active:!1});await we.ready(),we.length<ve.length&&(fe=!1),await we.close()}if(await ee.close(),!!fe)return C+1}return await V.close(),te&&await te.close(),de}async _migrate6(I,L){const V=this.store.get({key:I,active:!1});await V.ready();const te=V.session({name:"batch",overwrite:!0,checkout:L});await te.ready(),await te.close(),await V.close()}async _getSystemInfo(){const I=await this._getBootRecord();if(!I.key)return null;const L=!!I.heads,V=I.systemLength;L&&await this._migrate6(I.key,V);const te=this.store.get({key:I.key,encryption:null,active:!1});await te.ready();const de=te.session({name:"batch"}),C=await B.setSystemEncryption(this,de),ee=await _.getIndexedInfo(de,V);if(C&&await C.close(),await de.close(),await te.close(),ee.version>oe)throw new Error("Autobase upgrade required.");if(L){this.migrated=!0;for(const fe of ee.views)await this._migrate6(fe.key,fe.length);I.heads&&this.hintWakeup(I.heads),this.local.length&&this.hintWakeup([{key:this.local.key,length:this.local.length}])}return{key:I.key,indexers:ee.indexers,views:ee.views,entropy:ee.entropy}}async _getBootRecord(){await this._preopen;const I=await this.local.getUserData("autobase/boot"),L=I?l.decode(z.BootRecord,I):{version:ue,key:null,systemLength:0,indexersUpdated:!1,fastForwarding:!1,recoveries:he,heads:null};if(L.heads){const V=await this._getMigrationPointer(L.key,L.systemLength);V!==L.systemLength&&this._warn(new Error("Invalid pointer in migration, correcting ("+V+" vs "+L.systemLength+")")),L.systemLength=V}return L}static async getBootRecord(I,L){const V=await Y(I,L,{exclusive:!1});return await V.bootstrap.close(),await V.local.close(),V.boot}_interrupt(I){throw h(!!this._applyState.applying,"Interrupt is only allowed in apply"),this._interrupting=!0,I&&(this.interrupted=I),P}async flush(){if(this._flushing!==0)return this._flushSignal.wait()}async advance(){this.opened===!1&&await this.ready(),await this._advancing}recouple(){this._coupler&&this._coupler.destroy();const I=this._viewStore.getSystemCore();this._coupler=new c(I,this._wakeupPeerBound)}_updateBootstrapWriters(){const I=this.linearizer.getBootstrapWriters();for(const L of this._bootstrapWriters)L.isBootstrap=!1,L.isCoupled=!1;for(const L of I)L.isCoupled=!0,L.setBootstrap(!0);for(const L of this._bootstrapWriters)L.isBootstrap===!1&&L.setBootstrap(!1);this._bootstrapWriters=I,this._bootstrapWritersChanged=!1}async _openLinearizer(){if(this._applyState.system.bootstrapping){await this._makeLinearizer(null),this._bootstrapLinearizer();return}await this._makeLinearizerFromViewState()}async _catchupApplyState(){await this._applyState.shouldMigrate()?await this._migrate():await this._applyState.catchup(this.linearizer),this._caughtup=!0}async _open(){if(this._preopen=this._runPreOpen(),await this._preopen,!this.closing){this._applyState=new Q(this);try{await this._applyState.ready()}catch(I){if(this.closing)return;try{await this._applyState.close()}catch{}try{await this.core.ready()}catch{}if(this._applyState=null,this.closing)return;if(this._warn(new Error("Failed to boot due to: "+I.message)),this.recoveries<he){this._bootRecovery=!0,this._queueBump();return}throw I}try{await this._openLinearizer(),await this.core.ready(),await this._wakeup.ready()}catch(I){if(this.closing)return;throw I}this.core.length-this._applyState.indexedLength>this._ackTickThreshold&&(this._ackTick=this._ackTickThreshold),this.localWriter&&this._ackInterval&&this._startAckTimer(),this._updateBootstrapWriters(),this.recouple(),this._queueFastForward(),this._queueBump()}}async _close(){await this.flush(),this._interrupting=!0,await Promise.resolve(),this.wakeupSession&&this.wakeupSession.destroy(),this.wakeupOwner&&this.wakeupProtocol.destroy(),this.fastForwarding&&await this.fastForwarding.close(),this._coupler&&this._coupler.destroy(),this._coupler=null,this._waiting.notify(null),await this.activeWriters.clear();const I=this._advancing?this._advancing.catch(g):null;await this._clearWriters(),this._primaryBootstrap&&await this._primaryBootstrap.close(),await this.local.close(),this._ackTimer&&(this._ackTimer.stop(),await this._ackTimer.flush()),await this._wakeup.close(),this._hasClose&&await this._handlers.close(this.view),this._applyState&&await this._applyState.close(),await this._viewStore.close(),await this.core.close(),await this.store.close(),this._writable&&this._writable.resolve(!1),await I}_onError(I){if(!this.closing){if(I===P){this.emit("interrupt",this.interrupted),this.emit("update");return}if(this.close().catch(g),a.listenerCount(this,"error")===0){J(I);return}this.emit("error",I)}}async _closeWriter(I){this.activeWriters.delete(I),await I.close()}async _gcWriters(){if(this._checkWriters.length!==0){for(;this._checkWriters.length>0;){const I=this._checkWriters.pop();I.updateActivity(),!(!I.flushed()||!this._wakeup.unqueue(I.core.key,I.core.length)||I.isActiveIndexer)&&this.localWriter!==I&&await this._closeWriter(I)}await this._wakeup.flush()}}_startAckTimer(){this._ackTimer||(this._ackTimer=new j(this._backgroundAck.bind(this),this._ackInterval),this._bumpAckTimer())}_bumpAckTimer(){this._ackTimer&&this._ackTimer.bump()}async update(){this.opened===!1&&await this.ready();try{await this._bump(),this._acking&&await this._bump()}catch(I){if(this._interrupting)return;throw I}}async _onremotewriterchange(){this._bumpAckTimer();try{await this._bump()}catch{}}_onlocalwriterchange(){(!this.localWriter||this.localWriter.isRemoved)&&this._queueBump()}_onwakeup(){this._needsWakeup=!0,this._queueBump()}isFastForwarding(){return this.fastForwardTo!==null?!0:this.fastForwardEnabled&&this.fastForwarding!==null}_backgroundAck(){return this.ack(!0)}async ack(I=!1){if(this.opened===!1&&await this.ready(),this.localWriter===null||this._acking||this._interrupting||this._appending!==null)return;if(this._applyState===null){try{await this._bump()}catch{}if(this._applyState===null||this._interrupting)return}const L=this._applyState;L.opened===!1&&await L.ready();const V=L.isLocalPendingIndexer();if(!V&&this.isFastForwarding()||this._interrupting||!(L.isLocalIndexer()||V))return;this._acking=!0;try{await this._bump()}catch(C){if(!this._interrupting)throw C}if(this._interrupting||!this.localWriter||this.localWriter.closed){this._acking=!1;return}if(this._ackTimer&&I&&await this._ackTimer.asapStandalone(),this._interrupting){this._acking=!1;return}if(V||this._applyState.shouldWrite()||this.linearizer.shouldAck(this.localWriter,!1))try{this.localWriter&&!this.localWriter.closed&&await this.append(null)}catch(C){if(!this._interrupting)throw C}this._interrupting||(this._updateAckThreshold(),this._bumpAckTimer()),this._acking=!1}views(){return this._applyState?this._applyState.store.listViews():this._viewStore.listViews()}async append(I,L){if(this.opened===!1&&await this.ready(),this._advancing!==null&&await this._advancing,this._interrupting)throw new Error("Autobase is closing");I&&this.valueEncoding!==Z&&(I=X(this.valueEncoding,I));const V=!!L&&!!L.optimistic&&!!I;if(!V&&(this.localWriter===null||this.localWriter.isRemoved&&I!==null))throw new Error("Not writable");this._appending===null&&(this._appending=[]);let te=0;if(Array.isArray(I))for(const fe of I)te=this._append(fe);else te=this._append(I);const de=this.local.length;V&&(this._optimistic=this._appending.length-1);const C=this._appended+this._appending.length;this._advancing&&await this._advancing;let ee=0;for(;this._appended<C&&!this._interrupting&&(await this._bump(),!(ee++>=16&&this.localWriter&&this.localWriter.idle())););return this._advancing&&await this._advancing,de+te}_append(I){if(this._appending.length>0){if(I===null)return this._appending.length;this._appending[this._appending.length-1]===null&&this._appending.pop()}return this._appending.push(I)}static decodeValue(I,L){return R(I,L)}static encodeValue(I,L){return w(I,L)}static async getLocalKey(I,L={}){const V=L.keyPair?I.get({...L,active:!1}):I.get({...L,name:"local",active:!1});await V.ready();const te=V.key;return await V.close(),te}static getLocalCore(I,L,V){const te=V?{key:V}:null,de={...L,compat:!1,active:!1,exclusive:!0,valueEncoding:z.OplogMessage,encryption:te};return de.keyPair?I.get(de):I.get({...de,name:"local"})}static async getUserData(I){const L=await I.getUserData("autobase/view");return{referrer:await I.getUserData("referrer"),view:L?n.toString(L):null}}static async isAutobase(I,L={}){const V=await I.get(0,L);if(!V)throw new Error("Core is empty.");if(!n.isBuffer(V))return D(V);try{const te=l.decode(z.OplogMessage,V);return D(te)}catch{return!1}}async setUserData(I,L){await this._preopen,await(this._primaryBootstrap===null?this.local:this._primaryBootstrap).setUserData(I,L)}async getUserData(I){return await this._preopen,await(this._primaryBootstrap===null?this.local:this._primaryBootstrap).getUserData(I)}_needsLocalWriter(){return this.localWriter===null||this.localWriter.closed}async _getWriterByKey(I,L,V,te,de,C){h(this._draining===!0||this.opening&&!this.opened||this._optimistic>-1);const ee=await this._lock();if(this._interrupting)throw ee(),new Error("Autobase is closing");try{let fe=this.activeWriters.get(I);const ve=!!fe,we=C||this._applyState.system,F=await we.get(I);if(L===-1){if(!te&&F===null)return fe&&(fe.isRemoved=!de),null;L=F===null?0:F.length}const ne=F!==null&&(de||!F.isRemoved),ye=!ne;if(fe)fe.isRemoved=ye;else if(fe=this._makeWriter(I,L,ne,ye),!fe)return null;return ye&&we.bootstrapping&&n.equals(fe.core.key,this.key)&&(fe.isRemoved=!1),this._isLocalCore(fe.core)&&this._needsLocalWriter()&&this._setLocalWriter(fe),fe.seen(V),ve?fe:(await fe.ready(),this._isLocalCore(fe.core)&&this._needsLocalWriter()&&this._setLocalWriter(fe),te&&fe.flushed()&&(this._wakeup.unqueue(I,L),fe!==this.localWriter)?(await fe.close(),fe):(this.activeWriters.add(fe),this._checkWriters.push(fe),h(fe.opened),h(!fe.closed),fe.updateActivity(),fe))}finally{ee()}}_updateAll(){const I=[];for(const L of this.activeWriters)I.push(L.update(null).catch(this._warn));return Promise.all(I)}getWriterEncryption(){return this.encryptionKey?this.encryption.getWriterEncryption():null}_makeWriterCore(I){if(this.closing)throw new Error("Autobase is closing");if(this._interrupting)throw P();const L=n.equals(I,this.local.key),V=this.getWriterEncryption();return L?this.local.session({valueEncoding:z.OplogMessage,encryption:V,active:!1}):this.store.get({key:I,compat:!1,writable:!1,valueEncoding:z.OplogMessage,encryption:V,active:!1})}_makeWriter(I,L,V,te){const de=this._makeWriterCore(I),C=new v(this,de,L,te);return this._isLocalCore(de)?(V&&this._setLocalWriter(C),C):(de.on("append",this._onremotewriterchangeBound),de.on("download",this._onremotewriterchangeBound),de.on("manifest",this._onremotewriterchangeBound),C)}_updateLinearizer(I,L){for(const V of this.activeWriters)V.isActiveIndexer=!1;this.localWriter&&(this.localWriter.isActiveIndexer=!1);for(const V of I)V.isActiveIndexer=!0;this._isActiveIndexer()&&!this.isIndexer?this._setLocalIndexer():!this._isActiveIndexer()&&this.isIndexer&&this._clearLocalIndexer(),this.linearizer=new b(I,{heads:L,writers:this.activeWriters}),this._updateAckThreshold()}async _updateLocalWriter(I){this.localWriter!==null&&!this.localWriter.closed||await this._getWriterByKey(this.local.key,-1,0,!0,!1,I)}async _bootstrapLinearizer(){const I=this._makeWriter(this.key,0,!0,!1);this.activeWriters.add(I),this._checkWriters.push(I),await I.ready(),this._ensureWakeup(I),this._updateLinearizer([I],[])}async _makeLinearizer(I){if(I===null)return this._bootstrapLinearizer();(this.opened||await I.hasLocal(this.local.key))&&await this._updateLocalWriter(I);const L=[];for(const V of I.indexers){const te=await this._getWriterByKey(V.key,V.length,0,!1,!1,I);L.push(te)}if(!this._isActiveIndexer()){for(const V of I.pendingIndexers)if(n.equals(V,this.local.key)){this._setLocalIndexer();break}}this._updateLinearizer(L,I.heads);for(const{key:V,length:te}of I.heads)await this._getWriterByKey(V,te,0,!1,!1,I)}async _clearWriters(){await this.activeWriters.clear(),this.localWriter!==null&&await this.localWriter.close(),this._checkWriters=[]}async _makeLinearizerFromViewState(){const I=await this._applyState.getIndexedSystem();await this._makeLinearizer(I),await I.close()}async _runForceFastForward(){await this.core.ready(),!this.closing&&await this._runFastForward(new U(this,this.core.key,{force:!0}))}async forceFastForward(){this.isFastForwarding()||(await this._runForceFastForward(),await this.update())}async _recoverMaybe(){if(!this._applyState){if(!this._bootRecovery)return;await this._runForceFastForward(),this._queueBump();return}this._bootRecovery=!1;const I=await this._applyState.recoverAt();!I||this.fastForwardTo||(this.fastForwardTo=I,this._queueBump())}async _applyFastForward(){if(!this.fastForwardTo.force&&this.fastForwardTo.length<this.core.length+this.fastForwardTo.minimum){this.fastForwardTo=null,this._updateActivity();return}this._flushing++;try{const I=this._hasUpdate?new M(this):null;I&&I.track(this._applyState),this._applyState&&await this._applyState.close();const{key:L,length:V,views:te,indexers:de,manifestVersion:C,entropy:ee}=this.fastForwardTo,fe=this.core.signedLength,ve=this._viewStore.atomize(),we=new Set,F=!n.equals(L,this.core.key),ne=await this._viewStore.findViewByKey(L,de,C,ee);we.add(ne),F?await this._applyFastForwardMigration(ne,{key:L,length:V}):await ne.catchup(ve.atom,V);for(const qe of te){const Oe=await this._viewStore.findViewByKey(qe.key,de,C,ee);Oe&&(we.add(Oe),F?await this._applyFastForwardMigration(Oe,qe):await Oe.catchup(ve.atom,qe.length))}if(F){const qe=await this._viewStore.getIndexerManifests(de);for(const[Oe,Pe]of this._viewStore.byName)we.has(Pe)||await this._migrateView(qe,null,Oe,0,C,ee,[],null)}const ye=l.encode(z.BootRecord,{version:ue,key:L,systemLength:V,indexersUpdated:!1,fastForwarding:!0,recoveries:he}),me=ve.getLocal();await me.ready(),await me.setUserData("autobase/boot",ye),await E.clear(me),I&&I.finalise(),await ve.flush(),await ve.close();const Ee=this.core.signedLength;for(const qe of we)await qe.release();this.recoveries=he,this.fastForwardTo=null,this._queueFastForward(),await this._clearWriters(),this._applyState=new Q(this),await this._applyState.ready(),I&&await this._handlers.update(this._applyState.view,I),await this._applyState.shouldMigrate()?await this._migrate():(await this._makeLinearizerFromViewState(),await this._applyState.catchup(this.linearizer)),(!this.localWriter||this.localWriter.closed)&&await this._updateLocalWriter(this._applyState.system),this._caughtup=!0,this._rebooted(),this.emit("fast-forward",Ee,fe)}finally{--this._flushing===0&&this._flushSignal.notify()}}async _applyFastForwardMigration(I,L){const V=this.store.get(L.key);await V.ready();const te=V.manifest&&V.manifest.prologue;if(te&&te.length>0&&I.core.length>=te.length)try{await V.core.copyPrologue(I.core.state)}catch{}const de=V.session({name:"batch",overwrite:!0,checkout:L.length});await de.ready(),await I.batch.state.moveTo(de,de.length),await de.close(),I.migrated(this,V)}async _migrateView(I,L,V,te,de,C,ee,fe){const ve=this._viewStore.byName.get(V),we=te===0?null:{length:te,hash:await L.treeHash(te)};fe===null&&ve.core.manifest.userData!==null&&(fe=ve.core.manifest.userData);const F=this._viewStore.getViewCore(I,V,we,de,C,ee,fe);await F.ready(),te>0&&await F.core.copyPrologue(L.state);const ne=F.session({name:"batch",overwrite:!0,checkout:te});if(await ne.ready(),L!==null)for(;ne.length<L.length;)await ne.append(await L.get(ne.length));return await ve.batch.state.moveTo(ne,ne.length),await ne.close(),ve.migrated(this,F),ve}async _premigrate(){this._flushing++;try{const I=this._applyState.indexedLength,V=await this._applyState.system.getIndexedInfo(I),te=await this._viewStore.getIndexerManifests(V.indexers),{views:de,systemView:C,encryptionView:ee}=this._applyState,fe=this._applyState.system.core.manifest.version;for(const me of de){const Ee=this._applyState.getViewFromSystem(me,V),qe=Ee?Ee.length:0,Pe=this._viewStore.getViewByName(me.name).getCore();await Pe.ready(),await this._migrateView(te,Pe,me.name,qe,fe,V.entropy,null,null)}const ve=ee.ref.getCore();await ve.ready();const F=[(await this._migrateView(te,ve,"_encryption",V.encryptionLength,fe,V.entropy,null,null)).core.key],ne=C.ref.getCore();return(await this._migrateView(te,ne,"_system",I,fe,V.entropy,F,null,null)).core.key}finally{--this._flushing===0&&this._flushSignal.notify()}}async _migrate(){return this._reboot(await this._premigrate())}async _reboot(I){await this._clearWriters(),await this._makeLinearizerFromViewState(),await this._applyState.finalize(I),this._applyState=new Q(this),await this._applyState.ready(),await this._applyState.catchup(this.linearizer),this._queueFastForward(),this._rebooted()}_rebooted(){this.recouple(),this._updateActivity(),this.emit("reboot"),this._bootstrapWritersChanged=!0,this._needsWakeup=!0,this.updating=!0,this._queueBump()}_setLocalWriter(I){this.localWriter=I,this._ackInterval&&this._startAckTimer()}_unsetLocalWriter(){this.localWriter&&(this._closeWriter(this.localWriter),this.localWriter.isActiveIndexer&&this._clearLocalIndexer(),this.localWriter=null)}_setLocalIndexer(){h(this.localWriter!==null),this.isIndexer=!0,this.emit("is-indexer")}_clearLocalIndexer(){h(this.localWriter!==null),this._ackTimer&&this._ackTimer.stop(),this.isIndexer=!1,this._ackTimer=null,this.emit("is-non-indexer")}_isLocalCore(I){return I.writable&&I.id===this.local.id}_addLocalHeads(){if(!this.localWriter||this.localWriter.closed||!this.localWriter.idle())return null;const I=this._optimistic===-1?this._appending.length:this._optimistic||1,L=new Array(I);for(let V=0;V<I;V++){const te=this.linearizer.getHeads(),de=new Set(this.linearizer.heads),C=this._appending.length-V,ee=this._appending[V],fe=this.localWriter.append(ee,te,C,de,this._optimistic===0);this.linearizer.addHead(fe),L[V]=fe}return L}_flushLocalHeads(I){this._appending=I===this._appending.length?null:this._appending.slice(I),this._appended+=I,this._optimistic>-1&&this._optimistic<I&&(this._optimistic=-1)}async _addRemoteHeads(){let I=0;for(;I<W;){await this._updateAll();let L=0;for(const V of this.activeWriters){let te=V.advance();if(te!==null)for(L+=te.batch;this.linearizer.addHead(te),te.batch!==1;)te=V.advance()}if(L===0)break;I+=L}return I}async _drain(){const I=this.writable;for(;!this._interrupting&&!this.paused;){if(this.fastForwardTo!==null){await this._applyFastForward();continue}if(this._caughtup===!1){await this._catchupApplyState();continue}const L=await this._addRemoteHeads(),V=this._appending!==null?this._addLocalHeads():null;if(this._interrupting)return;(L>0||V!==null)&&(this.updating=!0);const te=this.linearizer.update(),de=te?await this._applyState.update(te,V):{reboot:!1};if(V&&this._flushLocalHeads(V.length),!de.reboot){if(this._applyState.shouldFlush()&&(await this._applyState.flush(),this.updating=!0),this._checkWriters.length>0){await this._gcWriters();continue}if(L>=W)continue;break}await this._gcWriters(),await this._reboot(this._applyState.key)}I!==this.writable&&(this.writable&&this._writable&&this._writable.resolve(!0),this.emit(I?"unwritable":"writable"))}_wakeupPeer(I){if(!this.wakeupSession)return;const L=this._getWakeup();L.length!==0&&this.wakeupSession.announceByStream(I,L)}_getWakeup(){const I=[];for(const L of this.activeWriters)L.isActiveIndexer||L.flushed()||I.push({key:L.core.key,length:L.length});return I}async _wakeupWriter(I,L){this._ensureWakeup(await this._getWriterByKey(I,-1,L,!0,!1,null))}_ensureWakeup(I){I===null||I.isBootstrap===!0||(I.setBootstrap(!0),this._bootstrapWriters.push(I),this._bootstrapWritersChanged=!0)}async _drainWakeup(){const I=[];if(this._needsWakeup){for(const{key:L,length:V}of this._wakeup){const te=this.activeWriters.get(L);if(te){te.length<V&&te.seen(V);continue}I.push(this._applyState.system.get(L))}if(this._needsWakeupHeads)for(const{key:L}of await this._applyState.system.heads)this.activeWriters.has(L)||I.push(this._applyState.system.get(L))}for(const[L,V]of this._wakeupHints){const te=n.from(L,"hex");if(V!==-1){const de=this.activeWriters.get(te);if(de){de.length<V&&de.seen(V);continue}}I.push(this._applyState.system.get(te))}if(await Promise.allSettled(I),this._needsWakeup===!0){this._needsWakeup=!1;for(const{key:L,length:V}of this._wakeup)this.activeWriters.has(L)||await this._wakeupWriter(L,V);if(this._needsWakeupHeads===!0){this._needsWakeupHeads=!1;for(const{key:L}of await this._applyState.system.heads)this.activeWriters.has(L)||await this._wakeupWriter(L,0)}}for(const[L,V]of this._wakeupHints){const te=n.from(L,"hex");if(!this.activeWriters.has(te)){if(V!==-1){const de=await this._applyState.system.get(te);if(de&&V<=de.length)continue}await this._wakeupWriter(te,V===-1?0:V)}}this._wakeupHints.clear()}pause(){this.paused=!0}resume(){this.paused=!1,this._queueBump()}waitForWritable(){return this.writable?Promise.resolve(!0):(this._writable||(this._writable=f()),this._writable.promise)}async _drainWithInterupt(){for(;;)try{await this._drain();return}catch(I){if(this.closing||!this.fastForwardTo)throw I}}async _advance(){if(this.opened===!1&&await this.ready(),this.paused||this._interrupting)return;this._draining=!0,(this.recoveries<se||this._bootRecovery)&&await this._recoverMaybe(),this._updateLocalCore!==null&&await this._rotateLocalWriter(this._updateLocalCore);const I=this.local.length;try{await this._drainWithInterupt(),this._caughtup&&(this._needsWakeup===!0||this._wakeupHints.size>0)&&await this._drainWakeup(),(!this.localWriter||this.localWriter.closed)&&await this._updateLocalWriter(this._applyState.system),this._draining=!1}catch(L){this._onError(L);return}this._interrupting||(this.localWriter&&!this.localWriter.closed&&(this._applyState.isLocalPendingIndexer()?this.ack().catch(ce):this._triggerAckAsap()&&this._ackTimer.asap()),(this.updating===!0||this._bootstrapWritersChanged===!0)&&this._updateBootstrapWriters(),this.updating===!0&&(this.updating=!1,I!==this.local.length?this._resetAckTick():this._ackTick++,this._interrupting||this.emit("update"),this._waiting.notify(null)),this._interrupting||await this._gcWriters())}_triggerAckAsap(){if(!this._ackTimer)return!1;if(this._ackTickThreshold&&!this._acking&&this._ackTick>=this._ackTickThreshold){if(this._ackTimer){for(const I of this.linearizer.indexers)if(I.core.length>I.length)return!1}return!0}return!1}_queueFastForward(){if(!this.core.opened)return;const I=this.core.core.state.length;!this.fastForwardEnabled||this.fastForwarding!==null||this._interrupting||I-this.core.length<this.fastForwardMinimum||this.fastForwardTo===null&&(Date.now()-this.fastForwardFailedAt<$||this._runFastForward(new U(this,this.core.key,{minimum:this.fastForwardMinimum})).catch(ce))}_queueStaticFastForward(I){!this.fastForwardEnabled||this.fastForwarding!==null||this._interrupting||this.fastForwardTo===null&&(Date.now()-this.fastForwardFailedAt<$||this._runFastForward(new U(this,I,{verified:!1})).catch(ce))}_updateActivity(){if(this.activeWriters.updateActivity(),this._applyState&&(this.isFastForwarding()?this._applyState.pause():this._applyState.resume()),this._needsWakeupRequest&&!this.isFastForwarding()&&this.wakeupSession){this._needsWakeupRequest=!1,this.wakeupSession.broadcastLookup({});const I=this._viewStore.getSystemView();I.compatExtension&&I.compatExtension.broadcast()}}_preferFastForward(){this.fastForwardMinimum=1,this._queueFastForward()}_postApply(){this.fastForwardMinimum=U.MINIMUM}async _runFastForward(I){this.fastForwarding=I,this._updateActivity();const L=await I.upgrade();if(await I.close(),this.fastForwarding===I&&(this.fastForwarding=null),!L){I.failed?this.fastForwardFailedAt=Date.now():this._queueFastForward(),this._updateActivity();return}this.fastForwardFailedAt=0,this.fastForwardTo=L,this._applyState&&this._applyState.applying&&this.fastForwardMinimum===1&&await this._applyState.close(),this._bumpAckTimer(),this._queueBump()}async _addWriter(I,L){h(!!this._applyState.applying,"System changes are only allowed in apply");const V=await this._getWriterByKey(I,-1,0,!1,!0,L)||this._makeWriter(I,0,!0,!1);await V.ready(),this.activeWriters.has(I)||(this.activeWriters.add(V),this._checkWriters.push(V),this._ensureWakeup(V)),this._queueBump()}_removeWriter(I){const L=this.activeWriters.get(I);L&&(L.isRemoved=!0),this._queueBump()}removeable(I){return this._applyState?this._applyState.removeable(I):!1}_updateAckThreshold(){this._ackThreshold!==0&&(this._ackTimer&&this._ackTimer.bau(),this._ackTick=0,this._ackTickThreshold=_e(this.linearizer.indexers.length*this._ackThreshold))}_resetAckTick(){this._ackTick=0,this._ackTimer&&this._ackTimer.bau()}_shiftWriter(I){I.shift(),I.flushed()&&this._checkWriters.push(I)}};function N(ie){return n.isBuffer(ie)?ie:y.decode(ie)}function D(ie){return ie.checkpoint?ie.checkpoint.length>0:ie.checkpoint===null}function H(ie,I){return n.compare(ie.key,I.key)}function _e(ie){return Math.floor(ie+Math.random()*ie)}function ce(){}function J(ie){throw queueMicrotask(()=>{throw ie}),ie}function d(ie){return typeof ie=="object"&&ie!==null}function k(ie){g(ie),this.emit("warning",ie)}function X(ie,I){const L={buffer:null,start:0,end:0};return ie.preencode(L,I),L.buffer=n.allocUnsafe(L.end),ie.encode(L,I),L.start=0,ie.decode(L)}return Bd}var ix=nx();const Nd=ti(ix);var qd,mb;function sx(){if(mb)return qd;mb=1;const n=.05;return qd=class{constructor(p,{max:l=64,start:g=0,end:y=p.length,linear:h=!0}={}){this.core=p,this.max=l,this.range=null,this.startBound=g,this.endBound=y,this.maxReadAhead=Math.max(l*2,Math.floor((y-g)*n)),this.start=g,this.end=g,this.linear=h,this.missing=0,this._ondownloadBound=this._ondownload.bind(this),this.core.on("download",this._ondownloadBound)}_ondownload(p){this.range&&p<this.end&&this.start<=p&&(this.missing--,this._update())}destroy(){this.core.off("download",this._ondownloadBound),this.range&&this.range.destroy(),this.range=null,this.max=0}update(p){this.start=p,this.range||this._update()}_update(){if(this.missing>=this.max)return;this.range&&this.range.destroy();let p=this.end;for(;p<this.endBound&&this.missing<this.max&&(p=this.core.core.bitfield.firstUnset(p)+1,!(p>=this.endBound));)this.missing++;p>this.start+this.maxReadAhead&&(p=this.start+this.maxReadAhead),p>=this.endBound&&(p=this.endBound),this.end=p,!(this.start>=this.end)&&(this.range=this.core.download({start:this.start,end:this.end,linear:this.linear}))}},qd}var Cd,wb;function rx(){if(wb)return Cd;wb=1;const{Readable:n,Writable:a}=Sn(),{BLOCK_NOT_AVAILABLE:p}=Lt(),l=sx();class g extends a{constructor(c,s,u){super(u),this.id={},this.core=c,this._lock=s,this._release=null,this._batch=[]}_open(c){this.core.ready().then(()=>{this._lock(s=>(this._release=s,this.id.byteOffset=this.core.byteLength,this.id.blockOffset=this.core.length,c(null)))},s=>c(s))}_final(c){this._append(s=>s?c(s):(this.id.blockLength=this.core.length-this.id.blockOffset,this.id.byteLength=this.core.byteLength-this.id.byteOffset,c(null)))}_destroy(c){this._release&&this._release(),c(null)}_append(c){return this._batch.length?this.core.append(this._batch).then(()=>(this._batch=[],c(null)),s=>(this._batch=[],c(s))):c(null)}_write(c,s){return this._batch.push(c),this._batch.length>=16?this._append(s):s(null)}}class y extends n{constructor(c,s,u={}){super(u),this.id=s,this.core=c.session({wait:u.wait,timeout:u.timeout});const f=s.blockOffset,m=s.blockOffset+s.blockLength,E=u.wait===!1||u.prefetch===!1||!c.core;this._prefetch=E?null:new l(this.core,{max:u.prefetch,start:f,end:m}),this._lastPrefetch=null,this._pos=u.start!==void 0?s.byteOffset+u.start:s.byteOffset,u.length!==void 0?this._end=this._pos+u.length:u.end!==void 0?this._end=s.byteOffset+u.end+1:this._end=s.byteOffset+s.byteLength,this._index=0,this._relativeOffset=0,this._bytesRead=0}_open(c){if(this._pos===this.id.byteOffset)return this._index=this.id.blockOffset,this._relativeOffset=0,c(null);this.core.seek(this._pos,{start:this.id.blockOffset,end:this.id.blockOffset+this.id.blockLength}).then(s=>s?(this._index=s[0],this._relativeOffset=s[1],c(null)):c(p()),s=>c(s))}_predestroy(){this._prefetch&&this._prefetch.destroy(),this.core.close().then(h,h)}_destroy(c){this._prefetch&&this._prefetch.destroy(),this.core.close().then(c,c)}_read(c){if(this._pos>=this._end)return this.push(null),c(null);this._prefetch&&this._prefetch.update(this._index),this.core.get(this._index).then(s=>{if(!s)return c(p());const u=this._end-this._pos;return(this._relativeOffset||u<s.length)&&(s=s.subarray(this._relativeOffset,this._relativeOffset+u)),this._index++,this._relativeOffset=0,this._pos+=s.length,this._bytesRead+=s.length,this.push(s),c(null)},s=>c(s))}}Cd={BlobReadStream:y,BlobWriteStream:g};function h(){}return Cd}var Md,bb;function d0(){if(bb)return Md;bb=1;var n=1,a=65535,p=4,l,g=function(){n=n+1&a};return Md=function(y){l||(l=setInterval(g,1e3/p|0),l.unref&&l.unref());var h=p*(y||5),o=[0],c=1,s=n-1&a;return function(u){var f=n-s&a;for(f>h&&(f=h),s=n;f--;)c===h&&(c=0),o[c]=o[c===0?h-1:c-1],c++;u&&(o[c-1]+=u);var m=o[c-1],E=o.length<h?0:o[c===h?0:c];return o.length<p?m:(m-E)*p/o.length}},Md}var Ud,vb;function ox(){if(vb)return Ud;vb=1;const n=nn,a=d0();Ud=class extends n{constructor(y,h){if(super(),!h)throw new Error("id is required");this.blobs=y,this.id=h,this.peers=0,this.uploadSpeedometer=null,this.downloadSpeedometer=null;const o={startTime:0,percentage:0,peers:0,speed:0,blocks:0,totalBytes:0,monitoringBytes:0,targetBytes:0,targetBlocks:0};this.uploadStats={...o},this.downloadStats={...o},this.uploadStats.targetBytes=this.downloadStats.targetBytes=this.id.byteLength,this.uploadStats.targetBlocks=this.downloadStats.targetBlocks=this.id.blockLength,this.uploadStats.peers=this.downloadStats.peers=this.peers=this.blobs.core.peers.length,this.uploadSpeedometer=a(),this.downloadSpeedometer=a()}destroy(){return this.close()}close(){this.blobs._removeMonitor(this)}_onUpload(y,h,o){this._updateStats(this.uploadSpeedometer,this.uploadStats,y,h,o)}_onDownload(y,h,o){this._updateStats(this.downloadSpeedometer,this.downloadStats,y,h,o)}_updatePeers(){this.uploadStats.peers=this.downloadStats.peers=this.peers=this.blobs.core.peers.length,this.emit("update")}_updateStats(y,h,o,c){this.closing||p(o,this.id)&&(h.startTime||(h.startTime=Date.now()),h.speed=y(c),h.blocks++,h.totalBytes+=c,h.monitoringBytes+=c,h.percentage=l(h.blocks/h.targetBlocks*100),this.emit("update"))}downloadSpeed(){return this.downloadSpeedometer?this.downloadSpeedometer():0}uploadSpeed(){return this.uploadSpeedometer?this.uploadSpeedometer():0}};function p(g,{blockOffset:y,blockLength:h}){return g>=y&&g<y+h}function l(g){return Math.round(g*100)/100}return Ud}var Od,kb;function ax(){if(kb)return Od;kb=1;const n=Nv(),a=Ue(),{BlobReadStream:p,BlobWriteStream:l}=rx(),g=ox(),y=2**16;class h{constructor(s){this.blobs=s,this.blocks=[],this.bytes=0}ready(){return this.blobs.ready()}async put(s){this.blobs.core.opened||await this.blobs.core.ready();const u=this.blobs.blockSize,f={blockOffset:this.blobs.core.length+this.blocks.length,blockLength:0,byteOffset:this.blobs.core.byteLength+this.bytes,byteLength:0};let m=0;for(;m<s.byteLength;){const E=s.subarray(m,m+u);m+=u,f.blockLength++,f.byteLength+=E.byteLength,this.bytes+=E.byteLength,this.blocks.push(E)}return f}async get(s){if(s.blockOffset<this.blobs.core.length)return this.blobs.get(s);const u=[];for(let f=s.blockOffset-this.blobs.core.length;f<s.blockOffset+s.blockLength;f++){if(f>=this.blocks.length)return null;u.push(this.blocks[f])}return u.length===1?u[0]:a.concat(u)}async flush(){await this.blobs.core.append(this.blocks),this.blocks=[],this.bytes=0}close(){}}class o{constructor(s,u={}){this.core=s,this.blockSize=u.blockSize||y,this._lock=n(),this._monitors=new Set,this._boundUpdatePeers=this._updatePeers.bind(this),this._boundOnUpload=this._onUpload.bind(this),this._boundOnDownload=this._onDownload.bind(this)}get key(){return this.core.key}get discoveryKey(){return this.core.discoveryKey}get feed(){return this.core}get locked(){return this._lock.locked}replicate(s,u){return this.core.replicate(s,u)}ready(){return this.core.ready()}close(){return this.core.close()}batch(){return new h(this)}snapshot(){return new o(this.core.snapshot())}async put(s,u){a.isBuffer(s)||(s=a.from(s));const f=u&&u.blockSize||this.blockSize,m=this.createWriteStream(u);for(let E=0;E<s.length;E+=f)m.write(s.subarray(E,E+f));return m.end(),new Promise((E,b)=>{m.once("error",b),m.once("close",()=>E(m.id))})}async _getAll(s,u){if(s.blockLength===1)return this.core.get(s.blockOffset,u);const f=new Array(s.blockLength);for(let E=0;E<s.blockLength;E++)f[E]=this.core.get(s.blockOffset+E,u);const m=await Promise.all(f);for(let E=0;E<s.blockLength;E++)if(m[E]===null)return null;return a.concat(m)}async get(s,u){if(!u||!u.start&&u.length===void 0&&u.end===void 0&&!u.core)return this._getAll(s,u);const m=[];try{for await(const E of this.createReadStream(s,u))m.push(E)}catch(E){if(E.code==="BLOCK_NOT_AVAILABLE")return null;throw E}return m.length===1?m[0]:a.concat(m)}async clear(s,u){return this.core.clear(s.blockOffset,s.blockOffset+s.blockLength,u)}createReadStream(s,u){const f=u&&u.core?u.core:this.core;return new p(f,s,u)}createWriteStream(s){const u=s&&s.core?s.core:this.core;return new l(u,this._lock,s)}monitor(s){const u=new g(this,s);return this._monitors.size===0&&this._startListening(),this._monitors.add(u),u}_removeMonitor(s){this._monitors.delete(s),this._monitors.size===0&&this._stopListening()}_updatePeers(){for(const s of this._monitors)s._updatePeers()}_onUpload(s,u,f){for(const m of this._monitors)m._onUpload(s,u,f)}_onDownload(s,u,f){for(const m of this._monitors)m._onDownload(s,u,f)}_startListening(){this.core.on("peer-add",this._boundUpdatePeers),this.core.on("peer-remove",this._boundUpdatePeers),this.core.on("upload",this._boundOnUpload),this.core.on("download",this._boundOnDownload)}_stopListening(){this.core.off("peer-add",this._boundUpdatePeers),this.core.off("peer-remove",this._boundUpdatePeers),this.core.off("upload",this._boundOnUpload),this.core.off("download",this._boundOnDownload)}}return Od=o,Od}var Pd,Sb;function f0(){if(Sb)return Pd;Sb=1,Pd=a;function n(g){const y=g.split(/[/\\]/),h={isAbsolute:!1,names:y};return y.length===0?h:y.length>1&&y[0].endsWith(":")?(h.isAbsolute=!0,y[0].length===2||y[0]==="file:"?(h.names=y.slice(1),h):(h.names=y.slice(3),h)):(h.isAbsolute=g.startsWith("/")||g.startsWith("\\"),h)}function a(g,y=""){const h=n(g),o=n(y);if(o.isAbsolute)return l([],o.names);if(!h.isAbsolute)throw new Error("One of the two paths must be absolute");return l(h.names,o.names)}function p(g,y){for(let h=0;h<y.length;h++)if(y[h]!==""&&y[h]!=="."){if(y[h]===".."){if(g.length===1)throw new Error("Path cannot be resolved, too many '..'");g=g.slice(0,g.lastIndexOf("/"))||"/";continue}g+=g.length===1?y[h]:"/"+y[h]}return g}function l(g,y){return p(p("/",g),y)}return Pd}var Id,xb;function lx(){if(xb)return Id;xb=1,Id=p;function n(g){const y=typeof g;return y==="object"?Array.isArray(g)?"array":a(g)?typeof g.equals=="function"?"buffer":"array":g===null?"null":"object":y}function a(g){return!!g&&typeof g.length=="number"&&ArrayBuffer.isView(g.array)}function p(g,y){if(g===y)return!0;const h=n(g),o=n(y);if(h!==o)return!1;if(h==="buffer")return g.equals(y);if(h==="array"){if(g.length!==y.length)return!1;for(let u=0;u<g.length;u++)if(!p(g[u],y[u]))return!1;return!0}if(h!=="object")return!1;const c=Object.entries(g),s=Object.entries(y);if(c.length!==s.length)return!1;c.sort(l),s.sort(l);for(let u=0;u<c.length;u++)if(c[u][0]!==s[u][0]||!p(c[u][1],s[u][1]))return!1;return!0}function l(g,y){return g[0]===y[0]?0:g[0]<y[0]?-1:1}return Id}var Kd,Eb;function cx(){if(Eb)return Kd;Eb=1;const n=Ue();Kd=function(p,l){return new Promise((g,y)=>a(p,l,g,y))};function a(p,l,g,y){let h=null,o=!1,c=null,s=!1,u=0,f=!1,m=null,E=!1;p.on("readable",z),p.on("end",M),p.on("error",b),p.on("close",_),l.on("readable",z),l.on("end",M),l.on("error",b),l.on("close",_);function b(j){m=j,p.destroy(),l.destroy()}function _(){++u===2&&(m!==null&&f===!1?y(m):g(E))}function B(j){f||(f=!0,E=j,p.destroy(),l.destroy())}function M(){this===p?o=!0:s=!0,z()}function z(){for(;f===!1;){if(h===null&&(h=p.read()),c===null&&(c=l.read()),h===null&&c===null&&o&&s){B(!0);return}if(h!==null&&c===null&&s){B(!1);return}if(c!==null&&h===null&&o){B(!1);return}if(h===null||c===null)return;if(h.byteLength===c.byteLength){if(n.equals(h,c)){h=c=null;continue}B(!1);return}const j=Math.min(h.byteLength,c.byteLength);if(n.equals(h.subarray(0,j),c.subarray(0,j))){h=h.byteLength===j?null:h.subarray(j),c=c.byteLength===j?null:c.subarray(j);continue}B(!1);return}}}return Kd}var zd,Ab;function hx(){if(Ab)return zd;Ab=1;const n=lx(),a=f0(),p=cx();zd=class{constructor(f,m,E={}){this.src=f,this.dst=m,this.prefix=E.prefix||"/",this.dryRun=!!E.dryRun,this.prune=E.prune!==!1,this.includeEquals=!!E.includeEquals,this.filter=E.filter||null,this.metadataEquals=E.metadataEquals||null,this.batch=!!E.batch,this.entries=E.entries||null,this.count={files:0,add:0,remove:0,change:0},this.bytesRemoved=0,this.bytesAdded=0,this.iterator=this._mirror(),this._ignore=E.ignore?c(E.ignore):null}[Symbol.asyncIterator](){return this.iterator}async done(){for(;;){const{done:f}=await this.iterator.next();if(f)break}}async*_mirror(){if(await this.src.ready(),await this.dst.ready(),this.dst.core&&!this.dst.core.writable)throw new Error("Destination must be writable");const f=this.batch?this.dst.batch():this.dst;if(this.prune)for await(const[m,E,b]of this._list(this.dst,this.src))b||(this.count.remove++,this.bytesRemoved+=l(E),yield{op:"remove",key:m,bytesRemoved:l(E),bytesAdded:0},this.dryRun||await f.del(m));if(this.src.download&&!this.entries){const m=this.src.download(this.prefix);m.catch&&m.catch(s)}for await(const[m,E,b]of this._list(this.src,f,{filter:this.filter}))if(E){if(this.count.files++,await y(this,E,b)){this.includeEquals&&(yield{op:"equal",key:m,bytesRemoved:0,bytesAdded:0});continue}b?(this.count.change++,this.bytesRemoved+=l(b),this.bytesAdded+=l(E),yield{op:"change",key:m,bytesRemoved:l(b),bytesAdded:l(E)}):(this.count.add++,this.bytesAdded+=l(E),yield{op:"add",key:m,bytesRemoved:0,bytesAdded:l(E)}),!this.dryRun&&(E.value.linkname?await f.symlink(m,E.value.linkname):await g(this.src.createReadStream(E),f.createWriteStream(m,{executable:E.value.executable,metadata:E.value.metadata})))}this.batch&&await f.flush()}async*_list(f,m,E){const b=this.entries||f.list(this.prefix,{ignore:this._ignore});for await(const _ of b){const B=typeof _=="object"?_.key:_;if(E&&E.filter&&!E.filter(B))continue;const M=await f.entry(_),z=await m.entry(B);yield[B,M,z]}}};function l(u){return u.value.blob?u.value.blob.byteLength:0}function g(u,f){return new Promise((m,E)=>{u.pipe(f,b=>{b?E(b):m()})})}async function y(u,f,m){return m?f.value.linkname||m.value.linkname?f.value.linkname===m.value.linkname:f.value.executable!==m.value.executable||!h(f,m)||!o(u,f,m)?!1:p(u.src.createReadStream(f),u.dst.createReadStream(m)):!1}function h(u,f){const m=u.value.blob,E=f.value.blob;return!m&&!E?!0:!m||!E?!1:m.byteLength===E.byteLength}function o(u,f,m){if(!u.src.supportsMetadata||!u.dst.supportsMetadata)return!0;const E=f.value.metadata,b=m.value.metadata;if(u.metadataEquals)return u.metadataEquals(E,b);const _=!E&&!b,B=!!(E&&b&&n(E,b));return _||B}function c(u){if(typeof u=="function")return u;const f=[].concat(u).map(m=>a("/",m));return m=>f.some(E=>E===m||m.startsWith(E+"/"))}function s(){}return zd}var Hd,Rb;function ux(){return Rb||(Rb=1,Hd=function(){throw new Error("random-access-file is not supported in the browser")}),Hd}var Fd,Lb;function g0(){if(Lb)return Fd;Lb=1,Fd=class{constructor({maxSize:p,maxAge:l,createMap:g,ongc:y}){if(this.maxSize=p,this.maxAge=l,this.ongc=y||null,this._createMap=g||n,this._latest=this._createMap(),this._oldest=this._createMap(),this._retained=this._createMap(),this._gced=!1,this._interval=null,this.maxAge>0&&this.maxAge<1/0){const h=Math.ceil(.6666666666666666*this.maxAge);this._interval=setInterval(this._gcAuto.bind(this),h),this._interval.unref&&this._interval.unref()}}*[Symbol.iterator](){for(const p of[this._latest,this._oldest,this._retained])yield*p}*keys(){for(const p of[this._latest,this._oldest,this._retained])yield*p.keys()}*values(){for(const p of[this._latest,this._oldest,this._retained])yield*p.values()}destroy(){this.clear(),clearInterval(this._interval),this._interval=null}clear(){this._gced=!0,this._latest.clear(),this._oldest.clear(),this._retained.clear()}set(p,l){return this._retained.has(p)?this:(this._latest.set(p,l),this._oldest.delete(p)||this._retained.delete(p),this._latest.size>=this.maxSize&&this._gc(),this)}retain(p,l){return this._retained.set(p,l),this._latest.delete(p)||this._oldest.delete(p),this}delete(p){return this._latest.delete(p)||this._oldest.delete(p)||this._retained.delete(p)}has(p){return this._latest.has(p)||this._oldest.has(p)||this._retained.has(p)}get(p){if(this._latest.has(p))return this._latest.get(p);if(this._oldest.has(p)){const l=this._oldest.get(p);return this._latest.set(p,l),this._oldest.delete(p),l}return this._retained.has(p)?this._retained.get(p):null}_gcAuto(){this._gced||this._gc(),this._gced=!1}_gc(){this._gced=!0,this.ongc!==null&&this._oldest.size>0&&this.ongc(this._oldest),this._oldest=this._latest,this._latest=this._createMap()}};function n(){return new Map}return Fd}var Vd,Tb;function dx(){if(Tb)return Vd;Tb=1;const n=Ff();return Vd=class{constructor(){this.queue=new n,this.priority=[],this.requests=new Map,this.length=0}push(p){p.priority>0?this.priority.push(p):this.queue.push(p),this.requests.set(p.id,p),this.length++}shift(){for(;this.priority.length>0;){const p=this.priority.pop(),l=this._processRequest(p);if(l!==null)return l}for(;this.queue.length>0;){const p=this.queue.shift(),l=this._processRequest(p);if(l!==null)return l}return null}_processRequest(p){return p.block||p.hash||p.seek||p.upgrade||p.manifest?(this.requests.delete(p.id),this.length--,p):null}clear(){this.queue.clear(),this.priority=[],this.length=0,this.requests.clear()}delete(p){const l=this.requests.get(p);l&&(l.block=null,l.hash=null,l.seek=null,l.upgrade=null,l.manifest=!1,this.requests.delete(p),this.length--,this.length===0&&(this.queue.clear(),this.priority=[]))}},Vd}var jd,Db;function fx(){if(Db)return jd;Db=1;const n=16;jd=class{constructor(){this.priorities=[[],[],[]]}*pick(l){for(let g=0;g<this.priorities.length;g++){let y=(this.priorities.length-g)*n;const h=this.priorities[g];for(let o=0;o<h.length;o++){const c=o+Math.floor(Math.random()*h.length-o),s=h[o],u=h[c];if(c!==o&&(h[u.hotswap.index=o]=u,h[s.hotswap.index=c]=s),!a(u,l)&&(yield u,--y<=0))break}}}add(l){if(l.hotswap!==null&&this.remove(l),l.inflight.length===0||l.inflight.length>=3)return;const g=this.priorities[l.inflight.length-1],y=g.push(l)-1;l.hotswap={ref:this,queue:g,index:y}}remove(l){const g=l.hotswap;if(g===null)return;l.hotswap=null;const y=g.queue.pop();y!==l&&(g.queue[y.hotswap.index=g.index]=y)}};function a(p,l){for(let g=0;g<p.inflight.length;g++)if(p.inflight[g].peer===l)return!0;return!1}return jd}var Gd={},Bb;function p0(){if(Bb)return Gd;Bb=1;let n=er();return(typeof n.findFirst!="function"||typeof n.findLast!="function"||typeof n.clear!="function")&&(n=er()),Gd.quickbit=n,Gd}var Yd,Nb;function y0(){if(Nb)return Yd;Nb=1;const n=ll(),a=p0().quickbit,p=32768,l=p/8,g=l/4,y=2097152,h=y/8,o=y/p;class c{constructor(f,m,E){this.index=f,this.offset=f*l-E.offset,this.bitfield=m,this.segment=E,E.add(this)}get tree(){return this.segment.tree}get(f){return a.get(this.bitfield,f)}set(f,m){a.set(this.bitfield,f,m)&&this.tree.update(this.offset*8+f)}setRange(f,m,E){a.fill(this.bitfield,E,f,f+m);let b=Math.floor(f/128);const _=b+Math.ceil(m/128);for(;b<=_;)this.tree.update(this.offset*8+b++*128)}findFirst(f,m){return a.findFirst(this.bitfield,f,m)}findLast(f,m){return a.findLast(this.bitfield,f,m)}insert(f,m){this.bitfield.set(m,f/32),this.segment.refresh()}clear(f,m){a.clear(this.bitfield,{field:m,offset:f})}}class s{constructor(f){this.index=f,this.offset=f*h,this.tree=a.Index.from([],h),this.pages=new Array(o),this.pagesLength=0}get chunks(){return this.tree.chunks}refresh(){this.tree=a.Index.from(this.tree.chunks,h)}add(f){const m=f.index-this.index*o;m>=this.pagesLength&&(this.pagesLength=m+1),this.pages[m]=f;const E={field:f.bitfield,offset:f.offset};this.chunks.push(E);for(let b=this.chunks.length-2;b>=0;b--){const _=this.chunks[b];if(_.offset<=E.offset)break;this.chunks[b]=E,this.chunks[b+1]=_}}findFirst(f,m){m=this.tree.skipFirst(!f,m);let E=m&p-1,b=(m-E)/p;if(b>=o)return-1;for(;b<this.pagesLength;){const _=this.pages[b];let B=-1;if(_?B=_.findFirst(f,E):f||(B=E),B!==-1)return b*p+B;E=0,b++}return f||this.pagesLength===o?-1:this.pagesLength*p}findLast(f,m){m=this.tree.skipLast(!f,m);let E=m&p-1,b=(m-E)/p;if(b>=o)return-1;for(;b>=0;){const _=this.pages[b];let B=-1;if(_?B=_.findLast(f,E):f||(B=E),B!==-1)return b*p+B;E=p-1,b--}return-1}}return Yd=class{static BITS_PER_PAGE=p;constructor(){this._pages=new n,this._segments=new n,this._maxSegments=0}getBitfield(f){const m=f&p-1,E=(f-m)/p;return this._pages.get(E)||null}get(f){const m=f&p-1,E=(f-m)/p,b=this._pages.get(E);return b?b.get(m):!1}set(f,m){const E=f&p-1,b=(f-E)/p;let _=this._pages.get(b);if(!_&&m){const B=Math.floor(b/o),M=this._segments.get(B)||this._segments.set(B,new s(B));this._maxSegments<=B&&(this._maxSegments=B+1),_=this._pages.set(b,new c(b,new Uint32Array(g),M))}_&&_.set(E,m)}setRange(f,m,E){let b=f&p-1,_=(f-b)/p;for(;m>0;){let B=this._pages.get(_);if(!B&&E){const j=Math.floor(_/o),v=this._segments.get(j)||this._segments.set(j,new s(j));this._maxSegments<=j&&(this._maxSegments=j+1),B=this._pages.set(_,new c(_,new Uint32Array(g),v))}const z=Math.min(b+m,p)-b;B&&B.setRange(b,z,E),b=0,_++,m-=z}}findFirst(f,m){let E=m&y-1,b=(m-E)/y;for(;b<this._maxSegments;){const _=this._segments.get(b);let B=-1;if(_?B=_.findFirst(f,E):f||(B=E),B!==-1)return b*y+B;E=0,b++}return f?-1:Math.max(m,this._maxSegments*y)}firstSet(f){return this.findFirst(!0,f)}firstUnset(f){return this.findFirst(!1,f)}findLast(f,m){let E=m&y-1,b=(m-E)/y;for(;b>=0;){const _=this._segments.get(b);let B=-1;if(_?B=_.findLast(f,E):f||(B=E),B!==-1)return b*y+B;E=y-1,b--}return-1}lastSet(f){return this.findLast(!0,f)}lastUnset(f){return this.findLast(!1,f)}insert(f,m){if(f%32!==0)return!1;let E=m.byteLength*8,b=f&p-1,_=(f-b)/p;for(;E>0;){let B=this._pages.get(_);if(!B){const j=Math.floor(_/o),v=this._segments.get(j)||this._segments.set(j,new s(j));this._maxSegments<=j&&(this._maxSegments=j+1),B=this._pages.set(_,new c(_,new Uint32Array(g),v))}const z=Math.min(b+E,p)-b;B.insert(b,m.subarray(0,z/32)),m=m.subarray(z/32),b=0,_++,E-=z}return!0}clear(f,m){if(f%32!==0)return!1;let E=m.byteLength*8,b=f&p-1,_=(f-b)/p;for(;E>0;){let B=this._pages.get(_);if(!B){const j=Math.floor(_/o),v=this._segments.get(j)||this._segments.set(j,new s(j));this._maxSegments<=j&&(this._maxSegments=j+1),B=this._pages.set(_,new c(_,new Uint32Array(g),v))}const z=Math.min(b+E,p)-b;B.clear(b,m.subarray(0,z/32)),m=m.subarray(z/32),b=0,_++,E-=z}return!0}},Yd}var ls={},Mi={},Wd,qb;function _0(){return qb||(qb=1,Wd=Cv),Wd}var Cb;function wo(){if(Cb)return Mi;Cb=1;const n=_t(),a=_0(),p=Ue(),l=et(),[g,y,h,o,c,s]=n.namespace("hypercore",6);return Mi.MANIFEST=o,Mi.DEFAULT_NAMESPACE=c,Mi.BLOCK_ENCRYPTION=s,Mi.replicate=function(u,f,m){const E=p.allocUnsafe(32);return a.crypto_generichash_batch(E,[u?y:h,f],m),E},Mi.treeSignable=function(u,f,m,E){const b={start:0,end:112,buffer:p.allocUnsafe(112)};return l.fixed32.encode(b,g),l.fixed32.encode(b,u),l.fixed32.encode(b,f),l.uint64.encode(b,m),l.uint64.encode(b,E),b.buffer},Mi.treeSignableCompat=function(u,f,m,E){const b=E?48:80,_={start:0,end:b,buffer:p.allocUnsafe(b)};return E||l.fixed32.encode(_,g),l.fixed32.encode(_,u),l.uint64.encode(_,f),l.uint64.encode(_,m),_.buffer},Mi}var Mb;function bo(){if(Mb)return ls;Mb=1;const n=et(),a=Ue(),{DEFAULT_NAMESPACE:p}=wo(),{INVALID_OPLOG_VERSION:l}=Lt(),g=Xt(),y=a.alloc(0),h={preencode(D,H){D.end++},encode(D,H){if(H==="blake2b"){n.uint.encode(D,0);return}throw new Error("Unknown hash: "+H)},decode(D){const H=n.uint.decode(D);if(H===0)return"blake2b";throw new Error("Unknown hash id: "+H)}},o={preencode(D,H){D.end++},encode(D,H){if(H==="ed25519"){n.uint.encode(D,0);return}throw new Error("Unknown signature: "+H)},decode(D){const H=n.uint.decode(D);if(H===0)return"ed25519";throw new Error("Unknown signature id: "+H)}},c={preencode(D,H){o.preencode(D,H.signature),n.fixed32.preencode(D,H.namespace),n.fixed32.preencode(D,H.publicKey)},encode(D,H){o.encode(D,H.signature),n.fixed32.encode(D,H.namespace),n.fixed32.encode(D,H.publicKey)},decode(D){return{signature:o.decode(D),namespace:n.fixed32.decode(D),publicKey:n.fixed32.decode(D)}}},s=n.array(c),u={preencode(D,H){n.fixed32.preencode(D,H.hash),n.uint.preencode(D,H.length)},encode(D,H){n.fixed32.encode(D,H.hash),n.uint.encode(D,H.length)},decode(D){return{hash:n.fixed32.decode(D),length:n.uint.decode(D)}}},f={preencode(D,H){if(h.preencode(D,H.hash),D.end++,H.prologue&&H.signers.length===0){n.fixed32.preencode(D,H.prologue.hash);return}H.quorum===1&&H.signers.length===1&&!H.allowPatch?c.preencode(D,H.signers[0]):(D.end++,n.uint.preencode(D,H.quorum),s.preencode(D,H.signers))},encode(D,H){if(h.encode(D,H.hash),H.prologue&&H.signers.length===0){n.uint.encode(D,0),n.fixed32.encode(D,H.prologue.hash);return}H.quorum===1&&H.signers.length===1&&!H.allowPatch?(n.uint.encode(D,1),c.encode(D,H.signers[0])):(n.uint.encode(D,2),n.uint.encode(D,H.allowPatch?1:0),n.uint.encode(D,H.quorum),s.encode(D,H.signers))},decode(D){const H=h.decode(D),_e=n.uint.decode(D);if(_e>2)throw new Error("Unknown type: "+_e);if(_e===0)return{version:0,hash:H,allowPatch:!1,quorum:0,signers:[],prologue:{hash:n.fixed32.decode(D),length:0}};if(_e===1)return{version:0,hash:H,allowPatch:!1,quorum:1,signers:[c.decode(D)],prologue:null};const ce=n.uint.decode(D);return{version:0,hash:H,allowPatch:(ce&1)!==0,quorum:n.uint.decode(D),signers:s.decode(D),prologue:null}}},m=ls.manifest={preencode(D,H){if(D.end++,H.version===0)return f.preencode(D,H);D.end++,h.preencode(D,H.hash),n.uint.preencode(D,H.quorum),s.preencode(D,H.signers),H.prologue&&u.preencode(D,H.prologue)},encode(D,H){if(n.uint.encode(D,H.version),H.version===0)return f.encode(D,H);n.uint.encode(D,(H.allowPatch?1:0)|(H.prologue?2:0)),h.encode(D,H.hash),n.uint.encode(D,H.quorum),s.encode(D,H.signers),H.prologue&&u.encode(D,H.prologue)},decode(D){const H=n.uint.decode(D);if(H===0)return f.decode(D);if(H!==1)throw new Error("Unknown version: "+H);const _e=n.uint.decode(D),ce=h.decode(D),J=n.uint.decode(D),d=s.decode(D);return{version:1,hash:ce,allowPatch:(_e&1)!==0,quorum:J,signers:d,prologue:(_e&2)===0?null:u.decode(D)}}},E={preencode(D,H){n.uint.preencode(D,H.index),n.uint.preencode(D,H.size),n.fixed32.preencode(D,H.hash)},encode(D,H){n.uint.encode(D,H.index),n.uint.encode(D,H.size),n.fixed32.encode(D,H.hash)},decode(D){return{index:n.uint.decode(D),size:n.uint.decode(D),hash:n.fixed32.decode(D)}}},b=n.array(E),_=ls.wire={};_.handshake={preencode(D,H){n.uint.preencode(D,1),n.fixed32.preencode(D,H.capability)},encode(D,H){n.uint.encode(D,H.seeks?1:0),n.fixed32.encode(D,H.capability)},decode(D){return{seeks:(n.uint.decode(D)&1)!==0,capability:g(n.fixed32.decode(D))}}};const B={preencode(D,H){n.uint.preencode(D,H.index),n.uint.preencode(D,H.nodes)},encode(D,H){n.uint.encode(D,H.index),n.uint.encode(D,H.nodes)},decode(D){return{index:n.uint.decode(D),nodes:n.uint.decode(D)}}},M={preencode(D,H){n.uint.preencode(D,H.bytes),n.uint.preencode(D,H.padding)},encode(D,H){n.uint.encode(D,H.bytes),n.uint.encode(D,H.padding)},decode(D){return{bytes:n.uint.decode(D),padding:n.uint.decode(D)}}},z={preencode(D,H){n.uint.preencode(D,H.start),n.uint.preencode(D,H.length)},encode(D,H){n.uint.encode(D,H.start),n.uint.encode(D,H.length)},decode(D){return{start:n.uint.decode(D),length:n.uint.decode(D)}}};_.request={preencode(D,H){D.end++,n.uint.preencode(D,H.id),n.uint.preencode(D,H.fork),H.block&&B.preencode(D,H.block),H.hash&&B.preencode(D,H.hash),H.seek&&M.preencode(D,H.seek),H.upgrade&&z.preencode(D,H.upgrade),H.priority&&n.uint.preencode(D,H.priority)},encode(D,H){const _e=(H.block?1:0)|(H.hash?2:0)|(H.seek?4:0)|(H.upgrade?8:0)|(H.manifest?16:0)|(H.priority?32:0);n.uint.encode(D,_e),n.uint.encode(D,H.id),n.uint.encode(D,H.fork),H.block&&B.encode(D,H.block),H.hash&&B.encode(D,H.hash),H.seek&&M.encode(D,H.seek),H.upgrade&&z.encode(D,H.upgrade),H.priority&&n.uint.encode(D,H.priority)},decode(D){const H=n.uint.decode(D);return{id:n.uint.decode(D),fork:n.uint.decode(D),block:H&1?B.decode(D):null,hash:H&2?B.decode(D):null,seek:H&4?M.decode(D):null,upgrade:H&8?z.decode(D):null,manifest:(H&16)!==0,priority:H&32?n.uint.decode(D):0}}},_.cancel={preencode(D,H){n.uint.preencode(D,H.request)},encode(D,H){n.uint.encode(D,H.request)},decode(D,H){return{request:n.uint.decode(D)}}};const j={preencode(D,H){n.uint.preencode(D,H.start),n.uint.preencode(D,H.length),b.preencode(D,H.nodes),b.preencode(D,H.additionalNodes),n.buffer.preencode(D,H.signature)},encode(D,H){n.uint.encode(D,H.start),n.uint.encode(D,H.length),b.encode(D,H.nodes),b.encode(D,H.additionalNodes),n.buffer.encode(D,H.signature)},decode(D){return{start:n.uint.decode(D),length:n.uint.decode(D),nodes:b.decode(D),additionalNodes:b.decode(D),signature:n.buffer.decode(D)}}},v={preencode(D,H){n.uint.preencode(D,H.bytes),b.preencode(D,H.nodes)},encode(D,H){n.uint.encode(D,H.bytes),b.encode(D,H.nodes)},decode(D){return{bytes:n.uint.decode(D),nodes:b.decode(D)}}},w={preencode(D,H){n.uint.preencode(D,H.index),n.buffer.preencode(D,H.value),b.preencode(D,H.nodes)},encode(D,H){n.uint.encode(D,H.index),n.buffer.encode(D,H.value),b.encode(D,H.nodes)},decode(D){return{index:n.uint.decode(D),value:n.buffer.decode(D)||y,nodes:b.decode(D)}}},R={preencode(D,H){n.uint.preencode(D,H.index),b.preencode(D,H.nodes)},encode(D,H){n.uint.encode(D,H.index),b.encode(D,H.nodes)},decode(D){return{index:n.uint.decode(D),nodes:b.decode(D)}}};_.data={preencode(D,H){D.end++,n.uint.preencode(D,H.request),n.uint.preencode(D,H.fork),H.block&&w.preencode(D,H.block),H.hash&&R.preencode(D,H.hash),H.seek&&v.preencode(D,H.seek),H.upgrade&&j.preencode(D,H.upgrade),H.manifest&&m.preencode(D,H.manifest)},encode(D,H){const _e=(H.block?1:0)|(H.hash?2:0)|(H.seek?4:0)|(H.upgrade?8:0)|(H.manifest?16:0);n.uint.encode(D,_e),n.uint.encode(D,H.request),n.uint.encode(D,H.fork),H.block&&w.encode(D,H.block),H.hash&&R.encode(D,H.hash),H.seek&&v.encode(D,H.seek),H.upgrade&&j.encode(D,H.upgrade),H.manifest&&m.encode(D,H.manifest)},decode(D){const H=n.uint.decode(D);return{request:n.uint.decode(D),fork:n.uint.decode(D),block:H&1?w.decode(D):null,hash:H&2?R.decode(D):null,seek:H&4?v.decode(D):null,upgrade:H&8?j.decode(D):null,manifest:H&16?m.decode(D):null}}},_.noData={preencode(D,H){n.uint.preencode(D,H.request)},encode(D,H){n.uint.encode(D,H.request)},decode(D,H){return{request:n.uint.decode(D)}}},_.want={preencode(D,H){n.uint.preencode(D,H.start),n.uint.preencode(D,H.length)},encode(D,H){n.uint.encode(D,H.start),n.uint.encode(D,H.length)},decode(D){return{start:n.uint.decode(D),length:n.uint.decode(D)}}},_.unwant={preencode(D,H){n.uint.preencode(D,H.start),n.uint.preencode(D,H.length)},encode(D,H){n.uint.encode(D,H.start),n.uint.encode(D,H.length)},decode(D,H){return{start:n.uint.decode(D),length:n.uint.decode(D)}}},_.range={preencode(D,H){D.end++,n.uint.preencode(D,H.start),H.length!==1&&n.uint.preencode(D,H.length)},encode(D,H){n.uint.encode(D,(H.drop?1:0)|(H.length===1?2:0)),n.uint.encode(D,H.start),H.length!==1&&n.uint.encode(D,H.length)},decode(D){const H=n.uint.decode(D);return{drop:(H&1)!==0,start:n.uint.decode(D),length:(H&2)!==0?1:n.uint.decode(D)}}},_.bitfield={preencode(D,H){n.uint.preencode(D,H.start),n.uint32array.preencode(D,H.bitfield)},encode(D,H){n.uint.encode(D,H.start),n.uint32array.encode(D,H.bitfield)},decode(D,H){return{start:n.uint.decode(D),bitfield:n.uint32array.decode(D)}}},_.sync={preencode(D,H){D.end++,n.uint.preencode(D,H.fork),n.uint.preencode(D,H.length),n.uint.preencode(D,H.remoteLength)},encode(D,H){n.uint.encode(D,(H.canUpgrade?1:0)|(H.uploading?2:0)|(H.downloading?4:0)|(H.hasManifest?8:0)),n.uint.encode(D,H.fork),n.uint.encode(D,H.length),n.uint.encode(D,H.remoteLength)},decode(D){const H=n.uint.decode(D);return{fork:n.uint.decode(D),length:n.uint.decode(D),remoteLength:n.uint.decode(D),canUpgrade:(H&1)!==0,uploading:(H&2)!==0,downloading:(H&4)!==0,hasManifest:(H&8)!==0}}},_.reorgHint={preencode(D,H){n.uint.preencode(D,H.from),n.uint.preencode(D,H.to),n.uint.preencode(D,H.ancestors)},encode(D,H){n.uint.encode(D,H.from),n.uint.encode(D,H.to),n.uint.encode(D,H.ancestors)},decode(D){return{from:n.uint.encode(D),to:n.uint.encode(D),ancestors:n.uint.encode(D)}}},_.extension={preencode(D,H){n.string.preencode(D,H.name),n.raw.preencode(D,H.message)},encode(D,H){n.string.encode(D,H.name),n.raw.encode(D,H.message)},decode(D){return{name:n.string.decode(D),message:n.raw.decode(D)}}};const A={preencode(D,H){n.string.preencode(D,H.key),n.buffer.preencode(D,H.value)},encode(D,H){n.string.encode(D,H.key),n.buffer.encode(D,H.value)},decode(D){return{key:n.string.decode(D),value:n.buffer.decode(D)}}},q={preencode(D,H){n.uint.preencode(D,H.fork),n.uint.preencode(D,H.ancestors),n.uint.preencode(D,H.length),n.buffer.preencode(D,H.signature)},encode(D,H){n.uint.encode(D,H.fork),n.uint.encode(D,H.ancestors),n.uint.encode(D,H.length),n.buffer.encode(D,H.signature)},decode(D){return{fork:n.uint.decode(D),ancestors:n.uint.decode(D),length:n.uint.decode(D),signature:n.buffer.decode(D)}}},U={preencode(D,H){D.end++,n.uint.preencode(D,H.start),n.uint.preencode(D,H.length)},encode(D,H){D.buffer[D.start++]=H.drop?1:0,n.uint.encode(D,H.start),n.uint.encode(D,H.length)},decode(D){return{drop:(n.uint.decode(D)&1)!==0,start:n.uint.decode(D),length:n.uint.decode(D)}}},T=ls.oplog={};T.entry={preencode(D,H){D.end++,H.userData&&A.preencode(D,H.userData),H.treeNodes&&b.preencode(D,H.treeNodes),H.treeUpgrade&&q.preencode(D,H.treeUpgrade),H.bitfield&&U.preencode(D,H.bitfield)},encode(D,H){const _e=D.start++;let ce=0;H.userData&&(ce|=1,A.encode(D,H.userData)),H.treeNodes&&(ce|=2,b.encode(D,H.treeNodes)),H.treeUpgrade&&(ce|=4,q.encode(D,H.treeUpgrade)),H.bitfield&&(ce|=8,U.encode(D,H.bitfield)),D.buffer[_e]=ce},decode(D){const H=n.uint.decode(D);return{userData:(H&1)!==0?A.decode(D):null,treeNodes:(H&2)!==0?b.decode(D):null,treeUpgrade:(H&4)!==0?q.decode(D):null,bitfield:(H&8)!==0?U.decode(D):null}}};const Q={preencode(D,H){n.buffer.preencode(D,H.publicKey),n.buffer.preencode(D,H.secretKey)},encode(D,H){n.buffer.encode(D,H.publicKey),n.buffer.encode(D,H.secretKey)},decode(D){return{publicKey:n.buffer.decode(D),secretKey:n.buffer.decode(D)}}},le={preencode(D,H){n.uint.preencode(D,H.from),n.uint.preencode(D,H.to),n.uint.preencode(D,H.ancestors)},encode(D,H){n.uint.encode(D,H.from),n.uint.encode(D,H.to),n.uint.encode(D,H.ancestors)},decode(D){return{from:n.uint.decode(D),to:n.uint.decode(D),ancestors:n.uint.decode(D)}}},Y=n.array(le),oe={preencode(D,H){Y.preencode(D,H.reorgs),n.uint.preencode(D,H.contiguousLength)},encode(D,H){Y.encode(D,H.reorgs),n.uint.encode(D,H.contiguousLength)},decode(D){return{reorgs:Y.decode(D),contiguousLength:D.start<D.end?n.uint.decode(D):0}}},ue={preencode(D,H){n.uint.preencode(D,H.fork),n.uint.preencode(D,H.length),n.buffer.preencode(D,H.rootHash),n.buffer.preencode(D,H.signature)},encode(D,H){n.uint.encode(D,H.fork),n.uint.encode(D,H.length),n.buffer.encode(D,H.rootHash),n.buffer.encode(D,H.signature)},decode(D){return{fork:n.uint.decode(D),length:n.uint.decode(D),rootHash:n.buffer.decode(D),signature:n.buffer.decode(D)}}},O={preencode(D,H){n.string.preencode(D,H.tree),n.string.preencode(D,H.bitfield),n.string.preencode(D,H.signer)},encode(D,H){n.string.encode(D,H.tree),n.string.encode(D,H.bitfield),n.string.encode(D,H.signer)},decode(D){return{tree:n.string.decode(D),bitfield:n.string.decode(D),signer:n.string.decode(D)}}},P={preencode(D,H){n.uint.preencode(D,H.start),n.uint.preencode(D,H.length)},encode(D,H){n.uint.encode(D,H.start),n.uint.encode(D,H.length)},decode(D){return{start:n.uint.decode(D),length:n.uint.decode(D)}}},Z=n.array(A);T.header={preencode(D,H){if(D.end+=2,H.external){P.preencode(D,H.external);return}n.fixed32.preencode(D,H.key),H.manifest&&m.preencode(D,H.manifest),H.keyPair&&Q.preencode(D,H.keyPair),Z.preencode(D,H.userData),ue.preencode(D,H.tree),oe.preencode(D,H.hints)},encode(D,H){if(n.uint.encode(D,1),H.external){n.uint.encode(D,1),P.encode(D,H.external);return}n.uint.encode(D,(H.manifest?2:0)|(H.keyPair?4:0)),n.fixed32.encode(D,H.key),H.manifest&&m.encode(D,H.manifest),H.keyPair&&Q.encode(D,H.keyPair),Z.encode(D,H.userData),ue.encode(D,H.tree),oe.encode(D,H.hints)},decode(D){const H=n.uint.decode(D);if(H>1)throw l("Invalid header version. Expected <= 1, got "+H);if(H===0){const ce={types:O.decode(D),userData:Z.decode(D),tree:ue.decode(D),signer:Q.decode(D),hints:oe.decode(D)};return{external:null,key:ce.signer.publicKey,manifest:{version:0,hash:ce.types.tree,allowPatch:!1,quorum:1,signers:[{signature:ce.types.signer,namespace:p,publicKey:ce.signer.publicKey}],prologue:null},keyPair:ce.signer.secretKey?ce.signer:null,userData:ce.userData,tree:ce.tree,hints:ce.hints}}const _e=n.uint.decode(D);return _e&1?{external:P.decode(D),key:null,manifest:null,keyPair:null,userData:null,tree:null,hints:null}:{external:null,key:n.fixed32.decode(D),manifest:(_e&2)!==0?m.decode(D):null,keyPair:(_e&4)!==0?Q.decode(D):null,userData:Z.decode(D),tree:ue.decode(D),hints:oe.decode(D)}}};const he=n.array(n.uint),se={preencode(D,H){n.uint.preencode(D,H.signer),n.fixed64.preencode(D,H.signature),n.uint.preencode(D,H.patch)},encode(D,H){n.uint.encode(D,H.signer),n.fixed64.encode(D,H.signature),n.uint.encode(D,H.patch)},decode(D){return{signer:n.uint.decode(D),signature:n.fixed64.decode(D),patch:n.uint.decode(D)}}},G={preencode(D,H){n.uint.preencode(D,H.start),n.uint.preencode(D,H.length),he.preencode(D,H.nodes)},encode(D,H){n.uint.encode(D,H.start),n.uint.encode(D,H.length),he.encode(D,H.nodes)},decode(D){return{start:n.uint.decode(D),length:n.uint.decode(D),nodes:he.decode(D)}}},re={preencode(D,H){D.end++,n.uint.preencode(D,H.signer),n.fixed64.preencode(D,H.signature),H.patch&&G.preencode(D,H.patch)},encode(D,H){n.uint.encode(D,H.patch?1:0),n.uint.encode(D,H.signer),n.fixed64.encode(D,H.signature),H.patch&&G.encode(D,H.patch)},decode(D){const H=n.uint.decode(D);return{signer:n.uint.decode(D),signature:n.fixed64.decode(D),patch:H&1?G.decode(D):null}}},W=n.array(re),$=n.array(se),S={preencode(D,H){n.uint.preencode(D,H.index),n.uint.preencode(D,H.size),n.fixed32.preencode(D,H.hash)},encode(D,H){n.uint.encode(D,H.index),n.uint.encode(D,H.size),n.fixed32.encode(D,H.hash)},decode(D){return{index:n.uint.decode(D),size:n.uint.decode(D),hash:n.fixed32.decode(D)}}},N=n.array(S);return ls.multiSignaturev0={preencode(D,H){W.preencode(D,H.proofs),N.preencode(D,H.patch)},encode(D,H){W.encode(D,H.proofs),N.encode(D,H.patch)},decode(D){return{proofs:W.decode(D),patch:N.decode(D)}}},ls.multiSignature={preencode(D,H){$.preencode(D,H.proofs),N.preencode(D,H.patch)},encode(D,H){$.encode(D,H.proofs),N.encode(D,H.patch)},decode(D){return{proofs:$.decode(D),patch:N.decode(D)}}},ls}var Qd,Ub;function gx(){if(Ub)return Qd;Ub=1;const n=Ue(),a=jt(),p=$v(),l=rn(),g=dx(),y=fx(),h=y0(),{REQUEST_CANCELLED:o,REQUEST_TIMEOUT:c,INVALID_CAPABILITY:s,SNAPSHOT_NOT_AVAILABLE:u}=Lt(),f=bo(),m=wo(),E=[16,512],b=50,_=256*1024*8,B=2e4+Math.random()*2e4|0,M=3,z=64,j={NORMAL:0,HIGH:1,VERY_HIGH:2,CANCELLED:255};class v{constructor(){this.resolved=!1,this.refs=[]}attach(C){const ee={context:this,session:C,sindex:0,rindex:0,snapshot:!0,resolve:null,reject:null,promise:null,timeout:null};return ee.sindex=C.push(ee)-1,ee.rindex=this.refs.push(ee)-1,ee.promise=new Promise((fe,ve)=>{ee.resolve=fe,ee.reject=ve}),ee}detach(C,ee=null){return C.context!==this?!1:(this._detach(C),this._cancel(C,ee),this.gc(),!0)}_detach(C){const ee=this.refs.pop(),fe=C.session.pop();return C.rindex<this.refs.length&&(this.refs[ee.rindex=C.rindex]=ee),C.sindex<C.session.length&&(C.session[fe.sindex=C.sindex]=fe),se(C),C.context=null,C}gc(){this.refs.length===0&&this._unref()}_cancel(C,ee){C.reject(ee||o())}_unref(){}resolve(C){for(this.resolved=!0;this.refs.length>0;)this._detach(this.refs[this.refs.length-1]).resolve(C)}reject(C){for(this.resolved=!0;this.refs.length>0;)this._detach(this.refs[this.refs.length-1]).reject(C)}setTimeout(C,ee){se(C),C.timeout=setTimeout(he,ee,C)}}class w extends v{constructor(C,ee,fe){super(),this.index=ee,this.priority=fe,this.inflight=[],this.queued=!1,this.hotswap=null,this.tracker=C}_unref(){this.queued=!1;for(const C of this.inflight)C.peer._cancelRequest(C);this.tracker.remove(this.index),oe(this)}}class R extends v{constructor(C,ee,fe,ve,we,F){super(),this.start=ee,this.end=fe,this.linear=ve,this.ifAvailable=we,this.blocks=F,this.ranges=C,this.userStart=ee,this.userEnd=fe}_unref(){const C=this.ranges.indexOf(this);if(C===-1)return;const ee=this.ranges.pop();C<this.ranges.length&&(this.ranges[C]=ee)}_cancel(C){C.resolve(!1)}}class A extends v{constructor(C,ee,fe){super(),this.fork=ee,this.length=fe,this.inflight=[],this.replicator=C}_unref(){this.replicator.eagerUpgrade===!0||this.inflight.length>0||(this.replicator._upgrade=null)}_cancel(C){C.resolve(!1)}}class q extends v{constructor(C,ee){super(),this.seeker=ee,this.inflight=[],this.seeks=C}_unref(){if(this.inflight.length>0)return;const C=this.seeks.indexOf(this);if(C===-1)return;const ee=this.seeks.pop();C<this.seeks.length&&(this.seeks[C]=ee)}}class U{constructor(){this._requests=[],this._free=[]}get idle(){return this._requests.length===this._free.length}*[Symbol.iterator](){for(const C of this._requests)C!==null&&(yield C)}add(C){const ee=this._free.length?this._free.pop():this._requests.push(null);return C.id=ee,this._requests[ee-1]=C,C}get(C){return C<=this._requests.length?this._requests[C-1]:null}remove(C,ee){C>this._requests.length||(this._requests[C-1]=null,ee===!0&&this._free.push(C))}reusable(C){this._free.push(C)}}class T{constructor(){this._map=new Map}[Symbol.iterator](){return this._map.values()}isEmpty(){return this._map.size===0}has(C){return this._map.has(C)}get(C){return this._map.get(C)||null}add(C,ee){let fe=this._map.get(C);return fe||(fe=new w(this,C,ee),this._map.set(C,fe),fe)}remove(C){const ee=this.get(C);return this._map.delete(C),ee}}class Q{constructor(){this.queue=[],this.tick=0}clear(){const C=new Array(this.queue.length);for(let ee=0;ee<C.length;ee++)C[ee]=this.queue[ee][1];return this.queue=[],C}add(C){this.queue.push([++this.tick,C])}flush(C){let ee=null;for(let fe=0;fe<this.queue.length&&!(this.queue[fe][0]>C);fe++)ee===null&&(ee=[]),ee.push(this.queue[fe][1]);return ee!==null&&this.queue.splice(0,ee.length),ee}}class le{constructor(C,ee,fe,ve,we){this.core=C.core,this.replicator=C,this.stream=ee.stream,this.protomux=ee,this.remotePublicKey=this.stream.remotePublicKey,this.remoteSupportsSeeks=!1,this.inflightRange=we,this.paused=!1,this.removed=!1,this.useSession=ve,this.channel=fe,this.channel.userData=this,this.wireSync=this.channel.messages[0],this.wireRequest=this.channel.messages[1],this.wireCancel=this.channel.messages[2],this.wireData=this.channel.messages[3],this.wireNoData=this.channel.messages[4],this.wireWant=this.channel.messages[5],this.wireUnwant=this.channel.messages[6],this.wireBitfield=this.channel.messages[7],this.wireRange=this.channel.messages[8],this.wireExtension=this.channel.messages[9],this.stats={wireSync:{tx:0,rx:0},wireRequest:{tx:0,rx:0},wireCancel:{tx:0,rx:0},wireData:{tx:0,rx:0},wireWant:{tx:0,rx:0},wireBitfield:{tx:0,rx:0},wireRange:{tx:0,rx:0},wireExtension:{tx:0,rx:0},hotswaps:0},this.receiverQueue=new g,this.receiverBusy=!1,this.roundtripQueue=null,this.inflight=0,this.dataProcessing=0,this.canUpgrade=!0,this.needsSync=!1,this.syncsProcessing=0,this._remoteContiguousLength=0,this.remoteOpened=!1,this.remoteBitfield=new h,this.missingBlocks=new h,this.remoteFork=0,this.remoteLength=0,this.remoteCanUpgrade=!1,this.remoteUploading=!0,this.remoteDownloading=!0,this.remoteSynced=!1,this.remoteHasManifest=!1,this.remoteRequests=new Map,this.segmentsWanted=new Set,this.broadcastedNonSparse=!1,this.lengthAcked=0,this.extensions=new Map,this.lastExtensionSent="",this.lastExtensionRecv="",C._ifAvailable++}get remoteContiguousLength(){return this.remoteBitfield.findFirst(!1,this._remoteContiguousLength)}getMaxInflight(){const C=this.stream.rawStream;if(!C.udx)return Math.min(this.inflightRange[1],this.inflightRange[0]*3);const ee=C.rtt<=b?1:C.rtt/b*Math.min(1,2/this.replicator.peers.length);return Math.max(this.inflightRange[0],Math.round(Math.min(this.inflightRange[1],this.inflightRange[0]*ee)))}getMaxHotswapInflight(){const C=this.getMaxInflight();return Math.max(16,C/2)}signalUpgrade(){this._shouldUpdateCanUpgrade()===!0?this._updateCanUpgradeAndSync():this.sendSync()}_markInflight(C){this.missingBlocks.set(C,!1)}broadcastRange(C,ee,fe){if(fe?this._unclearLocalRange(C,ee):this._clearLocalRange(C,ee),!fe){if(this._remoteContiguousLength>=C+ee)return;if(ee===1){if(this.remoteBitfield.get(C))return}else if(this.remoteBitfield.firstUnset(C)>=C+ee)return}this.wireRange.send({drop:fe,start:C,length:ee}),V(this.stats.wireRange,this.replicator.stats.wireRange)}extension(C,ee){this.wireExtension.send({name:C===this.lastExtensionSent?"":C,message:ee}),V(this.stats.wireExtension,this.replicator.stats.wireExtension),this.lastExtensionSent=C}onextension(C){const ee=C.name||this.lastExtensionRecv;this.lastExtensionRecv=ee;const fe=this.extensions.get(ee);fe&&fe._onmessage({start:0,end:C.message.byteLength,buffer:C.message},this)}sendSync(){if(this.syncsProcessing!==0){this.needsSync=!0;return}this.core.tree.fork!==this.remoteFork&&(this.canUpgrade=!1),this.needsSync=!1,this.wireSync.send({fork:this.core.tree.fork,length:this.core.tree.length,remoteLength:this.core.tree.fork===this.remoteFork?this.remoteLength:0,canUpgrade:this.canUpgrade,uploading:!0,downloading:this.replicator.isDownloading(),hasManifest:!!this.core.header.manifest&&this.core.compat===!1}),V(this.stats.wireSync,this.replicator.stats.wireSync)}onopen({seeks:C,capability:ee}){const fe=m.replicate(this.stream.isInitiator===!1,this.replicator.key,this.stream.handshakeHash);if(n.equals(ee,fe)!==!0)throw s("Remote sent an invalid replication capability");if(this.remoteOpened===!0)return;this.remoteOpened=!0,this.remoteSupportsSeeks=C,this.protomux.cork(),this.sendSync();const ve=Math.min(this.core.tree.length,this.core.header.hints.contiguousLength);ve>0&&(this.broadcastRange(0,ve,!1),ve===this.core.tree.length&&(this.broadcastedNonSparse=!0)),this.replicator._ifAvailable--,this.replicator._addPeer(this),this.protomux.uncork()}onclose(C){const ee=C===!0&&this.remoteOpened===!0&&this.remoteDownloading===!1&&this.remoteUploading===!0&&this.replicator.downloading===!0;if(this.remoteOpened===!1){this.useSession&&(this.replicator._peerSessions--,this.replicator._closeSessionMaybe()),this.replicator._ifAvailable--,this.replicator.updateAll();return}if(this.remoteOpened=!1,this.removed=!0,this.remoteRequests.clear(),this.receiverQueue.clear(),this.roundtripQueue!==null)for(const fe of this.roundtripQueue.clear())this.replicator._inflight.reusable(fe);this.replicator._removePeer(this),ee&&this.replicator._makePeer(this.protomux,this.useSession),this.useSession&&(this.replicator._peerSessions--,this.replicator._closeSessionMaybe())}closeIfIdle(){return this.remoteDownloading===!1&&this.replicator.isDownloading()===!1?(this.channel.close(),!0):!1}async onsync({fork:C,length:ee,remoteLength:fe,canUpgrade:ve,uploading:we,downloading:F,hasManifest:ne}){const ye=ee!==this.remoteLength,me=C===this.core.tree.fork;if(this.remoteSynced=!0,this.remoteFork=C,this.remoteLength=ee,this.remoteCanUpgrade=ve,this.remoteUploading=we,this.remoteDownloading=F,this.remoteHasManifest=ne,this.closeIfIdle())return;this.lengthAcked=me?fe:0,this.syncsProcessing++,this.replicator._updateFork(this),this.remoteLength>this.core.tree.length&&this.lengthAcked===this.core.tree.length&&this.replicator._addUpgradeMaybe()!==null&&this._update();const Ee=ye===!1||me===!1?this.canUpgrade&&me:await this._canUpgrade(ee,C);ee===this.remoteLength&&C===this.core.tree.fork&&(this.canUpgrade=Ee),--this.syncsProcessing===0&&((this.needsSync===!0||this.core.tree.fork===this.remoteFork&&this.core.tree.length>this.remoteLength)&&this.signalUpgrade(),this._update())}_shouldUpdateCanUpgrade(){return this.core.tree.fork===this.remoteFork&&this.core.tree.length>this.remoteLength&&this.canUpgrade===!1&&this.syncsProcessing===0}async _updateCanUpgradeAndSync(){const{length:C,fork:ee}=this.core.tree,fe=await this._canUpgrade(this.remoteLength,this.remoteFork);this.syncsProcessing>0||C!==this.core.tree.length||ee!==this.core.tree.fork||fe!==this.canUpgrade&&(this.canUpgrade=fe,this.sendSync())}async _canUpgrade(C,ee){if(ee!==this.core.tree.fork)return!1;if(C===0)return!0;if(C>=this.core.tree.length)return!1;try{const fe=await this.core.tree.upgradeable(C);return ee!==this.core.tree.fork?!1:fe}catch{return!1}}async _getProof(C){const ee=await this.core.tree.proof(C);if(ee.block){const fe=C.block.index;if(C.fork!==this.core.tree.fork||!this.core.bitfield.get(fe))return null;ee.block.value=await this.core.blocks.get(fe)}return C.manifest&&!this.core.compat&&(ee.manifest=this.core.header.manifest),ee}async onrequest(C){const ee=this.remoteRequests.size;if(this.remoteRequests.set(C.id,C),ee===this.remoteRequests.size&&(this._cancel(C.id),this.remoteRequests.set(C.id,C)),!this.protomux.drained||this.receiverQueue.length){this.receiverQueue.push(C);return}await this._handleRequest(C)}oncancel(C){this._cancel(C.request)}_cancel(C){this.remoteRequests.delete(C),this.receiverQueue.delete(C)}ondrain(){return this._handleRequests()}async _handleRequests(){if(!this.receiverBusy){for(this.receiverBusy=!0,this.protomux.cork();this.remoteOpened&&this.protomux.drained&&this.receiverQueue.length>0&&!this.removed;){const C=this.receiverQueue.shift();await this._handleRequest(C)}this.protomux.uncork(),this.receiverBusy=!1}}async _handleRequest(C){let ee=null;if(C.fork===this.core.tree.fork)try{ee=await this._getProof(C)}catch(fe){if(a(fe),C.fork===this.core.tree.fork&&G(fe))throw fe}if(this.remoteRequests.get(C.id)===C){if(this.remoteRequests.delete(C.id),ee===null){if(C.manifest&&this.core.header.manifest){const fe=this.core.header.manifest;this.wireData.send({request:C.id,fork:this.core.tree.fork,block:null,hash:null,seek:null,upgrade:null,manifest:fe}),V(this.stats.wireData,this.replicator.stats.wireData);return}this.wireNoData.send({request:C.id});return}ee.block!==null&&this.replicator.onupload(ee.block.index,ee.block.value,this),this.wireData.send({request:C.id,fork:C.fork,block:ee.block,hash:ee.hash,seek:ee.seek,upgrade:ee.upgrade,manifest:ee.manifest}),V(this.stats.wireData,this.replicator.stats.wireData)}}_cancelRequest(C){C.priority!==j.CANCELLED&&(C.priority=j.CANCELLED,this.inflight--,this.replicator._requestDone(C.id,!1),I(C)&&this.replicator._unmarkInflight(C.block.index),L(C)&&this.replicator._clearInflightUpgrade(C),this.roundtripQueue===null&&(this.roundtripQueue=new Q),this.roundtripQueue.add(C.id),this.wireCancel.send({request:C.id}),V(this.stats.wireCancel,this.replicator.stats.wireCancel))}_checkIfConflict(){this.paused=!0;const C=Math.min(this.core.tree.length,this.remoteLength);C!==0&&(this.wireRequest.send({id:0,fork:this.remoteFork,block:null,hash:null,seek:null,upgrade:{start:0,length:C}}),V(this.stats.wireRequest,this.replicator.stats.wireRequest))}async ondata(C){if(C.request===0&&C.upgrade&&C.upgrade.start===0){if(await this.core.checkConflict(C,this))return;this.paused=!1}const ee=C.request>0?this.replicator._inflight.get(C.request):null,fe=C.fork>this.core.tree.fork;if(!(ee===null&&fe===!1)){if(ee!==null){if(ee.peer!==this)return;this._onrequestroundtrip(ee)}try{if(fe===!0)return await this.replicator._onreorgdata(this,ee,C)}catch(ve){a(ve),I(ee)&&this.replicator._unmarkInflight(ee.block.index),this.paused=!0,this.replicator.oninvalid(ve,ee,C,this);return}this.dataProcessing++;try{if(!Y(ee,C)||!await this.core.verify(C,this)){this.replicator._onnodata(this,ee);return}}catch(ve){if(a(ve),I(ee)&&this.replicator._unmarkInflight(ee.block.index),ve.code==="WRITE_FAILED"){this.paused=!0;return}if(this.core.closed&&!G(ve))return;ve.code!=="INVALID_OPERATION"&&this._checkIfConflict(),this.replicator._onnodata(this,ee),this.replicator.oninvalid(ve,ee,C,this);return}finally{this.dataProcessing--}this.replicator._ondata(this,ee,C),this._shouldUpdateCanUpgrade()===!0&&this._updateCanUpgradeAndSync()}}onnodata({request:C}){const ee=C>0?this.replicator._inflight.get(C):null;ee===null||ee.peer!==this||(this._onrequestroundtrip(ee),this.replicator._onnodata(this,ee))}_onrequestroundtrip(C){if(C.priority===j.CANCELLED||(C.priority=j.CANCELLED,this.inflight--,this.replicator._requestDone(C.id,!0),this.roundtripQueue===null))return;const ee=this.roundtripQueue.flush(C.rt);if(ee!==null)for(const fe of ee)this.replicator._inflight.reusable(fe)}onwant({start:C,length:ee}){this.replicator._onwant(this,C,ee)}onunwant(){}onbitfield({start:C,bitfield:ee}){C<this._remoteContiguousLength&&(this._remoteContiguousLength=C),this.remoteBitfield.insert(C,ee),this.missingBlocks.insert(C,ee),this._clearLocalRange(C,ee.byteLength*8),this._update()}_clearLocalRange(C,ee){const fe=this.core.skipBitfield===null?this.core.bitfield:this.core.skipBitfield;if(ee===1){this.missingBlocks.set(C,this._remoteHasBlock(C)&&!fe.get(C));return}const ve=Math.min(this.core.tree.length,this.core.header.hints.contiguousLength);if(C+ee<ve){const ne=ve-C;this.missingBlocks.setRange(C,ne,!1);return}const we=C&32767;we>0&&(C-=we,ee+=we);const F=C+Math.min(ee,this.core.tree.length);for(;C<F;){const ne=fe.getBitfield(C);ne&&ne.bitfield&&this.missingBlocks.clear(C,ne.bitfield),C+=32768}}_resetMissingBlock(C){const ee=this.core.skipBitfield===null?this.core.bitfield:this.core.skipBitfield;this.missingBlocks.set(C,this._remoteHasBlock(C)&&!ee.get(C))}_unclearLocalRange(C,ee){if(ee===1){this._resetMissingBlock(C);return}const fe=C&2097151;fe>0&&(C-=fe,ee+=fe);const ve=C,we=C+Math.min(ee,this.remoteLength);for(;C<we;){const F=this.remoteBitfield.getBitfield(C);F&&F.bitfield&&this.missingBlocks.insert(C,F.bitfield),C+=2097152}this._clearLocalRange(ve,ee)}onrange({drop:C,start:ee,length:fe}){const ve=C===!1;if(C===!0&&ee<this._remoteContiguousLength&&(this._remoteContiguousLength=ee),ee===0&&C===!1)fe>this._remoteContiguousLength&&(this._remoteContiguousLength=fe);else if(fe===1){const we=this.core.skipBitfield===null?this.core.bitfield:this.core.skipBitfield;this.remoteBitfield.set(ee,ve),this.missingBlocks.set(ee,ve&&!we.get(ee))}else{const we=this.remoteBitfield.findFirst(!ve,ee),F=fe-(we-ee);F>0&&(this.remoteBitfield.setRange(we,F,ve),this.missingBlocks.setRange(we,F,ve),ve&&this._clearLocalRange(we,F))}C===!1&&this._update()}onreorghint(){}_update(){this.replicator.updatePeer(this)}async _onconflict(){this.protomux.cork(),this.remoteLength>0&&this.core.tree.fork===this.remoteFork&&await this.onrequest({id:0,fork:this.core.tree.fork,block:null,hash:null,seek:null,upgrade:{start:0,length:Math.min(this.core.tree.length,this.remoteLength)}}),this.channel.close(),this.protomux.uncork()}_makeRequest(C,ee,fe){return C===!0&&this.replicator._shouldUpgrade(this)===!1||this.remoteLength<fe?null:(C===!1&&this.replicator._autoUpgrade(this)===!0&&(C=!0),{peer:this,rt:this.roundtripQueue===null?0:this.roundtripQueue.tick,id:0,fork:this.remoteFork,block:null,hash:null,seek:null,upgrade:C===!1?null:{start:this.core.tree.length,length:this.remoteLength-this.core.tree.length},manifest:this.core.header.manifest===null&&this.remoteHasManifest===!0,priority:ee})}_requestManifest(){const C=this._makeRequest(!1,0,0);this._send(C)}_requestUpgrade(C){const ee=this._makeRequest(!0,0,0);return ee===null?!1:(this._send(ee),!0)}_requestSeek(C){if(this.replicator._updatesPending>0)return!1;const{length:ee,fork:fe}=this.core.tree;if(fe!==this.remoteFork)return!1;if(C.seeker.start>=ee){const F=this._makeRequest(!0,0,0);return F===null?!1:(F.seek=this.remoteSupportsSeeks?{bytes:C.seeker.bytes,padding:C.seeker.padding}:null,C.inflight.push(F),this._send(F),!0)}const ve=C.seeker.end-C.seeker.start,we=C.seeker.start+Math.floor(Math.random()*ve);for(let F=0;F<ve;F++){let ne=we+F;if(ne>C.seeker.end&&(ne-=ve),this._remoteHasBlock(ne)===!1||this.core.bitfield.get(ne)===!0||!this._hasTreeParent(ne))continue;const ye=this.replicator._blocks.get(ne);if(ye!==null&&ye.inflight.length>0)continue;const me=this.replicator._hashes.add(ne,j.NORMAL);if(me.inflight.length>0)continue;const Ee=this._makeRequest(!1,me.priority,ne+1);if(Ee===null)continue;const qe=l.depth(C.seeker.start+C.seeker.end-1);return Ee.hash={index:2*ne,nodes:qe},Ee.seek=this.remoteSupportsSeeks?{bytes:C.seeker.bytes,padding:C.seeker.padding}:null,C.inflight.push(Ee),me.inflight.push(Ee),this._send(Ee),!0}return this._maybeWant(C.seeker.start,ve),!1}_hasTreeParent(C){if(this.remoteLength>=this.core.tree.length)return!0;const ee=l.iterator(C*2);let fe=2,ve=0;for(;;){ee.parent();const we=(ee.index-ee.factor/2+1)/2;if(ve=we+fe,ve>this.core.tree.length){if(ve>this.remoteLength)return!0;break}if(ve>this.remoteLength)break;fe*=2;const F=this.core.bitfield.findFirst(!0,we);if(F>-1&&F<ve)return!0}return!1}_remoteHasBlock(C){return C<this._remoteContiguousLength||this.remoteBitfield.get(C)===!0}_sendBlockRequest(C,ee){C.block={index:ee.index,nodes:0},this.replicator._markInflight(ee.index),ee.inflight.push(C),this.replicator.hotswaps.add(ee),this._send(C)}_requestBlock(C){const{length:ee,fork:fe}=this.core.tree;if(this._remoteHasBlock(C.index)===!1||fe!==this.remoteFork)return this._maybeWant(C.index),!1;if(!this._hasTreeParent(C.index))return!1;const ve=this._makeRequest(C.index>=ee,C.priority,C.index+1);return ve===null?!1:(this._sendBlockRequest(ve,C),!0)}_requestRangeBlock(C,ee){if(this.core.bitfield.get(C)===!0||!this._hasTreeParent(C))return!1;const fe=this.replicator._blocks.add(C,j.NORMAL);if(fe.inflight.length>0)return this.missingBlocks.set(C,!1),!1;const ve=this._makeRequest(C>=ee,fe.priority,C+1);return ve===null?(fe.gc(),!1):(this._sendBlockRequest(ve,fe),fe.queued&&(fe.queued=!1),!0)}_findNext(C){if(C<this._remoteContiguousLength){if(this.core.skipBitfield===null&&this.replicator._openSkipBitfield(),C=this.core.skipBitfield.findFirst(!1,C),C<this._remoteContiguousLength&&C>-1)return C;C=this._remoteContiguousLength}return this.missingBlocks.findFirst(!0,C)}_requestRange(C){const{length:ee,fork:fe}=this.core.tree;if(C.blocks){let ye=-1,me=-1;for(let Ee=C.start;Ee<C.end;Ee++){const qe=C.blocks[Ee];if((ye===-1||qe<ye)&&(ye=qe),(me===-1||qe>me)&&(me=qe),(qe<this._remoteContiguousLength||this.missingBlocks.get(qe)===!0)===!0&&this._requestRangeBlock(qe,ee))return!0}return ye>-1&&this._maybeWant(ye,me-ye),!1}const ve=Math.min(this.core.tree.length,Math.min(C.end===-1?this.remoteLength:C.end,this.remoteLength));if(ve<=C.start||fe!==this.remoteFork)return!1;const we=ve-C.start,F=C.start+(C.linear?0:Math.floor(Math.random()*we));let ne=F;for(;ne=this._findNext(ne),!(ne===-1||ne>=ve);){if(this._requestRangeBlock(ne,ee))return!0;ne++}for(ne=C.start;ne=this._findNext(ne),!(ne===-1||ne>=F);){if(this._requestRangeBlock(ne,ee))return!0;ne++}return this._maybeWant(C.start,we),!1}_requestForkProof(C){const ee=this._makeRequest(!1,0,0);ee.upgrade={start:0,length:this.remoteLength},ee.manifest=!this.core.header.manifest,C.inflight.push(ee),this._send(ee)}_requestForkRange(C){if(C.fork!==this.remoteFork||C.batch.want===null)return!1;const ee=Math.min(C.batch.want.end,this.remoteLength);if(ee<C.batch.want.start)return!1;const fe=ee-C.batch.want.start,ve=C.batch.want.start+Math.floor(Math.random()*fe);for(let we=0;we<fe;we++){let F=ve+we;if(F>=ee&&(F-=fe),this._remoteHasBlock(F)===!1)continue;const ne=this._makeRequest(!1,0,0);return ne.hash={index:2*F,nodes:C.batch.want.nodes},C.inflight.push(ne),this._send(ne),!0}return this._maybeWant(C.batch.want.start,fe),!1}_maybeWant(C,ee=1){if(C+ee<=this.remoteContiguousLength)return;let fe=Math.floor(C/_);const ve=Math.ceil((C+ee)/_);for(;fe<ve;fe++)this.segmentsWanted.has(fe)||(this.segmentsWanted.add(fe),this.wireWant.send({start:fe*_,length:_}),V(this.stats.wireWant,this.replicator.stats.wireWant))}isActive(){return!(this.paused||this.removed)}async _send(C){const ee=this.core.tree.fork;this.inflight++,this.replicator._inflight.add(C),C.upgrade!==null&&C.fork===ee&&this.replicator._addUpgrade().inflight.push(C);try{if(C.block!==null&&C.fork===ee&&(C.block.nodes=await this.core.tree.missingNodes(2*C.block.index),C.priority===j.CANCELLED))return;if(C.hash!==null&&C.fork===ee&&C.hash.nodes===0){if(C.hash.nodes=await this.core.tree.missingNodes(C.hash.index),C.priority===j.CANCELLED)return;if(C.hash.nodes===0&&(C.hash.index&1)===0){this.inflight--,this.replicator._resolveHashLocally(this,C);return}}}catch(fe){this.stream.destroy(fe);return}this.wireRequest.send(C),V(this.stats.wireRequest,this.replicator.stats.wireRequest)}}Qd=class{static Peer=le;constructor(C,ee,{notDownloadingLinger:fe=B,eagerUpgrade:ve=!0,allowFork:we=!0,inflightRange:F=null,onpeerupdate:ne=O,onupload:ye=O,oninvalid:me=O}={}){this.key=ee,this.discoveryKey=C.crypto.discoveryKey(ee),this.core=C,this.eagerUpgrade=ve,this.allowFork=we,this.onpeerupdate=ne,this.onupload=ye,this.oninvalid=me,this.ondownloading=null,this.peers=[],this.findingPeers=0,this.destroyed=!1,this.downloading=!1,this.activeSessions=0,this.hotswaps=new y,this.inflightRange=F||E,this.stats={wireSync:{tx:0,rx:0},wireRequest:{tx:0,rx:0},wireCancel:{tx:0,rx:0},wireData:{tx:0,rx:0},wireWant:{tx:0,rx:0},wireBitfield:{tx:0,rx:0},wireRange:{tx:0,rx:0},wireExtension:{tx:0,rx:0},hotswaps:0},this._attached=new Set,this._inflight=new U,this._blocks=new T,this._hashes=new T,this._queued=[],this._seeks=[],this._upgrade=null,this._reorgs=[],this._ranges=[],this._hadPeers=!1,this._ifAvailable=0,this._updatesPending=0,this._applyingReorg=null,this._manifestPeer=null,this._hasSession=!1,this._peerSessions=0,this._notDownloadingLinger=fe,this._downloadingTimer=null;const Ee=this;this._onstreamclose=qe;function qe(){Ee.detachFrom(this.userData)}}updateActivity(C,ee){this.activeSessions+=C,this.setDownloading(this.activeSessions!==0,ee)}isDownloading(){return this.downloading||!this._inflight.idle}setDownloading(C){if(clearTimeout(this._downloadingTimer),!this.destroyed){if(C||this._notDownloadingLinger===0){this.setDownloadingNow(C);return}this._downloadingTimer=setTimeout(ie,this._notDownloadingLinger,this,C)}}setDownloadingNow(C){if(this._downloadingTimer=null,this.downloading!==C&&(this.downloading=C,!(!C&&this.isDownloading()))){for(const ee of this.peers)ee.signalUpgrade();if(C)for(const ee of this._attached)ee.stream.handshakeHash&&(ee.opened({protocol:"hypercore/alpha",id:this.discoveryKey})||this._makePeer(ee,!0));else for(const ee of this.peers)ee.closeIfIdle();this.ondownloading!==null&&C&&this.ondownloading()}}cork(){for(const C of this.peers)C.protomux.cork()}uncork(){for(const C of this.peers)C.protomux.uncork()}onhave(C,ee,fe=!1){for(const ve of this.peers)ve.broadcastRange(C,ee,fe)}ontruncate(C,ee){const fe=[];for(const ve of this._blocks)ve.index<C||fe.push(ve);for(const ve of fe)for(const we of ve.refs)we.snapshot!==!1&&ve.detach(we,u());for(const ve of this.peers)ve._unclearLocalRange(C,ee)}onupgrade(){for(const C of this.peers)C.signalUpgrade();this._blocks.isEmpty()===!1&&this._resolveBlocksLocally(),this._upgrade!==null&&this._resolveUpgradeRequest(null),(this._ranges.length!==0||this._seeks.length!==0)&&this._updateNonPrimary(!0)}async onconflict(C){const ee=[];for(const fe of this.peers)ee.push(fe._onconflict());await Promise.allSettled(ee)}async applyPendingReorg(){if(this._applyingReorg!==null)return await this._applyingReorg,!0;for(let C=this._reorgs.length-1;C>=0;C--){const ee=this._reorgs[C];if(ee.batch!==null&&ee.batch.finished)return await this._applyReorg(ee),!0}return!1}addUpgrade(C){if(this._upgrade!==null){const fe=this._upgrade.attach(C);return this._checkUpgradeIfAvailable(),fe}const ee=this._addUpgrade().attach(C);return this.updateAll(),ee}addBlock(C,ee){const fe=this._blocks.add(ee,j.HIGH),ve=fe.attach(C);return this._queueBlock(fe),this.updateAll(),ve}addSeek(C,ee){const fe=new q(this._seeks,ee),ve=fe.attach(C);return this._seeks.push(fe),this.updateAll(),ve}addRange(C,{start:ee=0,end:fe=-1,length:ve=P(ee,fe),blocks:we=null,linear:F=!1,ifAvailable:ne=!1}={}){we!==null&&(ee=0,fe=ve=we.length);const ye=new R(this._ranges,ee,ve===-1?-1:ee+ve,F,ne,we),me=ye.attach(C);return Z(this.core,ye),this._ranges.push(ye),ye.end!==-1&&ye.start>=ye.end?(this._resolveRangeRequest(ye,this._ranges.length-1),me):(this.updateAll(),me)}cancel(C){C.context.detach(C,null)}clearRequests(C,ee=null){let fe=!1;for(;C.length>0;){const ve=C[C.length-1];ve.context.detach(ve,ee),fe=!0}fe&&this.updateAll()}_addUpgradeMaybe(){return this.eagerUpgrade===!0?this._addUpgrade():this._upgrade}_checkUpgradeIfAvailable(){if(this._ifAvailable>0&&this.peers.length<M||this._upgrade===null||this._upgrade.refs.length===0||this._hadPeers===!1&&this.findingPeers>0)return;const C=Math.min(this.peers.length,M);for(let fe=0;fe<C;fe++){const ve=this.peers[fe];if(ve.remoteSynced===!1||this.core.tree.length===0&&ve.remoteLength>0)return;if(!(ve.remoteLength<=this._upgrade.length||ve.remoteFork!==this._upgrade.fork)&&(ve.syncsProcessing>0||ve.lengthAcked!==this.core.tree.length&&ve.remoteFork===this.core.tree.fork||ve.remoteCanUpgrade===!0))return}if(this._applyingReorg!==null)return;for(let fe=0;fe<this._reorgs.length;fe++)if(this._reorgs[fe].inflight.length>0)return;if(this._upgrade.inflight.length>0)return;const ee=this._upgrade;this._upgrade=null,ee.resolve(!1)}_addUpgrade(){return this._upgrade!==null?this._upgrade:(this._upgrade=new A(this,this.core.tree.fork,this.core.tree.length),this._upgrade)}_addReorg(C,ee){if(this.allowFork===!1)return null;for(const we of this._reorgs){if(we.fork>C&&we.batch!==null)return null;if(we.fork===C)return we}const fe={fork:C,inflight:[],batch:null};this._reorgs.push(fe);let ve=this._reorgs.length-1;for(;ve>0&&this._reorgs[ve-1].fork>C;)this._reorgs[ve]=this._reorgs[ve-1],this._reorgs[--ve]=fe;return fe}_shouldUpgrade(C){return this._upgrade!==null&&this._upgrade.inflight.length>0?!1:C.remoteCanUpgrade===!0&&C.remoteLength>this.core.tree.length&&C.lengthAcked===this.core.tree.length}_autoUpgrade(C){return this._upgrade!==null&&C.remoteFork===this.core.tree.fork&&this._shouldUpgrade(C)}_addPeer(C){this._hadPeers=!0,this.peers.push(C),this.updatePeer(C),this.onpeerupdate(!0,C)}_requestDone(C,ee){if(this._inflight.remove(C,ee),this.isDownloading()!==!0)for(const fe of this.peers)fe.signalUpgrade()}_removePeer(C){this.peers.splice(this.peers.indexOf(C),1),this._manifestPeer===C&&(this._manifestPeer=null);for(const ee of this._inflight)ee.peer===C&&(this._inflight.remove(ee.id,!0),this._clearRequest(C,ee));C.useSession&&this._closeSessionMaybe(),this.onpeerupdate(!1,C),this.updateAll()}_queueBlock(C){C.inflight.length>0||C.queued===!0||(C.queued=!0,this._queued.push(C))}_resolveHashLocally(C,ee){this._requestDone(ee.id,!1),this._resolveBlockRequest(this._hashes,ee.hash.index/2,null,ee),this.updatePeer(C)}async _resolveBlocksLocally(){let C=null;for(const ee of this._blocks)if(this.core.bitfield.get(ee.index)!==!1){try{ee.resolve(await this.core.blocks.get(ee.index))}catch(fe){ee.reject(fe)}C===null&&(C=[]),C.push(ee)}if(C!==null)for(const ee of C)this._blocks.remove(ee.index),oe(ee)}_resolveBlockRequest(C,ee,fe,ve){const we=C.remove(ee);if(we===null)return!1;if(ue(we.inflight,ve),oe(we),we.queued=!1,we.resolve(fe),we.inflight.length>0)for(let F=we.inflight.length-1;F>=0;F--){const ne=we.inflight[F];ne.peer._cancelRequest(ne)}return!0}_resolveUpgradeRequest(C){if(C!==null&&ue(this._upgrade.inflight,C),this.core.tree.length===this._upgrade.length&&this.core.tree.fork===this._upgrade.fork)return!1;const ee=this._upgrade;return this._upgrade=null,ee.resolve(!0),!0}_resolveRangeRequest(C,ee){const fe=this._ranges.pop();ee<this._ranges.length&&(this._ranges[ee]=fe),C.resolve(!0)}_clearInflightBlock(C,ee){const fe=C===this._blocks,ve=fe===!0?ee.block.index:ee.hash.index/2,we=C.get(ve);if(!(we===null||ue(we.inflight,ee)===!1)){if(oe(we)===!0&&we.inflight.length>0&&this.hotswaps.add(we),we.refs.length>0&&fe===!0){this._queueBlock(we);return}we.gc()}}_clearInflightUpgrade(C){ue(this._upgrade.inflight,C)!==!1&&this._upgrade.gc()}_clearInflightSeeks(C){for(const ee of this._seeks)ue(ee.inflight,C)!==!1&&ee.gc()}_clearInflightReorgs(C){for(const ee of this._reorgs)ue(ee.inflight,C)}_clearOldReorgs(C){for(let ee=0;ee<this._reorgs.length;ee++)this._reorgs[ee].fork>=C||(ee===this._reorgs.length-1?this._reorgs.pop():this._reorgs[ee]=this._reorgs.pop(),ee--)}async _updateNonPrimary(C){for(;++this._updatesPending===1;){let ee=Math.min(z,this._ranges.length);for(let fe=0;fe<ee;fe++){const ve=this._ranges[fe];Z(this.core,ve),ve.end!==-1&&ve.start>=ve.end&&(this._resolveRangeRequest(ve,fe--),ee>this._ranges.length&&ee--,this._ranges.length===z&&(C=!0))}for(let fe=0;fe<this._seeks.length;fe++){const ve=this._seeks[fe];let we=null,F=null;try{F=await ve.seeker.update()}catch(ne){we=ne}!F&&!we||(fe<this._seeks.length-1?this._seeks[fe]=this._seeks.pop():this._seeks.pop(),fe--,we?ve.reject(we):ve.resolve(F))}if(--this._updatesPending===0)break;this._updatesPending=0}(this._inflight.idle||C)&&this.updateAll()}_maybeResolveIfAvailableRanges(){if(!(this._ifAvailable>0||!this._inflight.idle||!this._ranges.length)){for(let C=0;C<this.peers.length;C++)if(this.peers[C].dataProcessing>0)return;for(let C=0;C<this._ranges.length;C++){const ee=this._ranges[C];ee.ifAvailable&&this._resolveRangeRequest(ee,C--)}}}_clearRequest(C,ee){ee.block!==null&&(this._clearInflightBlock(this._blocks,ee),this._unmarkInflight(ee.block.index)),ee.hash!==null&&this._clearInflightBlock(this._hashes,ee),ee.upgrade!==null&&this._upgrade!==null&&this._clearInflightUpgrade(ee),this._seeks.length>0&&this._clearInflightSeeks(ee),this._reorgs.length>0&&this._clearInflightReorgs(ee)}_onnodata(C,ee){this._clearRequest(C,ee),this.updateAll()}_openSkipBitfield(){const C=this.core.openSkipBitfield();for(const ee of this._inflight)ee.block&&C.set(ee.block.index,!0)}_markInflight(C){this.core.skipBitfield!==null&&this.core.skipBitfield.set(C,!0);for(const ee of this.peers)ee._markInflight(C)}_unmarkInflight(C){this.core.skipBitfield!==null&&this.core.skipBitfield.set(C,this.core.bitfield.get(C));for(const ee of this.peers)ee._resetMissingBlock(C)}_ondata(C,ee,fe){fe.block!==null&&this._resolveBlockRequest(this._blocks,fe.block.index,fe.block.value,ee),fe.hash!==null&&(fe.hash.index&1)===0&&this._resolveBlockRequest(this._hashes,fe.hash.index/2,null,ee),this._upgrade!==null&&this._resolveUpgradeRequest(ee),this._seeks.length>0&&this._clearInflightSeeks(ee),this._reorgs.length>0&&this._clearInflightReorgs(ee),this._manifestPeer===C&&this.core.header.manifest!==null&&(this._manifestPeer=null),(this._seeks.length>0||this._ranges.length>0)&&this._updateNonPrimary(this._seeks.length>0),this.updatePeer(C)}_onwant(C,ee,fe){const ve=Math.min(this.core.tree.length,this.core.header.hints.contiguousLength);if(ee+fe<ve||this.core.tree.length===ve){C.wireRange.send({drop:!1,start:0,length:ve}),V(C.stats.wireRange,this.stats.wireRange);return}fe=Math.min(fe,this.core.tree.length-ee),C.protomux.cork();for(const we of this.core.bitfield.want(ee,fe))C.wireBitfield.send(we),V(C.stats.wireBitfield,this.stats.wireBitfield);C.protomux.uncork()}async _onreorgdata(C,ee,fe){const ve=fe.upgrade&&await this.core.verifyReorg(fe),we=this._addReorg(fe.fork,C);if(we===null){this.updateAll();return}ue(we.inflight,ee),we.batch?await we.batch.update(fe):fe.upgrade&&(we.batch=ve,this._clearOldReorgs(we.fork)),we.batch&&we.batch.finished&&this._addUpgradeMaybe()!==null&&await this._applyReorg(we),this.updateAll()}async _applyReorg(C){const ee=this._upgrade;this._reorgs=[],this._applyingReorg=this.core.reorg(C.batch,null);try{await this._applyingReorg}catch(fe){this._upgrade=null,ee.reject(fe)}this._applyingReorg=null,this._upgrade!==null&&this._resolveUpgradeRequest(null);for(const fe of this.peers)this._updateFork(fe);for(const fe of this._ranges)fe.start=fe.userStart,fe.end=fe.userEnd;this.updateAll()}_maybeUpdate(){return this._upgrade!==null&&this._upgrade.inflight.length===0}_maybeRequestManifest(){return this.core.header.manifest===null&&this._manifestPeer===null}_updateFork(C){if(this._applyingReorg!==null||this.allowFork===!1||C.remoteFork<=this.core.tree.fork)return!1;const ee=this._addReorg(C.remoteFork,C);return ee!==null&&ee.batch===null&&ee.inflight.length===0?C._requestForkProof(ee):!1}_updateHotswap(C){const ee=C.getMaxHotswapInflight();if(!(!C.isActive()||C.inflight>=ee)){for(const fe of this.hotswaps.pick(C))if(C._requestBlock(fe)!==!1&&(C.stats.hotswaps++,C.replicator.stats.hotswaps++,C.inflight>=ee))break}}_updatePeer(C){if(!C.isActive()||C.inflight>=C.getMaxInflight())return!1;this._maybeRequestManifest()===!0&&C.remoteLength===0&&C.remoteHasManifest===!0&&(this._manifestPeer=C,C._requestManifest());for(const fe of this._seeks)if(!(fe.inflight.length>0)&&C._requestSeek(fe)===!0)return!0;const ee=new p(this._queued);for(const fe of ee)if(fe.queued===!1||C._requestBlock(fe)===!0)return fe.queued=!1,ee.dequeue(),!0;return!1}_updatePeerNonPrimary(C){if(!C.isActive()||C.inflight>=C.getMaxInflight())return!1;const ee=new p(this._ranges);let fe=0;for(const ve of ee){if(C._requestRange(ve)===!0)return!0;if(++fe>=z)break}for(let ve=this._reorgs.length-1;ve>=0;ve--){const we=this._reorgs[ve];if(we.batch!==null&&we.inflight.length===0&&C._requestForkRange(we)===!0)return!0}return this._maybeUpdate()===!0&&C._requestUpgrade(this._upgrade)===!0}updatePeer(C){if(this._applyingReorg===null){for(;this._updatePeer(C)===!0;);for(;this._updatePeerNonPrimary(C)===!0;);this.peers.length>1&&this._blocks.isEmpty()===!1&&this._updateHotswap(C),this._checkUpgradeIfAvailable(),this._maybeResolveIfAvailableRanges()}}updateAll(){if(this._applyingReorg!==null)return;const C=new p(this.peers);for(const ee of C)this._updatePeer(ee)===!0&&C.requeue();if(this._maybeUpdate()===!1&&this._ranges.length===0&&this._reorgs.length===0){this._checkUpgradeIfAvailable();return}for(const ee of C.restart())this._updatePeerNonPrimary(ee)===!0&&C.requeue();this._checkUpgradeIfAvailable(),this._maybeResolveIfAvailableRanges()}_closeSessionMaybe(){if(this._hasSession&&this._peerSessions===0&&(this._hasSession=!1,this.core.active--),this.core.active===0&&this.core.sessions.length===0){this.destroy(),this.core.close().catch(a);return}this.core.sessions.length===1&&this.core.active===1&&this.core.sessions[0].autoClose&&this.core.sessions[0].close().catch(a)}attached(C){return this._attached.has(C)}ensureSession(){this._hasSession||(this._hasSession=!0,this.core.active++)}attachTo(C,ee){if(this.core.closed)return;ee&&this.ensureSession();const fe=this._makePeer.bind(this,C,ee);this._attached.add(C),C.pair({protocol:"hypercore/alpha",id:this.discoveryKey},fe),C.stream.setMaxListeners(0),C.stream.on("close",this._onstreamclose),ee&&this._peerSessions++,this._ifAvailable++,C.stream.opened.then(ve=>{ee&&this._peerSessions--,this._ifAvailable--,ve&&!this.destroyed?fe():ee&&this._closeSessionMaybe(),this._checkUpgradeIfAvailable()})}detachFrom(C){this._attached.delete(C)&&(C.stream.removeListener("close",this._onstreamclose),C.unpair({protocol:"hypercore/alpha",id:this.discoveryKey}))}destroy(){this.destroyed=!0,this._downloadingTimer&&(clearTimeout(this._downloadingTimer),this._downloadingTimer=null);const C=[];for(;this.peers.length;){const ee=this.peers[this.peers.length-1];this.detachFrom(ee.protomux),ee.channel.close(),C.push(ee.channel.fullyClosed())}for(const ee of this._attached)this.detachFrom(ee);return Promise.all(C)}_makePeer(C,ee){const fe=this;if(C.opened({protocol:"hypercore/alpha",id:this.discoveryKey}))return ne();const ve=C.createChannel({userData:null,protocol:"hypercore/alpha",aliases:["hypercore"],id:this.discoveryKey,handshake:f.wire.handshake,messages:[{encoding:f.wire.sync,onmessage:S},{encoding:f.wire.request,onmessage:N},{encoding:f.wire.cancel,onmessage:D},{encoding:f.wire.data,onmessage:H},{encoding:f.wire.noData,onmessage:_e},{encoding:f.wire.want,onmessage:ce},{encoding:f.wire.unwant,onmessage:J},{encoding:f.wire.bitfield,onmessage:d},{encoding:f.wire.range,onmessage:k},{encoding:f.wire.extension,onmessage:X}],onopen:re,onclose:W,ondrain:$});if(ve===null)return ne();const we=new le(fe,C,ve,ee,this.inflightRange),F=C.stream;return ee&&(fe.ensureSession(),fe._peerSessions++),we.channel.open({seeks:!0,capability:m.replicate(F.isInitiator,this.key,F.handshakeHash)}),!0;function ne(){return ee&&fe._closeSessionMaybe(),!1}}};function Y(de,C){return C.block!==null&&(de.block===null||de.block.index!==C.block.index)||C.hash!==null&&(de.hash===null||de.hash.index!==C.hash.index)||C.seek!==null&&(de.seek===null||de.seek.bytes!==C.seek.bytes)||C.upgrade!==null&&de.upgrade===null?!1:de.fork===C.fork}function oe(de){return de.hotswap===null?!1:(de.hotswap.ref.remove(de),!0)}function ue(de,C){const ee=de.indexOf(C);return ee===-1?!1:(ee<de.length-1?de[ee]=de.pop():de.pop(),!0)}function O(){}function P(de,C){return C===-1?-1:C<de?0:C-de}function Z(de,C){if(C.blocks===null){const ee=de.bitfield.firstUnset(C.start);if(C.end===-1)C.start=ee===-1?de.tree.length:ee;else if(ee===-1||ee>=C.end)C.start=C.end;else{C.start=ee;const fe=de.bitfield.lastUnset(C.end-1);fe===-1||ee>=fe+1?C.end=C.start:C.end=fe+1}}else{for(;C.start<C.end&&de.bitfield.get(C.blocks[C.start]);)C.start++;for(;C.start<C.end&&de.bitfield.get(C.blocks[C.end-1]);)C.end--}}function he(de){de.context&&de.context.detach(de,c())}function se(de){de.timeout!==null&&(clearTimeout(de.timeout),de.timeout=null)}function G(de){return de.name==="HypercoreError"}function re(de,C){return C.userData.onopen(de)}function W(de,C){return C.userData.onclose(de)}function $(de){return de.userData.ondrain()}function S(de,C){return te(C.userData.stats.wireSync,C.userData.replicator.stats.wireSync),C.userData.onsync(de)}function N(de,C){return te(C.userData.stats.wireRequest,C.userData.replicator.stats.wireRequest),C.userData.onrequest(de)}function D(de,C){return te(C.userData.stats.wireCancel,C.userData.replicator.stats.wireCancel),C.userData.oncancel(de)}function H(de,C){return te(C.userData.stats.wireData,C.userData.replicator.stats.wireData),C.userData.ondata(de)}function _e(de,C){return C.userData.onnodata(de)}function ce(de,C){return te(C.userData.stats.wireWant,C.userData.replicator.stats.wireWant),C.userData.onwant(de)}function J(de,C){return C.userData.onunwant(de)}function d(de,C){return te(C.userData.stats.wireBitfield,C.userData.replicator.stats.wireBitfield),C.userData.onbitfield(de)}function k(de,C){return te(C.userData.stats.wireRange,C.userData.replicator.stats.wireRange),C.userData.onrange(de)}function X(de,C){return te(C.userData.stats.wireExtension,C.userData.replicator.stats.wireExtension),C.userData.onextension(de)}function ie(de,C,ee){de.setDownloadingNow(C,ee)}function I(de){return de!==null&&de.block!==null}function L(de){return de!==null&&de.upgrade!==null}function V(de,C){de.tx++,C.tx++}function te(de,C){de.rx++,C.rx++}return Qd}var Xd={},Zd,Ob;function px(){if(Ob)return Zd;Ob=1;const n=new Array(16);for(let a=0;a<16;a++)n[a]=new Uint32Array(256);for(let a=0;a<=255;a++){let p=a;for(let l=0;l<8;l++)p=p>>>1^(p&1)*3988292384;n[0][a]=p}for(let a=0;a<=255;a++)for(let p=1;p<16;p++)n[p][a]=n[p-1][a]>>>8^n[0][n[p-1][a]&255];return Zd=n,Zd}var Pb;function yx(){if(Pb)return Xd;Pb=1;const n=px();return Xd.crc32=function(p){let l=-1,g=0,y=p.byteLength;for(;y>=16;)l=n[15][p[g++]^l&255]^n[14][p[g++]^l>>>8&255]^n[13][p[g++]^l>>>16&255]^n[12][p[g++]^l>>>24]^n[11][p[g++]]^n[10][p[g++]]^n[9][p[g++]]^n[8][p[g++]]^n[7][p[g++]]^n[6][p[g++]]^n[5][p[g++]]^n[4][p[g++]]^n[3][p[g++]]^n[2][p[g++]]^n[1][p[g++]]^n[0][p[g++]],y-=16;for(;y-- >0;)l=l>>>8^n[0][l&255^p[g++]];return~l>>>0},Xd}var $d,Ib;function _x(){if(Ib)return $d;Ib=1;const n=et(),a=Ue(),{crc32:p}=yx(),{OPLOG_CORRUPT:l,OPLOG_HEADER_OVERFLOW:g,WRITE_FAILED:y}=Lt();return $d=class{constructor(o,{pageSize:c=4096,headerEncoding:s=n.raw,entryEncoding:u=n.raw,readonly:f=!1}={}){this.storage=o,this.headerEncoding=s,this.entryEncoding=u,this.readonly=f,this.flushed=!1,this.byteLength=0,this.length=0,this._headers=[1,0],this._pageSize=c,this._entryOffset=c*2}_addHeader(o,c,s,u){o.start=o.start-c-4,n.uint32.encode(o,c<<2|s|u),o.start-=8,n.uint32.encode(o,p(o.buffer.subarray(o.start+4,o.start+8+c))),o.start+=c+4}_decodeEntry(o,c){if(o.end-o.start<8)return null;const s=n.uint32.decode(o),u=n.uint32.decode(o),f=u>>>2,m=u&1,E=u&2;if(o.end-o.start<f)return null;const b=o.start+f;if(p(o.buffer.subarray(o.start-4,b))!==s)return null;const _={header:m,partial:E!==0,byteLength:f+8,message:null};try{_.message=c.decode({start:o.start,end:b,buffer:o.buffer})}catch{return null}return o.start=b,_}async open(){const o=await this._readAll(),c={start:0,end:o.byteLength,buffer:o},s={header:null,entries:[]};this.byteLength=0,this.length=0;const u=this._decodeEntry(c,this.headerEncoding);c.start=this._pageSize;const f=this._decodeEntry(c,this.headerEncoding);if(c.start=this._entryOffset,!u&&!f){if(this.flushed=!1,this._headers[0]=1,this._headers[1]=0,o.byteLength>=this._entryOffset)throw l();return s}this.flushed=!0,u&&!f?(this._headers[0]=u.header,this._headers[1]=u.header):!u&&f?(this._headers[0]=f.header+1&1,this._headers[1]=f.header):(this._headers[0]=u.header,this._headers[1]=f.header);const m=this._headers[0]+this._headers[1]&1,E=[];for(s.header=m?f.message:u.message;;){const _=this._decodeEntry(c,this.entryEncoding);if(!_||_.header!==m)break;E.push(_)}for(;E.length>0&&E[E.length-1].partial;)E.pop();for(const _ of E)s.entries.push(_.message),this.byteLength+=_.byteLength,this.length++;const b=this.byteLength+this._entryOffset;return b===o.byteLength||await new Promise((_,B)=>{if(this.readonly)return _();this.storage.truncate(b,M=>{if(M)return B(M);_()})}),s}_readAll(){return new Promise((o,c)=>{this.storage.open(s=>{if(s&&s.code!=="ENOENT")return c(s);if(s)return o(a.alloc(0));this.storage.stat((u,f)=>{if(u&&u.code!=="ENOENT")return c(u);this.storage.read(0,f.size,(m,E)=>{if(m)return c(m);o(E)})})})})}flush(o){const c={start:8,end:8,buffer:null},s=this._headers[0]===this._headers[1]?1:0,u=this._headers[s]+1&1;if(this.headerEncoding.preencode(c,o),c.end>this._pageSize)throw g();return c.buffer=a.allocUnsafe(c.end),this.headerEncoding.encode(c,o),this._addHeader(c,c.end-8,u,0),this._writeHeaderAndTruncate(s,u,c.buffer)}_writeHeaderAndTruncate(o,c,s){return new Promise((u,f)=>{this.storage.write(o===0?0:this._pageSize,s,m=>{if(m)return f(m);this.storage.truncate(this._entryOffset,E=>{if(E)return f(E);this._headers[o]=c,this.byteLength=0,this.length=0,this.flushed=!0,u()})})})}append(o,c=!0){Array.isArray(o)||(o=[o]);const s={start:0,end:o.length*8,buffer:null},u=this._headers[0]+this._headers[1]&1;for(let f=0;f<o.length;f++)this.entryEncoding.preencode(s,o[f]);s.buffer=a.allocUnsafe(s.end);for(let f=0;f<o.length;f++){const m=s.start+=8,E=c&&f<o.length-1?2:0;this.entryEncoding.encode(s,o[f]),this._addHeader(s,s.start-m,u,E)}return this._append(s.buffer,o.length)}close(){return new Promise((o,c)=>{this.storage.close(s=>{if(s)return c(s);o()})})}_append(o,c){return new Promise((s,u)=>{this.storage.write(this._entryOffset+this.byteLength,o,f=>{if(f)return u(y(f.message));this.byteLength+=o.byteLength,this.length+=c,s()})})}},$d}var Jd,Kb;function mx(){if(Kb)return Jd;Kb=1;const n=et(),{oplog:a}=bo();return Jd=class{constructor(l){this.storage=l}async load(l){const g=await new Promise((h,o)=>{this.storage.read(l.start,l.length,(c,s)=>{if(c)return o(c);h(s)})}),y=n.decode(a.header,g);return y.external=l,y}async flush(l){const g=l.external||{start:0,length:0};l.external=null;const y=n.encode(a.header,l);let h=0;if(y.byteLength>g.start){h=g.start+g.length;const o=h&4095;o>0&&(h+=4096-o)}return l.external={start:h,length:y.byteLength},await new Promise((o,c)=>{this.storage.write(h,y,s=>{if(s)return c(s);o()})}),l}close(){return new Promise((l,g)=>{this.storage.close(y=>{if(y)return g(y);l()})})}},Jd}var ef,zb;function wx(){return zb||(zb=1,ef=class{constructor(){this.locked=!1,this.destroyed=!1,this._destroying=null,this._destroyError=null,this._queue=[],this._enqueue=(a,p)=>this._queue.push([a,p])}lock(){return this.destroyed?Promise.reject(this._destroyError||new Error("Mutex has been destroyed")):this.locked?new Promise(this._enqueue):(this.locked=!0,Promise.resolve())}unlock(){if(!this._queue.length){this.locked=!1;return}this._queue.shift()[0]()}destroy(a){if(this._destroying||(this._destroying=this.locked?this.lock().catch(()=>{}):Promise.resolve()),this.destroyed=!0,a&&(this._destroyError=a),a)for(;this._queue.length;)this._queue.shift()[1](a);return this._destroying}}),ef}var tf,Hb;function bx(){if(Hb)return tf;Hb=1;const n=rn(),a=_t(),p=et(),l=g0(),g=Ue(),y=Xt(),h=wo(),{INVALID_PROOF:o,INVALID_CHECKSUM:c,INVALID_OPERATION:s,BAD_ARGUMENT:u,ASSERTION:f}=Lt(),m=g.alloc(32),E=g.from([5,2,87,2,0,0,40,7,66,76,65,75,69,50,98]),b=128;class _{constructor(d,k=null){this.i=0,this.nodes=d,this.extra=k,this.length=d.length+(this.extra===null?0:1)}shift(d){if(this.extra!==null&&this.extra.index===d){const X=this.extra;return this.extra=null,this.length--,X}if(this.i>=this.nodes.length)throw s("Expected node "+d+", got (nil)");const k=this.nodes[this.i++];if(k.index!==d)throw s("Expected node "+d+", got node "+k.index);return this.length--,k}}class B{constructor(d){this.fork=d.fork,this.roots=[...d.roots],this.length=d.length,this.ancestors=d.length,this.byteLength=d.byteLength,this.signature=null,this.hashCached=null,this.treeLength=d.length,this.treeFork=d.fork,this.tree=d,this.nodes=[],this.upgraded=!1}checkout(d,k){const X=[];let ie=0;const I=2*d-2,L=new Set,V=new Map;if(k)for(const te of k)V.set(te.index,te);for(const te of this.nodes)V.set(te.index,te);for(const te of n.fullRoots(I+2)){const de=n.leftSpan(te);if(de!==0&&L.add(de-1),ie<this.roots.length&&this.roots[ie].index===te){X.push(this.roots[ie++]);continue}const C=V.get(te);if(!C)throw new u("root missing for given length");X.push(C)}this.roots=X,this.length=d,this.byteLength=ue(X),this.hashCached=null,this.signature=null;for(let te=0;te<this.nodes.length;te++){const de=this.nodes[te].index;if(de<=I&&!L.has(de))continue;const C=this.nodes.pop();te<this.nodes.length&&(this.nodes[te--]=C)}}prune(d){if(d===0)return;const k=2*d-2,X=new Set;for(const ie of n.fullRoots(k+2)){const I=n.leftSpan(ie);I!==0&&X.add(I-1)}for(let ie=0;ie<this.nodes.length;ie++){const I=this.nodes[ie].index;if(I>k||X.has(I))continue;const L=this.nodes.pop();ie<this.nodes.length&&(this.nodes[ie--]=L)}}clone(){const d=new B(this.tree);return d.fork=this.fork,d.roots=[...this.roots],d.length=this.length,d.byteLength=this.byteLength,d.signature=this.signature,d.treeLength=this.treeLength,d.treeFork=this.treeFork,d.tree=this.tree,d.nodes=[...this.nodes],d.upgraded=this.upgraded,d}hash(){return this.hashCached===null&&(this.hashCached=y(this.tree.crypto.tree(this.roots))),this.hashCached}signable(d){return h.treeSignable(d,this.hash(),this.length,this.fork)}signableCompat(d){return h.treeSignableCompat(this.hash(),this.length,this.fork,d)}get(d,k){if(d>=this.length*2)return null;for(const X of this.nodes)if(X.index===d)return X;return this.tree.get(d,k)}proof({block:d,hash:k,seek:X,upgrade:ie}){return D(this,d,k,X,ie)}verifyUpgrade(d){const k=w(d,this.tree.crypto,this.nodes);if(!d.upgrade)throw s("Expected upgrade proof");return R(d,k,this)}append(d){const k=this.length*2,X=n.iterator(k),ie=P(this.tree.crypto,k,d);this.appendRoot(ie,X)}appendRoot(d,k){for(d=ce(d),this.hashCached=null,this.upgraded=!0,this.length+=k.factor/2,this.byteLength+=d.size,this.roots.push(d),this.nodes.push(d);this.roots.length>1;){const X=this.roots[this.roots.length-1],ie=this.roots[this.roots.length-2];if(k.sibling()!==ie.index){k.sibling();break}const I=ce(Z(this.tree.crypto,k.parent(),X,ie));this.nodes.push(I),this.roots.pop(),this.roots.pop(),this.roots.push(I)}}commitable(){return this.treeFork===this.tree.fork&&(this.upgraded?this.treeLength===this.tree.length:this.treeLength<=this.tree.length)}commit(){if(!this.commitable())throw s("Tree was modified during batch, refusing to commit");this.upgraded&&this._commitUpgrade();for(let d=0;d<this.nodes.length;d++){const k=this.nodes[d];this.tree.unflushed.set(k.index,k)}}_commitUpgrade(){if(this.ancestors<this.treeLength){if(this.ancestors>0){const d=2*this.ancestors,k=n.iterator(d-2);for(;k.contains(d)&&k.index<d&&this.tree.unflushed.set(k.index,he(k.index)),k.offset!==0;)k.parent()}this.tree.truncateTo=this.tree.truncated?Math.min(this.tree.truncateTo,this.ancestors):this.ancestors,this.tree.truncated=!0,this.tree.cache=new l({maxSize:this.tree.cache.maxSize}),W(this.tree.unflushed,this.ancestors),this.tree.flushing!==null&&W(this.tree.flushing,this.ancestors)}this.tree.roots=this.roots,this.tree.length=this.length,this.tree.byteLength=this.byteLength,this.tree.fork=this.fork,this.tree.signature=this.signature}seek(d,k){return new z(this,d,k)}byteRange(d){return j(this,d)}byteOffset(d){return d===2*this.tree.length?this.tree.byteLength:v(this,d)}}class M extends B{constructor(d){super(d),this.roots=[],this.length=0,this.byteLength=0,this.diff=null,this.ancestors=0,this.upgraded=!0,this.want={nodes:0,start:0,end:0}}get finished(){return this.want===null}update(d){if(this.want===null)return!0;const k=[],X=w(d,this.tree.crypto,k);return X===null||!g.equals(X.hash,this.diff.hash)?!1:(this.nodes.push(...k),this._update(k))}async _update(d){const k=new Map;for(const L of d)k.set(L.index,L);let X=null;const ie=n.iterator(this.diff.index),I=this.diff;for(;(ie.index&1)!==0;){const L=k.get(ie.leftChild());if(!L)break;const V=await this.tree.get(L.index,!1);!V||!g.equals(V.hash,L.hash)?X=L:X=k.get(ie.sibling())}return(this.diff.index&1)===0?!0:X===null||I!==this.diff?!1:this._updateDiffRoot(X)}_updateDiffRoot(d){if(this.want===null)return!0;const k=n.spans(d.index),X=k[0]/2,ie=Math.min(this.treeLength,k[1]/2+1),I=ie-X;return this.ancestors=X,this.diff=d,(d.index&1)===0||this.want.start>=this.treeLength||I<=0?(this.want=null,!0):(this.want.start=X,this.want.end=ie,this.want.nodes=$(k[1]-k[0]+2)-1,!1)}}class z{constructor(d,k,X=0){this.tree=d,this.bytes=k,this.padding=X;const ie=d.byteLength-d.length*X;this.start=k>=ie?d.length:0,this.end=k<ie?d.length:0}async _seek(d){if(!d)return[0,0];for(const k of this.tree.roots){const X=H(k,this.padding,null);if(d===X)return[n.rightSpan(k.index)+2,0];if(d>X){d-=X;continue}const ie=n.iterator(k.index);for(;(ie.index&1)!==0;){const I=await this.tree.get(ie.leftChild(),!1);if(I){const L=H(I,this.padding,ie);if(L===d)return[ie.rightSpan()+2,0];if(L>d)continue;d-=L,ie.sibling()}else return ie.parent(),[ie.index,d]}return[ie.index,d]}return null}async update(){const d=await this._seek(this.bytes);if(!d)return null;if((d[0]&1)===0)return[d[0]/2,d[1]];const k=n.spans(d[0]);return this.start=k[0]/2,this.end=k[1]/2+1,null}}tf=class m0{constructor(d,k,X,ie,I){this.crypto=a,this.fork=X,this.roots=k,this.length=k.length?O(k)/2:0,this.byteLength=ue(k),this.signature=ie,this.prologue=I,this.storage=d,this.unflushed=new Map,this.cache=new l({maxSize:b}),this.flushing=null,this.truncated=!1,this.truncateTo=0}addNode(d){d.size===0&&g.equals(d.hash,m)&&(d=he(d.index)),this.unflushed.set(d.index,d)}batch(){return new B(this)}async restoreBatch(d){const k=new B(this);if(d===this.length)return k;const X=_e(await this.getRoots(d));k.roots=X,k.length=d,k.byteLength=0,k.ancestors=d;for(const ie of X)k.byteLength+=ie.size;return k}seek(d,k){return new z(this,d,k)}hash(){return y(this.crypto.tree(this.roots))}signable(d){return h.treeSignable(d,this.hash(),this.length,this.fork)}getRoots(d){const k=n.fullRoots(2*d),X=new Array(k.length);for(let ie=0;ie<k.length;ie++)X[ie]=this.get(k[ie],!0);return Promise.all(X)}setPrologue({hash:d,length:k}){this.prologue={hash:d,length:k}}addNodes(d){for(let k=0;k<d.length;k++){const X=d[k];this.unflushed.set(X.index,X)}}getNeededNodes(d,k,X){const ie=new Map,I=d*2;for(let L=k;L<X;L++){const V=n.iterator(L*2);for(;!ie.has(V.index);){ie.set(V.index,this.get(V.index,!0));const te=V.sibling();if(V.parent(),V.contains(I)||ie.has(te))break;ie.set(te,this.get(te,!0))}}return Promise.all([...ie.values()])}async upgradeable(d){const k=n.fullRoots(2*d),X=new Array(k.length);for(let ie=0;ie<k.length;ie++)X[ie]=this.get(k[ie],!1);for(const ie of await Promise.all(X))if(ie===null)return!1;return!0}blankNode(d){return he(d)}get(d,k=!0){const X=this.cache.get(d);if(X)return X;let ie=this.unflushed.get(d);if(this.flushing!==null&&ie===void 0&&(ie=this.flushing.get(d)),this.truncated&&ie!==void 0&&ie.index>=2*this.truncateTo&&(ie=he(d)),ie!==void 0){if(ie.hash===m){if(k)throw s("Could not load node: "+d);return Promise.resolve(null)}return Promise.resolve(ie)}return se(this.storage,d,this.cache,k)}async flush(){this.flushing=this.unflushed,this.unflushed=new Map;try{this.truncated&&await this._flushTruncation(),await this._flushNodes()}catch(d){for(const k of this.flushing.values())this.unflushed.has(k.index)||this.unflushed.set(k.index,k);throw d}finally{this.flushing=null}}_flushTruncation(){return new Promise((d,k)=>{const X=this.truncateTo,ie=X===0?0:(X-1)*80+40;this.storage.truncate(ie,I=>{if(I)return k(I);this.truncateTo===X&&(this.truncateTo=0,this.truncated=!1),d()})})}_flushNodes(){return new Promise((d,k)=>{const X=g.allocUnsafe(40*this.flushing.size);let ie=null,I=this.flushing.size+1,L=0;for(const te of this.flushing.values()){const de={start:0,end:40,buffer:X.subarray(L,L+=40)};p.uint64.encode(de,te.size),p.raw.encode(de,te.hash),this.storage.write(te.index*40,de.buffer,V)}V(null);function V(te){te&&(ie=te),!(--I>0)&&(ie?k(ie):d())}})}clear(){return this.cache=new l({maxSize:this.cache.maxSize}),this.truncated=!0,this.truncateTo=0,this.roots=[],this.length=0,this.byteLength=0,this.fork=0,this.signature=null,this.flushing!==null&&this.flushing.clear(),this.unflushed.clear(),this.flush()}close(){return new Promise((d,k)=>{this.storage.close(X=>{X?k(X):d()})})}async truncate(d,k=this.fork){const X=d*2,ie=new B(this),I=n.fullRoots(X);for(let L=0;L<I.length;L++){const V=I[L];if(!(L<ie.roots.length&&ie.roots[L].index===V)){for(;ie.roots.length>L;)ie.roots.pop();ie.roots.push(ce(await this.get(V)))}}for(;ie.roots.length>I.length;)ie.roots.pop();return ie.fork=k,ie.length=d,ie.ancestors=d,ie.byteLength=ue(ie.roots),ie.upgraded=!0,ie}async reorg(d){const k=new M(this);let X=null;if((d.block||d.hash||d.seek)&&(X=w(d,this.crypto,k.nodes)),!R(d,X,k))throw o("Fork proof not verifiable");for(const ie of k.roots){const I=await this.get(ie.index,!1);if(!(I&&g.equals(I.hash,ie.hash))){k._updateDiffRoot(ie);break}}return k.diff!==null?await k._update(k.nodes):(k.want=null,k.ancestors=k.length),k}verifyFullyRemote(d){const k=new B(this);k.fork=d.fork,k.roots=[],k.length=0,k.ancestors=0,k.byteLength=0;let X=w(d,this.crypto,k.nodes);return d.upgrade&&R(d,X,k)&&(X=null),k}async verify(d){const k=new B(this);let X=w(d,this.crypto,k.nodes);if(d.upgrade&&R(d,X,k)&&(X=null),X){const ie=await this.get(X.index);if(!g.equals(ie.hash,X.hash))throw c("Invalid checksum at node "+X.index)}return k}proof({block:d,hash:k,seek:X,upgrade:ie}){return D(this,d,k,X,ie)}async missingNodes(d){const k=2*this.length,X=n.iterator(d);if(X.index+X.factor/2-1>=k)return 0;let I=0;for(;!X.contains(k)&&await this.get(X.index,!1)===null;)I++,X.parent();return I}async nodes(d){const k=2*this.length,X=n.iterator(d);let ie=0;for(;!X.contains(k)&&await this.get(X.index,!1)===null;)ie++,X.parent();return ie}byteRange(d){return j(this,d)}byteOffset(d){return v(this,d)}static async open(d,k={}){await new Promise((I,L)=>{d.read(0,E.length,(V,te)=>{if(V)return I();if(g.equals(te,E))return L(new Error("Storage contains an incompatible merkle tree"));I()})});const X=typeof k.length=="number"?k.length:await re(d),ie=[];for(const I of n.fullRoots(2*X))ie.push(ce(await se(d,I,null,!0)));return new m0(d,ie,k.fork||0,k.signature||null,k.prologue||null)}};async function j(J,d){const k=2*J.length;if(((d&1)===0?d:n.rightSpan(d))>=k)throw u("Index is out of bounds");return[await J.byteOffset(d),(await J.get(d)).size]}async function v(J,d){if(d===2*J.length)return J.byteLength;(d&1)===1&&(d=n.leftSpan(d));let k=0,X=0;for(const ie of J.roots){if(k+=2*(ie.index-k+1),d>=k){X+=ie.size;continue}const I=n.iterator(ie.index);for(;I.index!==d;)d<I.index?I.leftChild():(X+=(await J.get(I.leftChild())).size,I.sibling());return X}throw f("Failed to find offset")}function w({block:J,hash:d,seek:k},X,ie){const I=J?{index:2*J.index,value:J.value,nodes:J.nodes}:d?{index:d.index,value:null,nodes:d.nodes}:null;if(I===null&&(!k||!k.nodes.length))return null;let L=null;if(k&&k.nodes.length){const C=n.iterator(k.nodes[0].index),ee=new _(k.nodes);for(L=ee.shift(C.index),ie.push(L);ee.length>0;){const fe=ee.shift(C.sibling());L=Z(X,C.parent(),L,fe),ie.push(fe),ie.push(L)}}if(I===null)return L;const V=n.iterator(I.index),te=I.value&&P(X,V.index,I.value),de=new _(I.nodes,L);for(L=te||de.shift(V.index),ie.push(L);de.length>0;){const C=de.shift(V.sibling());L=Z(X,V.parent(),L,C),ie.push(C),ie.push(L)}return L}function R({fork:J,upgrade:d},k,X){const ie=X.tree.prologue;if(ie){const{start:ee,length:fe}=d;if(ee<ie.length&&(ee!==0||fe<ie.length))throw o("Upgrade does not satisfy prologue")}const I=new _(d.nodes,k);let L=X.roots.length>0,V=0;const te=2*(d.start+d.length),de=n.iterator(0);for(;de.fullRoot(te);de.nextTree()){if(V<X.roots.length&&X.roots[V].index===de.index){V++;continue}if(L){L=!1;const ee=de.index;if(V<X.roots.length){for(de.seek(X.roots[X.roots.length-1].index);de.index!==ee;)X.appendRoot(I.shift(de.sibling()),de);continue}}X.appendRoot(I.shift(de.index),de)}if(ie&&X.length===ie.length&&!g.equals(ie.hash,X.hash()))throw o("Invalid hash");const C=d.additionalNodes;for(de.seek(X.roots[X.roots.length-1].index),V=0;V<C.length&&C[V].index===de.sibling();)X.appendRoot(C[V++],de);for(;V<C.length;){const ee=C[V++];for(;ee.index!==de.index;){if(de.factor===2)throw s("Unexpected node: "+ee.index);de.leftChild()}X.appendRoot(ee,de),de.sibling()}return X.signature=y(d.signature),X.fork=J,I.extra===null}async function A(J,d,k,X){const ie=n.fullRoots(d);for(let I=0;I<ie.length;I++){const L=ie[I],V=await J.get(L),te=H(V,X,null);if(k===te)return L;if(k>te){k-=te;continue}return q(J,L,k,X)}return d}async function q(J,d,k,X){if(!k)return d;const ie=n.iterator(d);for(;(ie.index&1)!==0;){const I=await J.get(ie.leftChild(),!1);if(I){const L=H(I,X,ie);if(L===k)return ie.index;if(L>k)continue;k-=L,ie.sibling()}else return ie.parent(),ie.index}return ie.index}async function U(J,d,k,X){const ie=await J.byteOffset(d)-(X?X*n.leftSpan(d)/2:0);if(ie>k)throw s("Invalid seek");if(ie===k)return d;k-=ie;const I=await J.get(d);if(H(I,X,null)<=k)throw s("Invalid seek");return q(J,d,k,X)}function T(J,d,k,X){const ie=n.iterator(d);for(X.seek=[],X.seek.push(J.get(ie.index));ie.index!==k;)ie.sibling(),X.seek.push(J.get(ie.index)),ie.parent()}function Q(J,d,k,X,ie,I){if(!d)return T(J,X,ie,I);const L=n.iterator(d.index);for(I.node=[],d.value||I.node.push(J.get(L.index));L.index!==ie;)L.sibling(),k&&L.contains(X)&&L.index!==X?T(J,X,L.index,I):I.node.push(J.get(L.index)),L.parent()}function le(J,d,k,X,ie,I,L){X===0&&(L.upgrade=[]);for(const V=n.iterator(0);V.fullRoot(ie);V.nextTree())if(!(V.index+V.factor/2<X)){if(L.upgrade===null&&V.contains(X-2)){L.upgrade=[];const te=V.index,de=X-2;for(V.seek(de);V.index!==te;)V.sibling(),V.index>de&&(L.node===null&&L.seek===null&&V.contains(I)?Q(J,d,k,I,V.index,L):L.upgrade.push(J.get(V.index))),V.parent();continue}if(L.upgrade===null&&(L.upgrade=[]),L.node===null&&L.seek===null&&V.contains(I)){Q(J,d,k,I,V.index,L);continue}L.upgrade.push(J.get(V.index))}}function Y(J,d,k,X){d===0&&(X.additionalUpgrade=[]);for(const ie=n.iterator(0);ie.fullRoot(k);ie.nextTree())if(!(ie.index+ie.factor/2<d)){if(X.additionalUpgrade===null&&ie.contains(d-2)){X.additionalUpgrade=[];const I=ie.index,L=d-2;for(ie.seek(L);ie.index!==I;)ie.sibling(),ie.index>L&&X.additionalUpgrade.push(J.get(ie.index)),ie.parent();continue}X.additionalUpgrade===null&&(X.additionalUpgrade=[]),X.additionalUpgrade.push(J.get(ie.index))}}function oe(J,d,k){const X=n.iterator(J);for(let ie=0;ie<d;ie++)if(X.parent(),X.contains(k))throw u("Nodes is out of bounds");return X.index}function ue(J){let d=0;for(const k of J)d+=k.size;return d}function O(J){let d=0;for(const k of J)d+=2*(k.index-d+1);return d}function P(J,d,k){return{index:d,size:k.byteLength,hash:J.data(k)}}function Z(J,d,k,X){return{index:d,size:k.size+X.size,hash:J.parent(k,X)}}function he(J){return{index:J,size:0,hash:m}}function se(J,d,k,X){return new Promise((ie,I)=>{J.read(40*d,40,(L,V)=>{if(L){if(X)return I(L);ie(null);return}const te=V.subarray(8),de=p.decode(p.uint64,V);if(de===0&&g.compare(te,m)===0){X?I(new Error("Could not load node: "+d)):ie(null);return}const C={index:d,size:de,hash:te};k!==null&&(C.hash=y(te),k.set(d,C)),ie(C)})})}function G(J){return new Promise(d=>{J.stat((k,X)=>{if(!X)return d(0);d((X.size-X.size%40)/40)})})}async function re(J){const d=await G(J);if(!d)return 0;const k=n.iterator(d-1);let X=d-1;for(;await se(J,k.parent(),null,!1);)X=k.index;return n.rightSpan(X)/2+1}function W(J,d){for(const k of J.values())k.index>=2*d&&J.delete(k.index)}function $(J){let d=1;for(;J>2;)J/=2,d++;return d}function S(J,d){return J?{value:!0,index:J.index*2,nodes:J.nodes,lastIndex:J.index}:d?{value:!1,index:d.index,nodes:d.nodes,lastIndex:n.rightSpan(d.index)/2}:null}async function N(J){const d=[J.node&&Promise.all(J.node),J.seek&&Promise.all(J.seek),J.upgrade&&Promise.all(J.upgrade),J.additionalUpgrade&&Promise.all(J.additionalUpgrade)];try{return await Promise.all(d)}catch(k){throw J.node&&await Promise.allSettled(J.node),J.seek&&await Promise.allSettled(J.seek),J.upgrade&&await Promise.allSettled(J.upgrade),J.additionalUpgrade&&await Promise.allSettled(J.additionalUpgrade),k}}async function D(J,d,k,X,ie){J.prologue&&ie&&(ie.start=ie.start<J.prologue.length?0:ie.start,ie.length=ie.start<J.prologue.length?J.prologue.length:ie.length);const I=J.fork,L=J.signature,V=2*J.length,te=ie?ie.start*2:0,de=ie?te+ie.length*2:V,C=S(d,k),ee={fork:I,block:null,hash:null,seek:null,upgrade:null,manifest:null};if(V===0)return ee;if(te>=de||de>V)throw s("Invalid upgrade");if(X&&ie&&C!==null&&C.index>=te)throw s("Cannot both do a seek and block/hash request when upgrading");let fe=V;const ve={node:null,seek:null,upgrade:null,additionalUpgrade:null};if(C!==null&&(!ie||C.lastIndex<ie.start)){fe=oe(C.index,C.nodes,de);const me=X?await U(J,fe,X.bytes,X.padding):V;Q(J,C,X,me,fe,ve)}else(C||X)&&ie&&(fe=X?await A(J,de,X.bytes,X.padding):C.index);ie&&(le(J,C,X,te,de,fe,ve),V>de&&Y(J,de,V,ve));const[we,F,ne,ye]=await N(ve);if(d){if(we===null)throw s("Invalid block request");ee.block={index:d.index,value:null,nodes:we}}else if(k){if(we===null)throw s("Invalid hash request");ee.hash={index:k.index,nodes:we}}return X&&F!==null&&(ee.seek={bytes:X.bytes,nodes:F}),ie&&(ee.upgrade={start:ie.start,length:ie.length,nodes:ne,additionalNodes:ye||[],signature:L}),ee}function H(J,d,k){return d===0?J.size:J.size-d*(k?k.countLeaves():n.countLeaves(J.index))}function _e(J){for(const d of J)ce(d);return J}function ce(J){return J===null||(J.hash=y(J.hash)),J}return tf}var nf,Fb;function vx(){if(Fb)return nf;Fb=1;const n=Ue(),{WRITE_FAILED:a}=Lt();return nf=class{constructor(l,g){this.storage=l,this.tree=g}async get(l,g){g||(g=this.tree);const[y,h]=await g.byteRange(2*l);return this._read(y,h)}async put(l,g,y){return this._write(y,g)}putBatch(l,g,y){return g.length===0?Promise.resolve():this.put(l,g.length===1?g[0]:n.concat(g),y)}clear(l=0,g=-1){return new Promise((y,h)=>{g===-1?this.storage.truncate(l,o):this.storage.del(l,g,o);function o(c){c?h(c):y()}})}close(){return new Promise((l,g)=>{this.storage.close(y=>{y?g(y):l()})})}_read(l,g){return new Promise((y,h)=>{this.storage.read(l,g,(o,c)=>{o?h(o):y(c)})})}_write(l,g){return new Promise((y,h)=>{this.storage.write(l,g,o=>{o?h(a(o.message)):y(l+g.byteLength)})})}},nf}var sf,Vb;function kx(){if(Vb)return sf;Vb=1;const n=ll(),a=Ue(),p=p0().quickbit,l=32768,g=l/8,y=g/4,h=2097152,o=h/8,c=o/4,s=1024,u=h/l,f=4;class m{constructor(M,z){this.dirty=!1,this.index=M,this.offset=M*g-z.offset,this.bitfield=null,this.segment=z,z.add(this)}get tree(){return this.segment.tree}get(M){return p.get(this.bitfield,M)}set(M,z){p.set(this.bitfield,M,z)&&this.tree.update(this.offset*8+M)}setRange(M,z,j){p.fill(this.bitfield,j,M,M+z);let v=Math.floor(M/128);const w=v+Math.ceil(z/128);for(;v<=w;)this.tree.update(this.offset*8+v++*128)}findFirst(M,z){return p.findFirst(this.bitfield,M,z)}findLast(M,z){return p.findLast(this.bitfield,M,z)}count(M,z,j){const v=M+z;let w=M,R=0;for(;z>0;){const A=this.findFirst(j,w);if(A===-1||A>=v)return R;const q=this.findFirst(!j,A+1);if(q===-1||q>=v)return R+v-A;R+=q-A,z-=q-w,w=q}return R}}class E{constructor(M,z){this.index=M,this.offset=M*o,this.tree=p.Index.from(z,o),this.pages=new Array(u)}get bitfield(){return this.tree.field}add(M){const z=M.index-this.index*u;this.pages[z]=M;const j=z*y,v=j+y;v>=this.bitfield.length&&this.reallocate(v),M.bitfield=this.bitfield.subarray(j,v)}reallocate(M){let z=this.bitfield.length;for(;z<M;)z*=f;const j=new Uint32Array(z);j.set(this.bitfield),this.tree=p.Index.from(j,o);for(let v=0;v<this.pages.length;v++){const w=this.pages[v];if(!w)continue;const R=v*y,A=R+y;w.bitfield=j.subarray(R,A)}}findFirst(M,z){z=this.tree.skipFirst(!M,z);let j=z&l-1,v=(z-j)/l;if(v>=u)return-1;for(;v<this.pages.length;){const w=this.pages[v];let R=-1;if(w?R=w.findFirst(M,j):M||(R=j),R!==-1)return v*l+R;j=0,v++}return-1}findLast(M,z){z=this.tree.skipLast(!M,z);let j=z&l-1,v=(z-j)/l;if(v>=u)return-1;for(;v>=0;){const w=this.pages[v];let R=-1;if(w?R=w.findLast(M,j):M||(R=j),R!==-1)return v*l+R;j=l-1,v--}return-1}}sf=class il{constructor(M,z){this.unflushed=[],this.storage=M,this.resumed=!!(z&&z.byteLength>=4),this._pages=new n,this._segments=new n;const j=this.resumed?new Uint32Array(z.buffer,z.byteOffset,Math.floor(z.byteLength/4)):new Uint32Array(s);for(let v=0;v<j.length;v+=c){let w=j.subarray(v,v+c),R=c;if(v===0)for(R=s;R<w.length;)R*=f;if(w.length!==R){const q=new Uint32Array(R);q.set(w,0),w=q}const A=new E(v/c,w);this._segments.set(A.index,A);for(let q=0;q<w.length;q+=y){const U=new m((v+q)/y,A);this._pages.set(U.index,U)}}}toBuffer(M){const z=Math.ceil(M/l),j=a.allocUnsafe(z*g);for(let v=0;v<z;v++){const w=this._pages.get(v),R=v*g;if(w){const A=a.from(w.bitfield.buffer,w.bitfield.byteOffset,w.bitfield.byteLength);j.set(A,R)}else j.fill(0,R,R+g)}return j}getBitfield(M){const z=M&l-1,j=(M-z)/l;return this._pages.get(j)||null}get(M){const z=M&l-1,j=(M-z)/l,v=this._pages.get(j);return v?v.get(z):!1}set(M,z){const j=M&l-1,v=(M-j)/l;let w=this._pages.get(v);if(!w&&z){const R=Math.floor(v/u),A=this._segments.get(R)||this._segments.set(R,new E(R,new Uint32Array(R===0?s:c)));w=this._pages.set(v,new m(v,A))}w&&(w.set(j,z),w.dirty||(w.dirty=!0,this.unflushed.push(w)))}setRange(M,z,j){let v=M&l-1,w=(M-v)/l;for(;z>0;){let R=this._pages.get(w);if(!R&&j){const U=Math.floor(w/u),T=this._segments.get(U)||this._segments.set(U,new E(U,new Uint32Array(U===0?s:c)));R=this._pages.set(w,new m(w,T))}const q=Math.min(v+z,l)-v;R&&(R.setRange(v,q,j),R.dirty||(R.dirty=!0,this.unflushed.push(R))),v=0,w++,z-=q}}findFirst(M,z){let j=z&h-1,v=(z-j)/h;for(;v<this._segments.maxLength;){const w=this._segments.get(v);let R=-1;if(w?R=w.findFirst(M,j):M||(R=j),R!==-1)return v*h+R;j=0,v++}return M?-1:this._segments.maxLength*h}firstSet(M){return this.findFirst(!0,M)}firstUnset(M){return this.findFirst(!1,M)}findLast(M,z){let j=z&h-1,v=(z-j)/h;for(;v>=0;){const w=this._segments.get(v);let R=-1;if(w?R=w.findLast(M,j):M||(R=j),R!==-1)return v*h+R;j=h-1,v--}return-1}lastSet(M){return this.findLast(!0,M)}lastUnset(M){return this.findLast(!1,M)}count(M,z,j){let v=M&l-1,w=(M-v)/l,R=0;for(;z>0;){const A=this._pages.get(w),U=Math.min(v+z,l)-v;A?R+=A.count(v,U,j):j||(R+=U),v=0,w++,z-=U}return R}countSet(M,z){return this.count(M,z,!0)}countUnset(M,z){return this.count(M,z,!1)}*want(M,z){const j=M&h-1;let v=(M-j)/h;for(;z>0;){const w=this._segments.get(v);if(w){const R=_(b(z/8,4096,o),4096);yield{start:v*h,bitfield:w.bitfield.subarray(0,R/4)}}v++,z-=h}}clear(){return new Promise((M,z)=>{this.storage.truncate(0,j=>{if(j)return z(j);this._pages=new n,this.unflushed=[],M()})})}close(){return new Promise((M,z)=>{this.storage.close(j=>{j?z(j):M()})})}flush(){return new Promise((M,z)=>{if(!this.unflushed.length)return M();const j=this;let v=this.unflushed.length,w=null;for(const A of this.unflushed){const q=a.from(A.bitfield.buffer,A.bitfield.byteOffset,A.bitfield.byteLength);A.dirty=!1,this.storage.write(A.index*g,q,R)}function R(A){if(A&&(w=A),!--v){if(w)return z(w);j.unflushed=[],M()}}})}static open(M,z=null){return new Promise((j,v)=>{M.stat((w,R)=>{if(w)return j(new il(M,null));let A=R.size-(R.size&3);if(!A)return j(new il(M,null));z&&(A=Math.min(A,_(z.length/8,4096))),M.read(0,A,(q,U)=>{if(q)return v(q);j(new il(M,U))})})})}};function b(B,M,z){return Math.min(Math.max(B,M),z)}function _(B,M=1){const z=B%M;return z===0?B:B+M-z}return sf}var rf,jb;function w0(){return jb||(jb=1,rf=class Js{constructor(a={}){this.key=a.key,this.discoveryKey=a.discoveryKey,this.length=a.length||0,this.contiguousLength=a.contiguousLength||0,this.byteLength=a.byteLength||0,this.fork=a.fork||0,this.padding=a.padding||0,this.storage=a.storage||null}static async from(a,p={}){return new Js({key:a.key,discoveryKey:a.discoveryKey,length:a.length,contiguousLength:a.contiguousLength,byteLength:a.byteLength,fork:a.fork,padding:a.padding,storage:p.storage?await this.storage(a):null})}static async storage(a){const{oplog:p,tree:l,blocks:g,bitfield:y}=a.core;try{return{oplog:await Js.bytesUsed(p.storage),tree:await Js.bytesUsed(l.storage),blocks:await Js.bytesUsed(g.storage),bitfield:await Js.bytesUsed(y.storage)}}catch{return null}}static bytesUsed(a){return new Promise((p,l)=>{a.stat((g,y)=>{g?p(0):typeof y.blocks!="number"?l(new Error("cannot determine bytes used")):p(y.blocks*512)})})}}),rf}var of,Gb;function Sx(){if(Gb)return of;Gb=1;const n=et(),a=Ue(),p=rn(),{multiSignature:l,multiSignaturev0:g}=bo();of={assemblev0:f,assemble:m,inflatev0:y,inflate:h,partialSignature:o,signableLength:s};function y(B){return n.decode(g,B)}function h(B){return n.decode(l,B)}async function o(B,M,z,j=B.length,v=B.signature){if(z>B.length)return null;const w=j<=z?null:await c(B,z,j);return v.byteLength!==64&&(v=n.decode(l,v).proofs[0].signature),{signer:M,signature:v,patch:w?j-z:0,nodes:w}}async function c(B,M,z){return(await B.proof({upgrade:{start:M,length:z-M}})).upgrade.nodes}function s(B,M){return M<=0&&(M=1),M>B.length?0:B.sort(u)[M-1]}function u(B,M){return M-B}function f(B){const M=[],z=[];for(const j of B)M.push(b(j,z));return n.encode(g,{proofs:M,patch:z})}function m(B){const M=[],z=[],j=new Set;for(const v of B){if(v.nodes)for(const w of v.nodes)j.has(w.index)||(j.add(w.index),z.push(w));M.push({signer:v.signer,signature:v.signature,patch:v.patch})}return n.encode(l,{proofs:M,patch:z})}function E(B,M){return B.index!==M.index||B.size!==M.size?!1:a.equals(B.hash,M.hash)}function b(B,M){return{signer:B.signer,signature:B.signature,patch:B.patch?_(B,M):null}}function _(B,M){const z={start:p.rightSpan(B.nodes[B.nodes.length-1].index)/2+1,length:B.patch,nodes:[]};for(const j of B.nodes){let v=!1;for(let w=0;w<M.length;w++)if(E(M[w],j)){z.nodes.push(w),v=!0;break}v||z.nodes.push(M.push(j)-1)}return z}return of}var af,Yb;function v0(){if(Yb)return af;Yb=1;const n=_t(),a=Ue(),p=et(),l=rn(),{BAD_ARGUMENT:g}=Lt(),y=Xt(),h=bo(),o=Sx(),c=wo();class s{constructor(v,w,R,A,{signature:q="ed25519",publicKey:U,namespace:T=c.DEFAULT_NAMESPACE}={}){if(!U)throw g("public key is required for a signer");if(q!=="ed25519")throw g("Only Ed25519 signatures are supported");this.crypto=v,this.manifestHash=w,this.version=R,this.signer=A,this.signature=q,this.publicKey=U,this.namespace=T}_ctx(){return this.version===0?this.namespace:this.manifestHash}verify(v,w){return this.crypto.verify(v.signable(this._ctx()),w,this.publicKey)}sign(v,w){return this.crypto.sign(v.signable(this._ctx()),w.secretKey)}}class u extends s{constructor(v,w,R,A){super(v,null,0,w,R),this.legacy=A}verify(v,w){return this.crypto.verify(v.signableCompat(this.legacy),w,this.publicKey)}sign(v,w){return this.crypto.sign(v.signableCompat(this.legacy),w.secretKey)}}af=class b0{constructor(v,w,{compat:R=m(v,w),crypto:A=n,legacy:q=!1}={}){const U=this;this.manifestHash=v,this.compat=R||w===null,this.version=this.compat?0:typeof w.version=="number"?w.version:1,this.hash=w.hash||"blake2b",this.allowPatch=!this.compat&&!!w.allowPatch,this.quorum=this.compat?1:E(w),this.signers=w.signers?w.signers.map(T):[],this.prologue=this.compat?null:w.prologue||null;function T(Q,le){return U.compat?new u(A,le,Q,q):new s(A,v,U.version,le,Q)}}_verifyCompat(v,w){return w?this.compat||!this.allowPatch&&this.signers.length===1?!!w&&this.signers[0].verify(v,w):this._verifyMulti(v,w):!1}_inflate(v){if(this.version>=1)return o.inflate(v);const{proofs:w,patch:R}=o.inflatev0(v);return{proofs:w.map(z),patch:R}}_verifyMulti(v,w){if(!w||this.quorum===0)return!1;const{proofs:R,patch:A}=this._inflate(w);if(R.length<this.quorum)return!1;const q=new Uint8Array(this.signers.length),U=this.allowPatch&&A.length?f(A):null;for(let T=0;T<this.quorum;T++){const Q=R[T];let le=v;if(Q.patch&&this.allowPatch){le=v.clone();const oe=b(U,v.length,Q.patch),ue={fork:le.fork,block:null,hash:null,seek:null,upgrade:oe,manifest:null};try{if(!le.verifyUpgrade(ue))return!1}catch{return!1}}if(Q.signer>=this.signers.length||q[Q.signer]||(q[Q.signer]=1,!this.signers[Q.signer].verify(le,Q.signature)))return!1}return!0}verify(v,w){return this.version!==1?this._verifyCompat(v,w):this.prologue!==null&&v.length<=this.prologue.length?v.length===this.prologue.length&&a.equals(v.hash(),this.prologue.hash):this._verifyMulti(v,w)}sign(v,w){if(!w||!w.secretKey)throw g("No key pair was passed");for(const R of this.signers)if(a.equals(R.publicKey,w.publicKey)){const A=R.sign(v,w);return this.signers.length!==1||this.version===0?A:this.assemble([{signer:0,signature:A,patch:0,nodes:null}])}throw g("Public key is not a declared signer")}assemble(v){return this.version===0?o.assemblev0(v):o.assemble(v)}static manifestHash(v){return M(v)}static defaultSignerManifest(v){return{version:1,hash:"blake2b",allowPatch:!1,quorum:1,signers:[{signature:"ed25519",namespace:c.DEFAULT_NAMESPACE,publicKey:v}],prologue:null}}static fromManifest(v,w){const R=this.createManifest(v);return new this(M(R),R,w)}static createManifest(v){if(!v)return null;const w={version:typeof v.version=="number"?v.version:1,hash:"blake2b",allowPatch:!!v.allowPatch,quorum:E(v),signers:v.signers?v.signers.map(_):[],prologue:null};if(v.hash&&v.hash!=="blake2b")throw g("Only Blake2b hashes are supported");if(v.prologue){if(!(a.isBuffer(v.prologue.hash)&&v.prologue.hash.byteLength===32)||!(v.prologue.length>=0))throw g("Invalid prologue");w.prologue=v.prologue,w.prologue.hash=y(w.prologue.hash)}return w}static isValidManifest(v,w){return a.equals(v,M(w))}static isCompat(v,w){return m(v,w)}static sign(v,w,R,A){return b0.fromManifest(v,A).sign(w,R)}};function f(j){const v=new Map;for(const w of j)v.set(w.index,w);return v}function m(j,v){return!!(v&&v.signers.length===1&&a.equals(j,v.signers[0].publicKey))}function E(j){return typeof j.quorum=="number"?j.quorum:!j.signers||!j.signers.length?0:(j.signers.length>>1)+1}function b(j,v,w){const R={start:v,length:w,nodes:null,additionalNodes:[],signature:null},A=v*2,q=A+w*2;for(const U=l.iterator(0);U.fullRoot(q);U.nextTree())if(!(U.index+U.factor/2<A)){if(R.nodes===null&&U.contains(A-2)){R.nodes=[];const T=U.index,Q=A-2;for(U.seek(Q);U.index!==T;)U.sibling(),U.index>Q&&R.nodes.push(j.get(U.index)),U.parent();continue}R.nodes===null&&(R.nodes=[]),R.nodes.push(j.get(U.index))}return R.nodes===null&&(R.nodes=[]),R}function _(j){return B(j),{signature:"ed25519",namespace:y(j.namespace||c.DEFAULT_NAMESPACE),publicKey:y(j.publicKey)}}function B(j){if(!j||!j.publicKey)throw g("Signer missing public key");if(j.signature&&j.signature!=="ed25519")throw g("Only Ed25519 signatures are supported")}function M(j){const v={start:0,end:32,buffer:null};return h.manifest.preencode(v,j),v.buffer=a.allocUnsafe(v.end),p.raw.encode(v,c.MANIFEST),h.manifest.encode(v,j),n.hash(v.buffer)}function z(j){return{signer:j.signer,signature:j.signature,patch:j.patch?j.patch.length:0}}return af}var lf,Wb;function xx(){if(Wb)return lf;Wb=1;const n=_t(),a=rn(),p=et(),l=Ue(),g=l.alloc(32);lf=async function(o){const c={tree:0,blocks:0},s=o.header.tree.length,u=await y(o.blocks.storage),f=await y(o.tree.storage),m=new Uint8Array(Math.ceil(f.byteLength/40)),E=[];for(const z of o.tree.roots)m[z.index]=1,E.push(z);for(;E.length>0;){const z=E.pop();if((z.index&1)===0)continue;const[j,v]=a.children(z.index),w=B(j),R=B(v);if(!(!R&&!w)){if(E.push(w,R),m[z.index]){const A=n.parent(w,R);if(l.equals(A,z.hash)&&z.size===w.size+R.size){m[w.index]=1,m[R.index]=1;continue}}w.size&&M(w),R.size&&M(R)}}c.tree&&o.tree.cache.clear();let b=0,_=-1;for(;b<s;){if(!o.bitfield.get(b)){if(b+1===s||(b=o.bitfield.findFirst(!0,b+1),b<0))break;_=-1;continue}if(_===-1)try{_=await o.tree.byteOffset(b*2)}catch{o._setBitfield(b,!1),c.blocks++,b++;continue}const j=B(b*2),v=u.subarray(_,_+j.size),w=n.data(v);_+=v.byteLength,l.equals(w,j.hash)||(o._setBitfield(b,!1),c.blocks++),b++}return c;function B(z){if(z*40+40>f.byteLength)return null;const j={start:z*40,end:z*40+40,buffer:f},v=p.uint64.decode(j),w=p.fixed32.decode(j);return v===0&&w.equals(g)?null:{index:z,size:v,hash:w}}function M(z){m[z.index]=0,z.size&&(l.fill(f,0,z.index*40,z.index*40+40),o.tree.unflushed.set(z.index,o.tree.blankNode(z.index)),c.tree++)}};function y(h){return new Promise((o,c)=>{h.stat((s,u)=>{if(!u)return o(l.alloc(0));h.read(0,u.size,(f,m)=>{f?c(f):o(m)})})})}return lf}var cf,Qb;function Ex(){if(Qb)return cf;Qb=1;const n=_t(),a=Ue(),p=Xt(),l=_x(),g=mx(),y=wx(),h=bx(),o=vx(),c=kx(),s=y0(),u=w0(),{BAD_ARGUMENT:f,STORAGE_EMPTY:m,STORAGE_CONFLICT:E,INVALID_OPERATION:b,INVALID_SIGNATURE:_,INVALID_CHECKSUM:B}=Lt(),M=bo(),z=v0(),j=xx();cf=class{constructor(Y,oe,ue,O,P,Z,he,se,G,re,W,$,S,N){this.onupdate=S,this.onconflict=N,this.preupdate=null,this.header=Y,this.compat=oe,this.crypto=ue,this.oplog=O,this.bigHeader=P,this.tree=Z,this.blocks=he,this.bitfield=se,this.verifier=G,this.truncating=0,this.updating=!1,this.closed=!1,this.skipBitfield=null,this.active=re.length,this.sessions=re,this.globalCache=$,this._manifestFlushed=!!Y.manifest,this._maxOplogSize=65536,this._autoFlush=1,this._verifies=null,this._verifiesFlushed=null,this._mutex=new y,this._legacy=W}static async open(Y,oe={}){const ue=Y("oplog"),O=Y("tree"),P=Y("bitfield"),Z=Y("data"),he=Y("header");try{return await this.resume(ue,O,P,Z,he,oe)}catch(se){throw await A(ue,O,P,Z,he),se}}static async resume(Y,oe,ue,O,P,Z){let he=Z.overwrite===!0;const se=Z.force===!0,G=Z.createIfMissing!==!1,re=Z.crypto||n,W=!!Z.legacy,$=new l(Y,{headerEncoding:M.oplog.header,entryEncoding:M.oplog.entry,readonly:Z.readonly});let S=Z.compat===!0||Z.compat!==!1&&!Z.manifest,{header:N,entries:D}=await $.open();se&&Z.key&&N&&!a.equals(N.key,Z.key)&&(he=!0);const H=new g(P);if(!N||he){if(!G)throw m("No Hypercore is stored here");if(S&&Z.key&&Z.keyPair&&!a.equals(Z.key,Z.keyPair.publicKey))throw f("Key must match publicKey when in compat mode");const X=Z.keyPair||(Z.key?null:re.keyPair()),I=!Z.manifest&&(!!Z.compat||!Z.key||!!(X&&a.equals(Z.key,X.publicKey)))?z.defaultSignerManifest(Z.key||X.publicKey):z.createManifest(Z.manifest);N={external:null,key:Z.key||(S?I.signers[0].publicKey:z.manifestHash(I)),manifest:I,keyPair:X?{publicKey:X.publicKey,secretKey:X.secretKey||null}:null,userData:[],tree:{fork:0,length:0,rootHash:null,signature:null},hints:{reorgs:[],contiguousLength:0}},await q($,H,N)}else N.external&&(N=await H.load(N.external));if(N.key=p(N.key),N.tree.rootHash=p(N.tree.rootHash),N.tree.signature=p(N.tree.signature),N.keyPair&&(N.keyPair.publicKey=p(N.keyPair.publicKey),N.keyPair.secretKey=p(N.keyPair.secretKey)),Z.manifest){if(!Z.key&&!z.isValidManifest(N.key,z.createManifest(Z.manifest)))throw E("Manifest does not hash to provided key");N.manifest||(N.manifest=Z.manifest)}if(Z.key&&!a.equals(N.key,Z.key))throw E("Another Hypercore is stored here");S&&N.manifest&&!z.isCompat(N.key,N.manifest)?S=!1:!S&&N.manifest&&z.isCompat(N.key,N.manifest)&&(S=!0);const _e=N.manifest?N.manifest.prologue:null,ce=await h.open(oe,{crypto:re,prologue:_e,...N.tree}),J=await c.open(ue),d=new o(O,ce);if(he&&(await ce.clear(),await d.clear(),await J.clear(),D=[]),N.hints.contiguousLength===0)for(;J.get(N.hints.contiguousLength);)N.hints.contiguousLength++;N.manifest&&(N.manifest=z.createManifest(N.manifest));const k=N.manifest?new z(N.key,N.manifest,{crypto:re,legacy:W}):null;for(const X of D){if(X.userData&&R(N.userData,X.userData.key,X.userData.value),X.treeNodes)for(const ie of X.treeNodes)ce.addNode(ie);if(X.bitfield&&(J.setRange(X.bitfield.start,X.bitfield.length,!X.bitfield.drop),v(N,X.bitfield,J)),X.treeUpgrade){const ie=await ce.truncate(X.treeUpgrade.length,X.treeUpgrade.fork);ie.ancestors=X.treeUpgrade.ancestors,ie.signature=p(X.treeUpgrade.signature),w(N.hints.reorgs,ce,ie),ie.commit(),N.tree.length=ce.length,N.tree.fork=ce.fork,N.tree.rootHash=ce.hash(),N.tree.signature=ce.signature}}for(const X of N.userData)X.value=p(X.value);return new this(N,S,re,$,H,ce,d,J,k,Z.sessions||[],W,Z.globalCache||null,Z.onupdate||U,Z.onconflict||U)}async audit(){await this._mutex.lock();try{await this._flushOplog();const Y=await j(this);return(Y.blocks||Y.tree)&&await this._flushOplog(),Y}finally{await this._mutex.unlock()}}async setManifest(Y){await this._mutex.lock();try{if(Y&&this.header.manifest===null){if(!z.isValidManifest(this.header.key,Y))throw B("Manifest hash does not match");this._setManifest(z.createManifest(Y),null),await this._flushOplog()}}finally{this._mutex.unlock()}}_setManifest(Y,oe){if(!Y&&a.equals(oe.publicKey,this.header.key)&&(Y=z.defaultSignerManifest(this.header.key)),!Y)return;const ue=new z(this.header.key,Y,{crypto:this.crypto,legacy:this._legacy});ue.prologue&&this.tree.setPrologue(ue.prologue),this.header.manifest=Y,this.compat=ue.compat,this.verifier=ue,this._manifestFlushed=!1,this.onupdate(16,null,null,null)}_shouldFlush(){return--this._autoFlush<=0||this.oplog.byteLength>=this._maxOplogSize?(this._autoFlush=4,!0):!this._manifestFlushed&&this.header.manifest?(this._manifestFlushed=!0,!0):!1}async copyPrologue(Y,{additional:oe=[]}={}){await this._mutex.lock();try{await Y._mutex.lock()}catch(ue){throw this._mutex.unlock(),ue}try{const ue=this.header.manifest&&this.header.manifest.prologue;if(!ue)throw b("No prologue present");const O=ue.length-oe.length,P=O!==Y.tree.length?await Y.tree.truncate(O):Y.tree.batch(),Z=P.roots.slice(0),he=P.byteLength;for(const W of oe)P.append(W);if(!a.equals(P.hash(),ue.hash))throw b("Source tree is conflicting");const se={userData:null,treeNodes:Z,treeUpgrade:null,bitfield:null};oe.length&&(await this.blocks.putBatch(O,oe,he),se.treeNodes=se.treeNodes.concat(P.nodes),se.bitfield={drop:!1,start:O,length:oe.length}),await this.oplog.append([se],!1),this.tree.addNodes(se.treeNodes),this.header.tree.length<P.length&&(this.header.tree.length=P.length,this.header.tree.rootHash=P.hash(),this.tree.length=P.length,this.tree.byteLength=P.byteLength,this.tree.roots=P.roots,this.onupdate(1,null,null,null)),se.bitfield&&(this._setBitfieldRange(se.bitfield.start,se.bitfield.length,!0),this.onupdate(0,se.bitfield,null,null)),await this._flushOplog();let G=0;for(;G<O;){const W=T(G,Y.bitfield,this.bitfield);if(W>=O||W<0)break;G=Math.min(W+65536,O,Q(W,Y.bitfield,this.bitfield));const $=await Y.tree.getNeededNodes(O,W,G),S={drop:!1,start:W,length:G-W},N=[];for(let _e=W;_e<G;_e++){const ce=await Y.blocks.get(_e);N.push(ce)}const D=await Y.tree.byteOffset(2*W);await this.blocks.putBatch(W,N,D);const H={userData:null,treeNodes:$,treeUpgrade:null,bitfield:S};await this.oplog.append([H],!1),this.tree.addNodes($),this._setBitfieldRange(S.start,S.length,!0),this.onupdate(0,S,null,null),await this._flushOplog()}this.header.userData=Y.header.userData.slice(0);const re=Math.min(Y.header.hints.contiguousLength,P.length);this.header.hints.contiguousLength<re&&(this.header.hints.contiguousLength=re),await this._flushOplog()}finally{Y._mutex.unlock(),this._mutex.unlock()}}async flush(){await this._mutex.lock();try{this._manifestFlushed=!0,this._autoFlush=4,await this._flushOplog()}finally{this._mutex.unlock()}}async _flushOplog(){return await this.bitfield.flush(),await this.tree.flush(),q(this.oplog,this.bigHeader,this.header)}_appendBlocks(Y){return this.blocks.putBatch(this.tree.length,Y,this.tree.byteLength)}async _writeBlock(Y,oe,ue){const O=await Y.byteOffset(oe*2);await this.blocks.put(oe,ue,O)}async userData(Y,oe,ue){await this._mutex.lock();try{let O=!0;for(const Z of this.header.userData)if(Z.key===Y){if(oe&&a.equals(Z.value,oe))return;O=!1;break}if(O&&!oe)return;const P={userData:{key:Y,value:oe},treeNodes:null,treeUpgrade:null,bitfield:null};await this.oplog.append([P],!1),R(this.header.userData,Y,oe),(this._shouldFlush()||ue)&&await this._flushOplog()}finally{this._mutex.unlock()}}async truncate(Y,oe,{signature:ue,keyPair:O=this.header.keyPair}={}){if(this.tree.prologue&&Y<this.tree.prologue.length)throw b("Truncation breaks prologue");this.truncating++,await this._mutex.lock(),this.verifier===null&&O&&this._setManifest(null,O);try{const P=await this.tree.truncate(Y,oe);Y>0&&(P.signature=ue||this.verifier.sign(P,O)),await this._truncate(P,null)}finally{this.truncating--,this._mutex.unlock()}}async clearBatch(){await this._mutex.lock();try{const Y=this.bitfield.findFirst(!1,this.tree.length);if(Y<=this.tree.length)return;const oe=await this.tree.truncate(this.tree.length,this.tree.fork);oe.signature=this.tree.signature;const ue={userData:null,treeNodes:oe.nodes,treeUpgrade:oe,bitfield:{drop:!0,start:oe.ancestors,length:Y-oe.ancestors}};await this.oplog.append([ue],!1),this._setBitfieldRange(oe.ancestors,Y-oe.ancestors,!1),oe.commit(),await this._flushOplog()}finally{this._mutex.unlock()}}async clear(Y,oe,ue){await this._mutex.lock();try{const O={userData:null,treeNodes:null,treeUpgrade:null,bitfield:{start:Y,length:oe-Y,drop:!0}};if(await this.oplog.append([O],!1),this._setBitfieldRange(Y,oe-Y,!1),Y<this.header.hints.contiguousLength&&(this.header.hints.contiguousLength=Y),Y=this.bitfield.lastSet(Y)+1,oe=this.bitfield.firstSet(oe),oe===-1&&(oe=this.tree.length),Y>=oe||Y>=this.tree.length)return;const P=await this.tree.byteOffset(Y*2),he=await this.tree.byteOffset(oe*2)-P,se=ue?await u.bytesUsed(this.blocks.storage):null;await this.blocks.clear(P,he);const G=ue?await u.bytesUsed(this.blocks.storage):null;ue&&(ue.blocks=Math.max(se-G,0)),this.onupdate(0,O.bitfield,null,null),this._shouldFlush()&&await this._flushOplog()}finally{this._mutex.unlock()}}async purge(){return new Promise((Y,oe)=>{let ue=4,O=null;this.oplog.storage.unlink(P),this.tree.storage.unlink(P),this.bitfield.storage.unlink(P),this.blocks.storage.unlink(P);function P(Z){Z&&(O=Z),!--ue&&(O?oe(O):Y())}})}async insertBatch(Y,oe,{signature:ue,keyPair:O=this.header.keyPair,pending:P=!1,treeLength:Z=Y.treeLength}={}){await this._mutex.lock();try{if(this.verifier===null&&O&&this._setManifest(null,O),this.tree.fork!==Y.fork)return null;if(this.tree.length>Y.treeLength){if(this.tree.length>Y.length)return null;for(const W of this.tree.roots){const $=await Y.get(W.index);if($.size!==W.size||!a.equals($.hash,W.hash))return null}}const he=Y.length-Z;Y.upgraded=!P&&Y.length>this.tree.length,Y.treeLength=this.tree.length,Y.ancestors=this.tree.length,Y.upgraded&&!P&&(Y.signature=ue||this.verifier.sign(Y,O));let se=Y.byteLength;for(let W=0;W<he;W++)se-=oe[W].byteLength;P===!0&&(Y.upgraded=!1);const G={userData:null,treeNodes:Y.nodes,treeUpgrade:Y.upgraded?Y:null,bitfield:{drop:!1,start:Z,length:he}};await this.blocks.putBatch(Z,he<oe.length?oe.slice(0,he):oe,se),await this.oplog.append([G],!1),this._setBitfieldRange(G.bitfield.start,G.bitfield.length,!0),Y.commit(),Y.upgraded&&(this.header.tree.length=Y.length,this.header.tree.rootHash=Y.hash(),this.header.tree.signature=Y.signature);const re=(Y.upgraded?1:0)|v(this.header,G.bitfield,this.bitfield);P||(G.treeUpgrade&&Z>Y.treeLength&&(G.bitfield.start=Y.treeLength,G.bitfield.length=Z-Y.treeLength),this.onupdate(re,G.bitfield,null,null)),this._shouldFlush()&&await this._flushOplog()}finally{this._mutex.unlock()}return{length:Y.length,byteLength:Y.byteLength}}async append(Y,{signature:oe,keyPair:ue=this.header.keyPair,preappend:O}={}){await this._mutex.lock();try{if(this.verifier===null&&ue&&this._setManifest(null,ue),O&&await O(Y),!Y.length)return{length:this.tree.length,byteLength:this.tree.byteLength};const P=this.tree.batch();for(const G of Y)P.append(G);if(this.tree.prologue&&P.length<this.tree.prologue.length)throw b("Append is not consistent with prologue");P.signature=oe||this.verifier.sign(P,ue);const Z={userData:null,treeNodes:P.nodes,treeUpgrade:P,bitfield:{drop:!1,start:P.ancestors,length:Y.length}},he=await this._appendBlocks(Y);await this.oplog.append([Z],!1),this._setBitfieldRange(P.ancestors,P.length-P.ancestors,!0),P.commit(),this.header.tree.length=P.length,this.header.tree.rootHash=P.hash(),this.header.tree.signature=P.signature;const se=1|v(this.header,Z.bitfield,this.bitfield);return this.onupdate(se,Z.bitfield,null,null),this._shouldFlush()&&await this._flushOplog(),{length:P.length,byteLength:he}}finally{this._mutex.unlock()}}_verifyBatchUpgrade(Y,oe){if(!this.header.manifest&&(!oe&&this.compat&&(oe=z.defaultSignerManifest(this.header.key)),!oe||!(z.isValidManifest(this.header.key,oe)||this.compat&&z.isCompat(this.header.key,oe))))throw _("Proof contains an invalid manifest");oe=z.createManifest(oe);const ue=this.verifier||new z(this.header.key,oe,{crypto:this.crypto,legacy:this._legacy});if(!ue.verify(Y,Y.signature))throw _("Proof contains an invalid signature");this.header.manifest||(this.header.manifest=oe,this.compat=ue.compat,this.verifier=ue,this.onupdate(16,null,null,null))}async _verifyExclusive({batch:Y,bitfield:oe,value:ue,manifest:O,from:P}){this._verifyBatchUpgrade(Y,O),await this._mutex.lock();try{if(!Y.commitable())return!1;this.updating=!0;const Z={userData:null,treeNodes:Y.nodes,treeUpgrade:Y,bitfield:oe};this.preupdate!==null&&await this.preupdate(Y,this.header.key),oe&&await this._writeBlock(Y,oe.start,ue),await this.oplog.append([Z],!1);let he=1;oe&&(this._setBitfield(oe.start,!0),he|=v(this.header,oe,this.bitfield)),Y.commit(),this.header.tree.fork=Y.fork,this.header.tree.length=Y.length,this.header.tree.rootHash=Y.hash(),this.header.tree.signature=Y.signature,this.onupdate(he,oe,ue,P),this._shouldFlush()&&await this._flushOplog()}finally{this.updating=!1,this._mutex.unlock()}return!0}async _verifyShared(){if(!this._verifies.length)return!1;await this._mutex.lock();const Y=this._verifies;this._verifies=null,this._verified=null;try{const oe=[];for(const{batch:ue,bitfield:O,value:P}of Y)ue.commitable()&&(O&&await this._writeBlock(ue,O.start,P),oe.push({userData:null,treeNodes:ue.nodes,treeUpgrade:null,bitfield:O}));await this.oplog.append(oe,!1);for(let ue=0;ue<Y.length;ue++){const{batch:O,bitfield:P,value:Z,manifest:he,from:se}=Y[ue];if(!O.commitable()){Y[ue]=null;continue}let G=0;if(P&&(this._setBitfield(P.start,!0),G=v(this.header,P,this.bitfield)),he&&this.header.manifest===null){if(!z.isValidManifest(this.header.key,he))throw B("Manifest hash does not match");this._setManifest(he,null)}O.commit(),this.onupdate(G,P,Z,se)}this._shouldFlush()&&await this._flushOplog()}finally{this._mutex.unlock()}return Y[0]!==null}async checkConflict(Y,oe){if(this.tree.length<Y.upgrade.length||Y.fork!==this.tree.fork)return!1;const ue=this.tree.verifyFullyRemote(Y);try{this._verifyBatchUpgrade(ue,Y.manifest)}catch{return!0}const O=this.crypto.tree(Y.upgrade.nodes),P=this.crypto.tree(await this.tree.getRoots(Y.upgrade.length));return a.equals(P,O)?!1:(await this.onconflict(Y),!0)}async verifyReorg(Y){const oe=await this.tree.reorg(Y);return this._verifyBatchUpgrade(oe,Y.manifest),oe}async verify(Y,oe){if(Y.fork!==this.tree.fork)return!1;const ue=await this.tree.verify(Y);if(!ue.commitable())return!1;const O=Y.block&&Y.block.value||null,P={batch:ue,bitfield:O&&{drop:!1,start:Y.block.index,length:1},value:O,manifest:Y.manifest,from:oe};if(ue.upgraded)return this._verifyExclusive(P);if(this._verifies!==null){const Z=this._verifies,he=Z.push(P);return await this._verified,Z[he]!==null}return this._verifies=[P],this._verified=this._verifyShared(),this._verified}async reorg(Y,oe){if(!Y.commitable())return!1;this.truncating++,await this._mutex.lock();try{if(!Y.commitable())return!1;await this._truncate(Y,oe)}finally{this.truncating--,this._mutex.unlock()}return!0}async _truncate(Y,oe){const ue={userData:null,treeNodes:Y.nodes,treeUpgrade:Y,bitfield:{drop:!0,start:Y.ancestors,length:this.tree.length-Y.ancestors}};await this.oplog.append([ue],!1),this._setBitfieldRange(Y.ancestors,this.tree.length-Y.ancestors,!1),w(this.header.hints.reorgs,this.tree,Y),Y.commit();const O=v(this.header,ue.bitfield,this.bitfield),P=(Y.length>Y.ancestors?3:2)|O;this.header.tree.fork=Y.fork,this.header.tree.length=Y.length,this.header.tree.rootHash=Y.hash(),this.header.tree.signature=Y.signature,this.onupdate(P,ue.bitfield,null,oe),await this._flushOplog()}openSkipBitfield(){if(this.skipBitfield!==null)return this.skipBitfield;this.skipBitfield=new s;const Y=this.bitfield.toBuffer(this.tree.length),oe=new Uint32Array(Y.buffer,Y.byteOffset,Y.byteLength/4);return this.skipBitfield.insert(0,oe),this.skipBitfield}_setBitfield(Y,oe){this.bitfield.set(Y,oe),this.skipBitfield!==null&&this.skipBitfield.set(Y,oe)}_setBitfieldRange(Y,oe,ue){this.bitfield.setRange(Y,oe,ue),this.skipBitfield!==null&&this.skipBitfield.setRange(Y,oe,ue)}async close(){this.closed=!0,await this._mutex.destroy(),await Promise.allSettled([this.oplog.close(),this.bitfield.close(),this.tree.close(),this.blocks.close(),this.bigHeader.close()])}};function v(le,Y,oe){const ue=Y.start+Y.length;let O=le.hints.contiguousLength;if(Y.drop)O<=ue&&O>Y.start&&(O=Y.start);else if(O<=ue&&O>=Y.start)for(O=ue;oe.get(O);)O++;return O===le.hints.contiguousLength?0:O>le.hints.contiguousLength?(le.hints.contiguousLength=O,4):(le.hints.contiguousLength=O,8)}function w(le,Y,oe){if(!(Y.length===0||Y.fork===oe.fork)){for(;le.length>=4;)le.shift();for(;le.length>0&&le[le.length-1].ancestors>oe.ancestors;)le.pop();le.push({from:Y.fork,to:oe.fork,ancestors:oe.ancestors})}}function R(le,Y,oe){oe=p(oe);for(let ue=0;ue<le.length;ue++)if(le[ue].key===Y){oe?le[ue].value=oe:le.splice(ue,1);return}oe&&le.push({key:Y,value:oe})}function A(...le){let Y=1,oe=null;return new Promise((ue,O)=>{for(const Z of le)Y++,Z.close(P);P(null);function P(Z){Z&&(oe=Z),!--Y&&(oe?O(oe):ue())}})}async function q(le,Y,oe){oe.external&&await Y.flush(oe);try{await le.flush(oe)}catch(ue){if(ue.code!=="OPLOG_HEADER_OVERFLOW")throw ue;await Y.flush(oe),await le.flush(oe)}}function U(){}function T(le,Y,oe){for(;;){const ue=Y.firstSet(le),O=oe.firstUnset(le);if(ue===-1)return-1;if(O===-1)return ue;if(ue<O){le=O;continue}return ue}}function Q(le,Y,oe){const ue=Y.firstUnset(le),O=oe.firstSet(le);return ue===-1?-1:O===-1||ue<O?ue:O}return cf}var hf,Xb;function Ax(){if(Xb)return hf;Xb=1;const n=_0(),a=et(),p=Ue(),{BLOCK_ENCRYPTION:l}=wo(),g=p.alloc(n.crypto_stream_NONCEBYTES);return hf=class{constructor(h,o,{isBlockKey:c=!1,compat:s=!0}={}){const u=p.alloc(2*n.crypto_stream_KEYBYTES);this.key=h,this.blockKey=c?h:u.subarray(0,n.crypto_stream_KEYBYTES),this.blindingKey=u.subarray(n.crypto_stream_KEYBYTES),this.padding=8,this.compat=s,this.isBlockKey=c,c||(s?n.crypto_generichash_batch(this.blockKey,[h],o):n.crypto_generichash_batch(this.blockKey,[l,o,h])),n.crypto_generichash(this.blindingKey,this.blockKey)}encrypt(h,o,c){const s=o.subarray(0,this.padding);o=o.subarray(this.padding),a.uint64.encode({start:0,end:8,buffer:s},c),a.uint64.encode({start:0,end:8,buffer:g},h),g.fill(0,8,8+s.byteLength),n.crypto_stream_xor(s,s,g,this.blindingKey),g.set(s,8),n.crypto_stream_xor(o,o,g,this.blockKey)}decrypt(h,o){const c=o.subarray(0,this.padding);o=o.subarray(this.padding),a.uint64.encode({start:0,end:8,buffer:g},h),g.set(c,8),n.crypto_stream_xor(o,o,g,this.blockKey)}},hf}var uf,Zb;function Rx(){if(Zb)return uf;Zb=1,uf=class{constructor(p){this.req=p}async done(){return(await this.req).promise}downloaded(){return this.done()}destroy(){this.req.then(p=>p.context&&p.context.detach(p),n)}};function n(){}return uf}var df,$b;function Lx(){if($b)return df;$b=1;const{BLOCK_NOT_AVAILABLE:n,SESSION_CLOSED:a}=Lt(),p=nn,l=et(),g=Ue(),y=jt();return df=class extends p{constructor(o,c,s,u,f){super(),this.session=o,this.opened=!1,this.closed=!1,this.opening=null,this.closing=null,this.writable=!0,this.autoClose=s,this.restore=u,this.fork=0,this._appends=[],this._appendsActual=null,this._checkoutLength=c,this._byteLength=0,this._sessionLength=0,this._sessionByteLength=0,this._sessionBatch=null,this._cachedBatch=null,this._flushing=null,this._clear=f,this.opening=this._open(),this.opening.catch(y)}get id(){return this.session.id}get key(){return this.session.key}get discoveryKey(){return this.session.discoveryKey}get indexedLength(){return Math.min(this._sessionLength,this.session.core===null?0:this.session.core.tree.length)}get flushedLength(){return this._sessionLength}get indexedByteLength(){return this._sessionByteLength}get length(){return this._sessionLength+this._appends.length}get byteLength(){return this._sessionByteLength+this._byteLength}get core(){return this.session.core}get manifest(){return this.session.manifest}ready(){return this.opening}async _open(){if(await this.session.ready(),this._clear&&(this._checkoutLength=this.core.tree.length),this._checkoutLength!==-1){const o=await this.session.core.tree.restoreBatch(this._checkoutLength);o.treeLength=this._checkoutLength,this._sessionLength=o.length,this._sessionByteLength=o.byteLength,this._sessionBatch=o,this._clear&&await this.core.clearBatch()}else{const o=this.restore?this.session.core.bitfield.findFirst(!1,this.session.length):0;if(o>this.session.length){const c=await this.session.core.tree.restoreBatch(o);this._sessionLength=c.length,this._sessionByteLength=c.byteLength-this.session.padding*c.length,this._sessionBatch=c}else this._sessionLength=this.session.length,this._sessionByteLength=this.session.byteLength,this._sessionBatch=this.session.createTreeBatch()}this._appendsActual=this.session.encryption?[]:this._appends,this.fork=this.session.fork,this.opened=!0,this.emit("ready")}async has(o){return this.opened===!1&&await this.ready(),o>=this._sessionLength?o<this.length:this.session.has(o)}async update(o){this.opened===!1&&await this.ready(),await this.session.update(o)}treeHash(){return this._sessionBatch.hash()}setUserData(o,c,s){return this.session.setUserData(o,c,s)}getUserData(o,c){return this.session.getUserData(o,c)}async info(o){const s=await this.session.info(o);return s.length=this._sessionLength,s.contiguousLength>=s.length?s.contiguousLength=s.length+=this._appends.length:s.length+=this._appends.length,s.byteLength=this._sessionByteLength+this._byteLength,s}async seek(o,c={}){if(this.opened===!1&&await this.opening,this.closing)throw a();if(o<this._sessionByteLength)return await this.session.seek(o,{...c,tree:this._sessionBatch});o-=this._sessionByteLength;let s=0;for(const u of this._appends){if(o<u.byteLength)return[this._sessionLength+s,o];s++,o-=u.byteLength}if(o===0)return[this._sessionLength+s,0];throw n()}async get(o,c={}){if(this.opened===!1&&await this.opening,this.closing)throw a();const s=this._sessionLength;if(o<s)return this.session.get(o,{...c,tree:this._sessionBatch});if(c&&c.raw)return this._appendsActual[o-s]||null;const u=this._appends[o-s]||null;if(!u)throw n();const f=c&&c.valueEncoding&&l.from(c.valueEncoding)||this.session.valueEncoding;return f?l.decode(f,u):u}async _waitForFlush(){for(;this._flushing;)await this._flushing,await Promise.resolve()}async restoreBatch(o,c){return this.opened===!1&&await this.opening,o>=this._sessionLength?this.createTreeBatch(o,c):this.session.core.tree.restoreBatch(o)}_catchupBatch(o){if(this._cachedBatch===null&&(this._cachedBatch=this._sessionBatch.clone()),this.length>this._cachedBatch.length){const c=this._cachedBatch.length-this._sessionBatch.length;for(let s=c;s<this._appendsActual.length;s++)this._cachedBatch.append(this._appendsActual[s])}return o?this._cachedBatch.clone():this._cachedBatch}createTreeBatch(o,c={}){Array.isArray(c)&&(c={blocks:c});const{blocks:s=[],clone:u=!0}=c;!o&&o!==0&&(o=this.length+s.length);const f=this.length+s.length,m=this._catchupBatch(u||s.length>0||o!==this.length),E=Math.min(o,this.length);if(E<this._sessionLength||o>f)return null;E<m.length&&m.checkout(E,this._sessionBatch.roots);for(let b=0;b<o-E;b++)m.append(this._appendsActual===this._appends?s[b]:this._encrypt(m.length,s[b]));return m}async truncate(o=0,c={}){if(this.opened===!1&&await this.opening,this.closing)throw a();await this._waitForFlush(),typeof c=="number"&&(c={fork:c});const{fork:s=this.fork+1,force:u=!1}=c;this._cachedBatch=null;const f=this._sessionLength;if(o<f){if(!u)throw new Error("Cannot truncate committed blocks");this._appends.length=0,this._byteLength=0,await this.session.truncate(o,{fork:s,force:!0,...c}),this._sessionLength=this.session.length,this._sessionByteLength=this.session.byteLength,this._sessionBatch=this.session.createTreeBatch()}else{for(let m=o-f;m<this._appends.length;m++)this._byteLength-=this._appends[m].byteLength;this._appends.length=o-f}this.fork=s,this.emit("truncate",o,this.fork)}async append(o){const c=this.session;if(this.opened===!1&&await this.opening,this.closing)throw a();await this._waitForFlush(),o=Array.isArray(o)?o:[o];const s=c.encodeBatch!==null?c.encodeBatch(o):new Array(o.length);if(c.encodeBatch===null)for(let f=0;f<o.length;f++){const m=this._encode(c.valueEncoding,o[f]);s[f]=m,this._byteLength+=m.byteLength}if(this._appends!==this._appendsActual)for(let f=0;f<s.length;f++)this._appendsActual.push(this._encrypt(this._sessionLength+this._appendsActual.length,s[f]));for(const f of s)this._appends.push(f);const u={length:this.length,byteLength:this.byteLength};return this.emit("append"),u}_encode(o,c){const s={start:0,end:0,buffer:null};if(g.isBuffer(c)){if(s.start===0)return c;s.end+=c.byteLength}else if(o)o.preencode(s,c);else{if(c=g.from(c),s.start===0)return c;s.end+=c.byteLength}return s.buffer=g.allocUnsafe(s.end),o?o.encode(s,c):s.buffer.set(c,s.start),s.buffer}_encrypt(o,c){const s=g.allocUnsafe(c.byteLength+8);return s.set(c,8),this.session.encryption.encrypt(o,s,this.fork),s}async flush(o={}){if(this.opened===!1&&await this.opening,this.closing)throw a();const{length:c=this.length,keyPair:s=this.session.keyPair,signature:u=null,pending:f=!u&&!s}=o;for(;this._flushing;)await this._flushing;this._flushing=this._flush(c,s,u,f);let m=!1;try{m=await this._flushing}finally{this._flushing=null}return this.autoClose&&await this.close(),m}async _flush(o,c,s,u){if(this._sessionBatch.fork!==this.session.fork)return!1;if(this.session.replicator._upgrade){for(const M of this.session.replicator._upgrade.inflight)if(M.upgrade&&M.upgrade.start+M.upgrade.length>o)return!1}const f=Math.min(o-this._sessionLength,this._appends.length);if(f<=0){if(this._sessionLength>this.core.tree.length&&o>this.core.tree.length&&!u){const M=await this.restoreBatch(o);return await this.core.insertBatch(M,[],{keyPair:c,signature:s,pending:u,treeLength:o})!==null}return!0}const m=this.createTreeBatch(this._sessionLength+f);if(m===null)return!1;const E=await this.core.insertBatch(m,this._appendsActual,{keyPair:c,signature:s,pending:u,treeLength:this._sessionLength});if(E===null)return!1;const b=E.byteLength-this._sessionByteLength,_=E.length!==this.session.length?await this.session.core.tree.restoreBatch(E.length):this.session.createTreeBatch();this._sessionLength=E.length,this._sessionByteLength=E.byteLength,this._sessionBatch=_,this._cachedBatch!==null&&this._cachedBatch.prune(E.length);const B=this._appends===this._appendsActual;return this._appends=this._appends.slice(f),this._appendsActual=B?this._appends:this._appendsActual.slice(f),this._byteLength-=b,this.emit("flush"),!0}close(){return this.closing||(this.closing=this._close()),this.closing}async _close(){this._clearAppends(),await this.session.close(),this.closed=!0,this.emit("close")}_clearAppends(){this._appends=[],this._appendsActual=[],this._byteLength=0,this.fork=0}},df}var ho={},Jb;function Tx(){if(Jb)return ho;Jb=1;const{Writable:n,Readable:a}=Sn();class p extends a{constructor(h,o={}){super(),this.core=h,this.start=o.start||0,this.end=typeof o.end=="number"?o.end:-1,this.snapshot=!o.live&&o.snapshot!==!1,this.live=!!o.live}_open(h){this._openP().then(h,h)}_read(h){this._readP().then(h,h)}async _openP(){this.end===-1?await this.core.update():await this.core.ready(),this.snapshot&&this.end===-1&&(this.end=this.core.length)}async _readP(){const h=this.live?-1:this.end===-1?this.core.length:this.end;if(h>=0&&this.start>=h){this.push(null);return}this.push(await this.core.get(this.start++))}}ho.ReadStream=p;class l extends n{constructor(h){super(),this.core=h}_writev(h,o){this._writevP(h).then(o,o)}async _writevP(h){await this.core.append(h)}}ho.WriteStream=l;class g extends a{constructor(h,o={}){super(),this._core=h,this._index=0,this._range=null,this._byteOffset=o.byteOffset||0,this._byteLength=typeof o.byteLength=="number"?o.byteLength:-1,this._prefetch=typeof o.prefetch=="number"?o.prefetch:32,this._applyOffset=this._byteOffset>0}_open(h){this._openp().then(h,h)}_read(h){this._readp().then(h,h)}async _openp(){this._byteLength===-1&&(await this._core.update(),this._byteLength=Math.max(this._core.byteLength-this._byteOffset,0))}async _readp(){let h=null;if(this._byteLength===0){this.push(null);return}let o=0;if(this._applyOffset){this._applyOffset=!1;const[c,s]=await this._core.seek(this._byteOffset);this._index=c,o=s}this._predownload(this._index+1),h=await this._core.get(this._index++,{valueEncoding:"binary"}),o>0&&(h=h.subarray(o)),h.byteLength>this._byteLength&&(h=h.subarray(0,this._byteLength)),this._byteLength-=h.byteLength,this.push(h),this._byteLength===0&&this.push(null)}_predownload(h){this._range&&this._range.destroy(),this._range=this._core.download({start:h,end:h+this._prefetch,linear:!0})}_destroy(h){this._range&&this._range.destroy(),h(null)}}return ho.ByteStream=g,ho}var ff,ev;function Dx(){if(ev)return ff;ev=1;const{EventEmitter:n}=nn,a=ux(),p=Kf(),l=_t(),g=et(),y=Ue(),h=g0(),o=Gv(),c=Pf(),s=Of(),u=ol(),f=jt(),m=Xt(),E=gx(),b=Ex(),_=Ax(),B=w0(),M=Rx(),z=Lx(),{manifestHash:j,createManifest:v}=v0(),{ReadStream:w,WriteStream:R,ByteStream:A}=Tx(),{ASSERTION:q,BAD_ARGUMENT:U,SESSION_CLOSED:T,SESSION_NOT_WRITABLE:Q,SNAPSHOT_NOT_AVAILABLE:le,DECODING_ERROR:Y}=Lt(),oe=Symbol.for("hypercore.promises"),ue=Symbol.for("nodejs.util.inspect.custom"),O=15*1024*1024;ff=class sl extends n{constructor(S,N,D){super(),p(S)?(D=S,S=null,N=D.key||null):p(N)&&(D=N,N=D.key||null),N&&typeof N=="string"&&(N=u.decode(N)),D||(D={}),S||(S=D.storage),this[oe]=!0,this.storage=null,this.crypto=D.crypto||l,this.core=null,this.replicator=null,this.encryption=null,this.extensions=new Map,this.cache=re(D.cache),this.valueEncoding=null,this.encodeBatch=null,this.activeRequests=[],this.id=null,this.key=N||null,this.keyPair=D.keyPair||null,this.readable=!0,this.writable=!1,this.opened=!1,this.closed=!1,this.snapshotted=!!D.snapshot,this.sparse=D.sparse!==!1,this.sessions=D._sessions||[this],this.autoClose=!!D.autoClose,this.onwait=D.onwait||null,this.wait=D.wait!==!1,this.timeout=D.timeout||0,this.closing=null,this.opening=null,this._readonly=D.writable===!1,this._preappend=se.bind(this),this._snapshot=null,this._findingPeers=0,this._active=D.active!==!1,this.opening=this._openSession(N,S,D),this.opening.catch(f)}[ue](S,N){let D="";if(typeof N.indentationLvl=="number")for(;D.length<N.indentationLvl;)D+=" ";let H="";const _e=Math.min(this.peers.length,5);for(let ce=0;ce<_e;ce++){const J=this.peers[ce];H+=D+`    Peer(
`,H+=D+"      remotePublicKey: "+N.stylize(he(J.remotePublicKey),"string")+`
`,H+=D+"      remoteLength: "+N.stylize(J.remoteLength,"number")+`
`,H+=D+"      remoteFork: "+N.stylize(J.remoteFork,"number")+`
`,H+=D+"      remoteCanUpgrade: "+N.stylize(J.remoteCanUpgrade,"boolean")+`
`,H+=D+`    )
`}return this.peers.length>5&&(H+=D+"  ... and "+(this.peers.length-5)+` more
`),H?H=`[
`+H+D+"  ]":H="[ "+N.stylize(0,"number")+" ]",this.constructor.name+`(
`+D+"  id: "+N.stylize(this.id,"string")+`
`+D+"  key: "+N.stylize(he(this.key),"string")+`
`+D+"  discoveryKey: "+N.stylize(he(this.discoveryKey),"string")+`
`+D+"  opened: "+N.stylize(this.opened,"boolean")+`
`+D+"  closed: "+N.stylize(this.closed,"boolean")+`
`+D+"  snapshotted: "+N.stylize(this.snapshotted,"boolean")+`
`+D+"  sparse: "+N.stylize(this.sparse,"boolean")+`
`+D+"  writable: "+N.stylize(this.writable,"boolean")+`
`+D+"  length: "+N.stylize(this.length,"number")+`
`+D+"  fork: "+N.stylize(this.fork,"number")+`
`+D+"  sessions: [ "+N.stylize(this.sessions.length,"number")+` ]
`+D+"  activeRequests: [ "+N.stylize(this.activeRequests.length,"number")+` ]
`+D+"  peers: "+H+`
`+D+")"}static MAX_SUGGESTED_BLOCK_SIZE=O;static key(S,{compat:N,version:D,namespace:H}={}){return y.isBuffer(S)&&(S={version:D,signers:[{publicKey:S,namespace:H}]}),N?S.signers[0].publicKey:j(v(S))}static discoveryKey(S){return l.discoveryKey(S)}static getProtocolMuxer(S){return S.noiseStream.userData}static createProtocolStream(S,N={}){let D=c.isProtomux(S)?S.stream:P(S)?S:N.stream,H=null;if(D?H=D.noiseStream:(H=new o(S,null,N),D=H.rawStream),!H)throw U("Invalid stream");if(!H.userData){const _e=c.from(H);N.keepAlive!==!1&&H.setKeepAlive(5e3),H.userData=_e}return N.ondiscoverykey&&H.userData.pair({protocol:"hypercore/alpha"},N.ondiscoverykey),D}static defaultStorage(S,N={}){if(typeof S!="string"){if(!Z(S))return S;const X=S;return ie=>new X(ie)}const D=S,H=N.unlocked?null:N.lock||"oplog",_e=N.pool||(N.poolSize?a.createPool(N.poolSize):null),ce=!!N.rmdir,J=N.writable!==!1;return d;function d(X){const ie=H===null?!1:k(X,H),I=k(X,"data")||k(X,"bitfield")||k(X,"tree");return new a(X,{directory:D,lock:ie,sparse:I,pool:ie?null:_e,rmdir:ce,writable:J})}function k(X,ie){return X===ie||X.endsWith("/"+ie)}}snapshot(S){return this.session({...S,snapshot:!0})}session(S={}){if(this.closing)throw T("Cannot make sessions on a closing core");const N=S.sparse===!1?!1:this.sparse,D=S.wait===!1?!1:this.wait,H=S.writable===!1?!1:!this._readonly,_e=S.onwait===void 0?this.onwait:S.onwait,ce=S.timeout===void 0?this.timeout:S.timeout,J=S.class||sl,d=new J(this.storage,this.key,{...S,sparse:N,wait:D,onwait:_e,timeout:ce,writable:H,_opening:this.opening,_sessions:this.sessions});return d._passCapabilities(this),S.cache!==!1&&(d.cache=S.cache===!0||!S.cache?this.cache:S.cache),this.opened&&G(d,S),this._addSession(d),d}_addSession(S){this.sessions.push(S),this.core&&this.core.active++}async setEncryptionKey(S,N){this.opened||await this.opening,this.encryption=S?new _(S,this.key,{compat:this.core.compat,...N}):null}setKeyPair(S){this.keyPair=S,this.writable=this._isWritable()}setActive(S){const N=!!S;N===this._active||this.closing||(this._active=N,this.opened&&this.replicator.updateActivity(this._active?1:-1))}_passCapabilities(S){this.keyPair||(this.keyPair=S.keyPair),this.crypto=S.crypto,this.id=S.id,this.key=S.key,this.core=S.core,this.replicator=S.replicator,this.encryption=S.encryption,this.writable=this._isWritable(),this.autoClose=S.autoClose,this.snapshotted&&this.core&&!this._snapshot&&this._updateSnapshot()}async _openFromExisting(S,N){S.opened||await S.opening;const D=this.sessions;for(const H of D)H.sessions=S.sessions,H._passCapabilities(S),H._addSession(H);if(this.storage=S.storage,this.replicator.findingPeers+=this._findingPeers,G(this,N),this.encryption&&!S.encryption)for(const H of D)H.encryption=this.encryption}async _openSession(S,N,D){const H=!D._opening;if(H||await D._opening,D.preload&&(D={...D,...await this._retryPreload(D.preload)}),this.cache===null&&D.cache&&(this.cache=re(D.cache)),H){if(await this._openCapabilities(S,N,D),!D.from)for(let _e=0;_e<this.sessions.length;_e++){const ce=this.sessions[_e];ce!==this&&ce._passCapabilities(this)}}else G(this,D);D.manifest&&!this.core.header.manifest&&await this.core.setManifest(D.manifest),this.writable=this._isWritable(),D.valueEncoding&&(this.valueEncoding=g.from(D.valueEncoding)),D.encodeBatch&&(this.encodeBatch=D.encodeBatch),this.sparse||this.download({start:0,end:-1}),D._preready&&await D._preready(this),this.replicator.updateActivity(this._active?1:0),this.opened=!0,this.emit("ready")}async _retryPreload(S){for(;;){const N=await S(),D=N&&N.from;if(!(D&&(D.opened||await D.ready(),D.closing)))return N}}async _openCapabilities(S,N,D){if(D.from)return this._openFromExisting(D.from,D);const H=!!D.unlocked;if(this.storage=sl.defaultStorage(D.storage||N,{unlocked:H,writable:!H}),this.core=await b.open(this.storage,{compat:D.compat,force:D.force,sessions:this.sessions,createIfMissing:D.createIfMissing,readonly:H,overwrite:D.overwrite,key:S,keyPair:D.keyPair,crypto:this.crypto,legacy:D.legacy,manifest:D.manifest,globalCache:D.globalCache||null,onupdate:this._oncoreupdate.bind(this),onconflict:this._oncoreconflict.bind(this)}),D.userData)for(const[_e,ce]of Object.entries(D.userData))await this.core.userData(_e,ce);this.key=this.core.header.key,this.keyPair=this.core.header.keyPair,this.id=s.encode(this.key),this.replicator=new E(this.core,this.key,{eagerUpgrade:!0,notDownloadingLinger:D.notDownloadingLinger,allowFork:D.allowFork!==!1,inflightRange:D.inflightRange,onpeerupdate:this._onpeerupdate.bind(this),onupload:this._onupload.bind(this),oninvalid:this._oninvalid.bind(this)}),this.replicator.findingPeers+=this._findingPeers,!this.encryption&&D.encryptionKey&&(this.encryption=new _(D.encryptionKey,this.key,{compat:this.core.compat,isBlockKey:D.isBlockKey}))}_getSnapshot(){return this.sparse?{length:this.core.tree.length,byteLength:this.core.tree.byteLength,fork:this.core.tree.fork,compatLength:this.core.tree.length}:{length:this.core.header.hints.contiguousLength,byteLength:0,fork:this.core.tree.fork,compatLength:this.core.header.hints.contiguousLength}}_updateSnapshot(){const S=this._snapshot,N=this._snapshot=this._getSnapshot();return S?S.length!==N.length||S.fork!==N.fork:!0}_isWritable(){return!this._readonly&&!!(this.keyPair&&this.keyPair.secretKey)}close(S){return this.closing?this.closing:(this.closing=this._close(S||null),this.closing)}async _close(S){this.opened===!1&&await this.opening;const N=this.sessions.indexOf(this);if(N===-1)return;this.sessions.splice(N,1),this.core.active--,this.readable=!1,this.writable=!1,this.closed=!0,this.opened=!1;const D=[];for(const H of this.extensions.values())H.session===this&&D.push(H);for(const H of D)H.destroy();if(this.replicator!==null&&(this.replicator.findingPeers-=this._findingPeers,this.replicator.clearRequests(this.activeRequests,S),this.replicator.updateActivity(this._active?-1:0)),this._findingPeers=0,this.sessions.length||this.core.active>0){this.sessions.length===1&&this.core.active===1&&this.autoClose&&await this.sessions[0].close(S),this.emit("close",!1);return}this.replicator!==null&&await this.replicator.destroy(),await this.core.close(),this.emit("close",!0)}replicate(S,N={}){if(c.isProtomux(S))return this._attachToMuxer(S,N);if(P(S)&&this._isAttached(S))return S;const D=sl.createProtocolStream(S,N),_e=D.noiseStream.userData,ce=!!N.session;return this._attachToMuxer(_e,ce),D}_isAttached(S){return S.userData&&this.replicator&&this.replicator.attached(S.userData)}_attachToMuxer(S,N){return this.opened?this._attachToMuxerOpened(S,N):this.opening.then(this._attachToMuxerOpened.bind(this,S,N),S.destroy.bind(S)),S}_attachToMuxerOpened(S,N){this.replicator.attachTo(S,N)}get discoveryKey(){return this.replicator===null?null:this.replicator.discoveryKey}get manifest(){return this.core===null?null:this.core.header.manifest}get length(){return this._snapshot?this._snapshot.length:this.core===null?0:this.sparse?this.core.tree.length:this.contiguousLength}get signedLength(){return this.length}get indexedLength(){return this.length}get byteLength(){return this._snapshot?this._snapshot.byteLength:this.core===null?0:this.sparse?this.core.tree.byteLength-this.core.tree.length*this.padding:this.contiguousByteLength}get contiguousLength(){return this.core===null?0:Math.min(this.core.tree.length,this.core.header.hints.contiguousLength)}get contiguousByteLength(){return 0}get fork(){return this.core===null?0:this.core.tree.fork}get peers(){return this.replicator===null?[]:this.replicator.peers}get encryptionKey(){return this.encryption&&this.encryption.key}get padding(){return this.encryption===null?0:this.encryption.padding}get globalCache(){return this.core&&this.core.globalCache}ready(){return this.opening}_onupload(S,N,D){const H=N.byteLength-this.padding;for(let _e=0;_e<this.sessions.length;_e++)this.sessions[_e].emit("upload",S,H,D)}_oninvalid(S,N,D,H){for(let _e=0;_e<this.sessions.length;_e++)this.sessions[_e].emit("verification-error",S,N,D,H)}async _oncoreconflict(S,N){await this.replicator.onconflict(N);for(const H of this.sessions)H.emit("conflict",S.upgrade.length,S.fork,S);const D=new Error("Two conflicting signatures exist for length "+S.upgrade.length);await this._closeAllSessions(D)}async _closeAllSessions(S){const N=[...this.sessions],D=[];for(const H of N)D.push(H.close(S));await Promise.allSettled(D)}_oncoreupdate(S,N,D,H){if(S!==0){const _e=(S&8)!==0,ce=(S&4)!==0,J=(S&2)!==0,d=(S&1)!==0;if(J&&this.replicator.ontruncate(N.start,N.length),(S&19)!==0&&this.replicator.onupgrade(),S&16){for(let X=0;X<this.sessions.length;X++){const ie=this.sessions[X];ie.encryption&&ie.encryption.compat!==this.core.compat&&(ie.encryption=new _(ie.encryption.key,this.key,{compat:this.core.compat,isBlockKey:ie.encryption.isBlockKey}))}for(let X=0;X<this.sessions.length;X++)this.sessions[X].emit("manifest")}for(let X=0;X<this.sessions.length;X++){const ie=this.sessions[X];J&&(ie.cache&&ie.cache.clear(),ie._snapshot&&N.start<ie._snapshot.compatLength&&(ie._snapshot.compatLength=N.start)),(ie.sparse?J:_e)&&ie.emit("truncate",N.start,this.core.tree.fork),(ie.sparse?d:ce)&&ie.emit("append")}const k=this.core.header.hints.contiguousLength;if(ce&&k===this.core.tree.length)for(const X of this.peers)X.broadcastedNonSparse||(X.broadcastRange(0,k),X.broadcastedNonSparse=!0)}if(N&&this.replicator.onhave(N.start,N.length,N.drop),D){const _e=D.byteLength-this.padding;for(let ce=0;ce<this.sessions.length;ce++)this.sessions[ce].emit("download",N.start,_e,H)}}_onpeerupdate(S,N){const D=S?"peer-add":"peer-remove";for(let H=0;H<this.sessions.length;H++)if(this.sessions[H].emit(D,N),S)for(const _e of this.sessions[H].extensions.values())N.extensions.set(_e.name,_e)}async setUserData(S,N,{flush:D=!1}={}){return this.opened===!1&&await this.opening,this.core.userData(S,N,D)}async getUserData(S){this.opened===!1&&await this.opening;for(const{key:N,value:D}of this.core.header.userData)if(S===N)return D;return null}createTreeBatch(){return this.core.tree.batch()}findingPeers(){this._findingPeers++,this.replicator!==null&&!this.closing&&this.replicator.findingPeers++;let S=!0;return()=>{this.closing||!S||(S=!1,this._findingPeers--,this.replicator!==null&&--this.replicator.findingPeers===0&&this.replicator.updateAll())}}async info(S){return this.opened===!1&&await this.opening,B.from(this,S)}async update(S){if(this.opened===!1&&await this.opening,this.closing!==null)return!1;if(this.writable&&(!S||S.force!==!0))return this.snapshotted?this._updateSnapshot():!1;const N=this._shouldWait(S,this.replicator.findingPeers>0);let D=!1;if(await this.replicator.applyPendingReorg()&&(D=!0),!D&&N){const H=S&&S.activeRequests||this.activeRequests;D=await this.replicator.addUpgrade(H).promise}return D?this.snapshotted?this._updateSnapshot():!0:!1}batch({checkout:S=-1,autoClose:N=!0,session:D=!0,restore:H=!1,clear:_e=!1}={}){return new z(D?this.session():this,S,N,H,_e)}async seek(S,N){if(this.opened===!1&&await this.opening,!W(S))throw q("seek is invalid");const H=(N&&N.tree||this.core.tree).seek(S,this.padding),_e=await H.update();if(_e)return _e;if(this.closing!==null)throw T();if(!this._shouldWait(N,this.wait))return null;const ce=N&&N.activeRequests||this.activeRequests,J=this.replicator.addSeek(ce,H),d=N&&N.timeout!==void 0?N.timeout:this.timeout;return d&&J.context.setTimeout(J,d),J.promise}async has(S,N=S+1){if(this.opened===!1&&await this.opening,!W(S)||!W(N))throw q("has range is invalid");if(N===S+1)return this.core.bitfield.get(S);const D=this.core.bitfield.firstUnset(S);return D===-1||D>=N}async get(S,N){if(this.opened===!1&&await this.opening,!W(S))throw q("block index is invalid");if(this.closing!==null)throw T();if(this._snapshot!==null&&S>=this._snapshot.compatLength)throw le();const D=N&&N.valueEncoding&&g.from(N.valueEncoding)||this.valueEncoding;let H=this.cache&&this.cache.get(S);H||(H=this._get(S,N));let _e=await H;return _e?N&&N.raw?_e:(this.encryption&&(!N||N.decrypt!==!1)&&(_e=y.from(_e),this.encryption.decrypt(S,_e)),this._decode(D,_e)):null}async clear(S,N=S+1,D){if(this.opened===!1&&await this.opening,this.closing!==null)throw T();if(typeof N=="object"&&(D=N,N=S+1),!W(S)||!W(N))throw q("clear range is invalid");const H=D&&D.diff?{blocks:0}:null;return S>=N||S>=this.length||await this.core.clear(S,N,H),H}async purge(){await this._closeAllSessions(null),await this.core.purge()}async _get(S,N){let D;if(this.core.bitfield.get(S)){const H=N&&N.tree||this.core.tree;D=this.core.blocks.get(S,H),this.cache&&this.cache.set(S,D)}else{if(!this._shouldWait(N,this.wait))return null;N&&N.onwait&&N.onwait(S,this),this.onwait&&this.onwait(S,this);const H=N&&N.activeRequests||this.activeRequests,_e=this.replicator.addBlock(H,S);_e.snapshot=S<this.length;const ce=N&&N.timeout!==void 0?N.timeout:this.timeout;ce&&_e.context.setTimeout(_e,ce),D=this._cacheOnResolve(S,_e.promise,this.core.tree.fork)}return D}async _cacheOnResolve(S,N,D){const H=await N,_e=H!==null&&2*H.byteLength<H.buffer.byteLength?m(H):H;return this.cache&&D===this.core.tree.fork&&this.cache.set(S,Promise.resolve(_e)),_e}_shouldWait(S,N){if(S){if(S.wait===!1)return!1;if(S.wait===!0)return!0}return N}createReadStream(S){return new w(this,S)}createWriteStream(S){return new R(this,S)}createByteStream(S){return new A(this,S)}download(S){const N=this._download(S);return N.catch(f),new M(N)}async _download(S){this.opened===!1&&await this.opening;const N=S&&S.activeRequests||this.activeRequests;return this.replicator.addRange(N,S)}undownload(S){S.destroy(null)}cancel(S){}async truncate(S=0,N={}){this.opened===!1&&await this.opening;const{fork:D=this.core.tree.fork+1,keyPair:H=this.keyPair,signature:_e=null}=typeof N=="number"?{fork:N}:N;if((!this._readonly&&!!(_e||H&&H.secretKey))===!1&&(S>0||D!==this.core.tree.fork))throw Q();await this.core.truncate(S,D,{keyPair:H,signature:_e}),this.replicator.updateAll()}async append(S,N={}){this.opened===!1&&await this.opening;const{keyPair:D=this.keyPair,signature:H=null}=N;if((!this._readonly&&!!(H||D&&D.secretKey))===!1)throw Q();S=Array.isArray(S)?S:[S];const ce=this.encryption&&this._preappend,J=this.encodeBatch!==null?this.encodeBatch(S):new Array(S.length);if(this.encodeBatch===null)for(let d=0;d<S.length;d++)J[d]=this._encode(this.valueEncoding,S[d]);for(const d of J)if(d.byteLength>O)throw U("Appended block exceeds the maximum suggested block size");return this.core.append(J,{keyPair:D,signature:H,preappend:ce})}async treeHash(S){S===void 0&&(await this.ready(),S=this.core.tree.length);const N=await this.core.tree.getRoots(S);return this.crypto.tree(N)}registerExtension(S,N={}){if(this.extensions.has(S)){const H=this.extensions.get(S);return H.handlers=N,H.encoding=g.from(N.encoding||g.buffer),H.session=this,H}const D={name:S,handlers:N,encoding:g.from(N.encoding||g.buffer),session:this,send(H,_e){const ce=g.encode(this.encoding,H);_e.extension(S,ce)},broadcast(H){const _e=g.encode(this.encoding,H);for(const ce of this.session.peers)ce.extension(S,_e)},destroy(){for(const H of this.session.peers)H.extensions.get(S)===D&&H.extensions.delete(S);this.session.extensions.delete(S)},_onmessage(H,_e){const ce=this.encoding.decode(H);this.handlers.onmessage&&this.handlers.onmessage(ce,_e)}};this.extensions.set(S,D);for(const H of this.peers)H.extensions.set(S,D);return D}_encode(S,N){const D={start:this.padding,end:this.padding,buffer:null};if(y.isBuffer(N)){if(D.start===0)return N;D.end+=N.byteLength}else if(S)S.preencode(D,N);else{if(N=y.from(N),D.start===0)return N;D.end+=N.byteLength}return D.buffer=y.allocUnsafe(D.end),S?S.encode(D,N):D.buffer.set(N,D.start),D.buffer}_decode(S,N){this.padding&&(N=N.subarray(this.padding));try{if(S)return g.decode(S,N)}catch{throw Y()}return N}};function P($){return typeof $=="object"&&$&&typeof $.pipe=="function"}function Z($){return!!(typeof $=="function"&&$.prototype&&typeof $.prototype.open=="function")}function he($){return $&&y.toString($,"hex")}function se($){const S=this.core.tree.length,N=this.core.tree.fork;for(let D=0;D<$.length;D++)this.encryption.encrypt(S+D,$[D],N)}function G($,S){S.encryptionKey&&($.encryption&&y.equals($.encryption.key,S.encryptionKey)&&$.encryption.compat===$.core.compat||($.encryption=new _(S.encryptionKey,$.key,{compat:$.core?$.core.compat:!0,isBlockKey:S.isBlockKey})))}function re($){return $===!0?new h({maxSize:65536,maxAge:0}):$||null}function W($){return $===0||$>0}return ff}var gf,tv;function Bx(){if(tv)return gf;tv=1;const n=Rn(),a=jt(),p=d0();gf=class extends n{constructor(h,o={}){super(),this.drive=h,this.blobs=null,this.name=o.name||null,this.entry=o.entry||null,this.peers=0,this._boundOnUpload=this._onUpload.bind(this),this._boundOnDownload=this._onDownload.bind(this),this._boundPeerUpdate=this._updatePeers.bind(this);const c={startTime:0,percentage:0,peers:0,speed:0,blocks:0,totalBytes:0,monitoringBytes:0,targetBytes:0,targetBlocks:0};this.uploadStats={...c},this.downloadStats={...c},this.uploadSpeedometer=null,this.downloadSpeedometer=null,this.ready().catch(a)}async _open(){await this.drive.ready(),this.blobs=await this.drive.getBlobs(),!this.entry&&this.name&&(this.entry=await this.drive.entry(this.name)),this.entry&&this._setEntryInfo(),this.uploadSpeedometer=p(),this.downloadSpeedometer=p(),this._updatePeers(),this.blobs.core.on("peer-add",this._boundPeerUpdate),this.blobs.core.on("peer-remove",this._boundPeerUpdate),this.blobs.core.on("upload",this._boundOnUpload),this.blobs.core.on("download",this._boundOnDownload)}async _close(){this.blobs.core.off("peer-add",this._boundPeerUpdate),this.blobs.core.off("peer-remove",this._boundPeerUpdate),this.blobs.core.off("upload",this._boundOnUpload),this.blobs.core.off("download",this._boundOnDownload),this.drive.monitors.delete(this)}_setEntryInfo(){(!this.downloadStats.targetBytes||!this.downloadStats.targetBlocks)&&(this.downloadStats.targetBytes=this.entry.value.blob.byteLength,this.downloadStats.targetBlocks=this.entry.value.blob.blockLength),(!this.uploadStats.targetBytes||!this.uploadStats.targetBlocks)&&(this.uploadStats.targetBytes=this.entry.value.blob.byteLength,this.uploadStats.targetBlocks=this.entry.value.blob.blockLength)}_onUpload(h,o,c){this._updateStats(this.uploadSpeedometer,this.uploadStats,h,o,c)}_onDownload(h,o,c){this._updateStats(this.downloadSpeedometer,this.downloadStats,h,o,c)}_updatePeers(){this.uploadStats.peers=this.downloadStats.peers=this.peers=this.blobs.core.peers.length}_updateStats(h,o,c,s,u){!this.entry||this.closing||l(c,this.entry)&&(o.startTime||(o.startTime=Date.now()),o.speed=h(s),o.blocks++,o.monitoringBytes+=s,o.totalBytes+=s,o.percentage=g(o.blocks/o.targetBlocks*100),this.emit("update"))}downloadSpeed(){return this.downloadSpeedometer?this.downloadSpeedometer():0}uploadSpeed(){return this.uploadSpeedometer?this.uploadSpeedometer():0}};function l(y,h){if(!h||!h.value)return;const{blockOffset:o,blockLength:c}=h.value.blob;return y>=o&&y<o+c}function g(y){return Math.round(y*100)/100}return gf}var pf,nv;function Nx(){if(nv)return pf;nv=1;const n=Qf(),a=ax(),p=Kf(),{Writable:l,Readable:g}=Sn(),y=f0(),h=hx(),o=l0(),c=Rn(),s=jt(),u=_t(),f=Dx(),{BLOCK_NOT_AVAILABLE:m,BAD_ARGUMENT:E}=Lt(),b=Bx(),_=new o("files","utf-8"),[B]=u.namespace("hyperdrive",1);pf=class rl extends c{constructor(Y,oe,ue={}){super(),p(oe)&&(ue=oe,oe=null),this.corestore=Y,this.db=ue._db||z(oe,Y,ue),this.core=this.db.core,this.blobs=null,this.supportsMetadata=!0,this.encryptionKey=ue.encryptionKey||null,this.monitors=new Set,this._active=ue.active!==!1,this._openingBlobs=null,this._onwait=ue.onwait||null,this._batching=!!(ue._checkout===null&&ue._db),this._checkout=ue._checkout||null,this.ready().catch(s)}[Symbol.asyncIterator](){return this.entries()[Symbol.asyncIterator]()}static async getDriveKey(Y){const oe=z(void 0,Y);await oe.ready();const ue=oe.key;return await oe.close(),ue}static getContentKey(Y,oe){if(Y instanceof f)return Y.core.compat?null:rl.getContentKey(Y.manifest,Y.key);const ue=A(Y,oe);return ue?f.key(ue):null}_generateBlobsManifest(){const Y=this.db.core.manifest;return this.db.core.core.compat?null:A(Y,this.core.key)}get id(){return this.core.id}get key(){return this.core.key}get discoveryKey(){return this.core.discoveryKey}get contentKey(){return this.blobs?.core.key}get version(){return this.db.version}get writable(){return this.core.writable}get readable(){return this.core.readable}findingPeers(){return this.corestore.findingPeers()}async truncate(Y,{blobs:oe=-1}={}){if(this.opened||await this.ready(),Y>this.core.length)throw E("Bad truncation length");const ue=oe===-1?await this.getBlobsLength(Y):oe,O=await this.getBlobs();if(ue>O.core.length)throw E("Bad truncation length");await this.core.truncate(Y),await O.core.truncate(ue)}async getBlobsLength(Y){this.opened||await this.ready(),Y||(Y=this.version);const oe=this.db.checkout(Y);try{return await q(oe)}finally{await oe.close()}}replicate(Y,oe){return this.corestore.replicate(Y,oe)}update(Y){return this.db.update(Y)}_makeCheckout(Y){return new rl(this.corestore,this.key,{onwait:this._onwait,encryptionKey:this.encryptionKey,_checkout:this._checkout||this,_db:Y})}checkout(Y){return this._makeCheckout(this.db.checkout(Y))}batch(){return new rl(this.corestore,this.key,{onwait:this._onwait,encryptionKey:this.encryptionKey,_checkout:null,_db:this.db.batch()})}setActive(Y){const oe=!!Y;oe!==this._active&&(this._active=oe,this.core.setActive(oe),this.blobs&&this.blobs.core.setActive(oe))}async flush(){return await this.db.flush(),this.close()}async _close(){this.blobs&&(!this._checkout||this.blobs!==this._checkout.blobs)&&await this.blobs.core.close(),await this.db.close(),!this._checkout&&!this._batching&&await this.corestore.close(),await this.closeMonitors()}async _openBlobsFromHeader(Y){if(this.blobs)return!0;const oe=await j(this.db).getHeader(Y);if(!oe)return!1;if(this.blobs)return!0;const ue=oe.metadata&&oe.metadata.contentFeed&&oe.metadata.contentFeed.subarray(0,32),O=ue||f.key(this._generateBlobsManifest());if(!O||O.length<32)throw new Error("Invalid or no Blob store key set");const P=this.corestore.get({key:O,cache:!1,onwait:this._onwait,encryptionKey:this.encryptionKey,keyPair:!ue&&this.db.core.writable?this.db.core.keyPair:null,active:this._active});return await P.ready(),this.closing?(await P.close(),!1):(this.blobs=new a(P),this.emit("blobs",this.blobs),this.emit("content-key",P.key),!0)}async _open(){if(this._checkout){await this._checkout.ready(),this.blobs=this._checkout.blobs;return}if(await this._openBlobsFromHeader({wait:!1}),this.db.core.writable&&!this.blobs){const Y=this._generateBlobsManifest(),oe=this.corestore.get({manifest:Y,name:Y?null:this.db.core.id+"/blobs",cache:!1,onwait:this._onwait,encryptionKey:this.encryptionKey,compat:this.db.core.core.compat,active:this._active,keyPair:Y&&this.db.core.writable?this.db.core.keyPair:null});await oe.ready(),this.blobs=new a(oe),Y||(j(this.db).metadata.contentFeed=this.blobs.core.key),this.emit("blobs",this.blobs),this.emit("content-key",oe.key)}await this.db.ready(),this.blobs||(this._openingBlobs=this._openBlobsFromHeader(),this._openingBlobs.catch(s))}async getBlobs(){return this.blobs?this.blobs:(this._checkout?this.blobs=await this._checkout.getBlobs():(await this.ready(),await this._openingBlobs),this.blobs)}monitor(Y,oe={}){const ue=new b(this,{name:Y,...oe});return this.monitors.add(ue),ue}async closeMonitors(){const Y=[];for(const oe of this.monitors)Y.push(oe.close());await Promise.allSettled(Y)}async get(Y,oe){const ue=await this.entry(Y,oe);if(!ue?.value.blob)return null;await this.getBlobs();const O=await this.blobs.get(ue.value.blob,oe);if(O===null)throw m();return O}async put(Y,oe,{executable:ue=!1,metadata:O=null}={}){await this.getBlobs();const P=await this.blobs.put(oe);return this.db.put(v(Y,!1),{executable:ue,linkname:null,blob:P,metadata:O},{keyEncoding:_})}async del(Y){return this.db.del(v(Y,!1),{keyEncoding:_})}compare(Y,oe){const ue=Y.seq-oe.seq;return ue>0?1:ue<0?-1:0}async clear(Y,oe){this.opened||await this.ready();let ue=null;try{ue=await this.entry(Y,{wait:!1})}catch{}return ue===null||this.blobs===null?oe&&oe.diff?{blocks:0}:null:this.blobs.clear(ue.value.blob,oe)}async clearAll(Y){return this.opened||await this.ready(),this.blobs===null?Y&&Y.diff?{blocks:0}:null:this.blobs.core.clear(0,this.blobs.core.length,Y)}async purge(){if(this._checkout||this._batch)throw new Error("Can only purge the main session");await this.ready(),await this.close();const Y=[this.core.purge()];this.blobs&&Y.push(this.blobs.core.purge()),await Promise.all(Y)}async symlink(Y,oe,{metadata:ue=null}={}){return this.db.put(v(Y,!1),{executable:!1,linkname:oe,blob:null,metadata:ue},{keyEncoding:_})}async entry(Y,oe){if(!oe||!oe.follow)return this._entry(Y,oe);for(let ue=0;ue<16;ue++){const O=await this._entry(Y,oe);if(!O||!O.value.linkname)return O;Y=y(O.key,O.value.linkname)}throw new Error("Recursive symlink")}async _entry(Y,oe){return typeof Y!="string"?Y:this.db.get(v(Y,!1),{...oe,keyEncoding:_})}async exists(Y){return await this.entry(Y)!==null}watch(Y){return Y=v(Y||"/",!0),this.db.watch(R(Y),{keyEncoding:_,map:oe=>this._makeCheckout(oe)})}diff(Y,oe,ue){return typeof oe=="object"&&oe&&!ue?this.diff(Y,null,oe):(oe=v(oe||"/",!0),this.db.createDiffStream(Y,R(oe),{...ue,keyEncoding:_}))}async downloadDiff(Y,oe,ue){const O=[];for await(const Z of this.diff(Y,oe,ue)){if(!Z.left)continue;const he=Z.left.value.blob;if(!he)continue;const se=await this.getBlobs();O.push(se.core.download({start:he.blockOffset,length:he.blockLength}))}const P=[];for(const Z of O)P.push(Z.downloaded());await Promise.allSettled(P)}async downloadRange(Y,oe){const ue=[];await this.ready();for(const Z of Y)ue.push(this.db.core.download(Z));const O=await this.getBlobs();for(const Z of oe)ue.push(O.core.download(Z));const P=[];for(const Z of ue)P.push(Z.downloaded());await Promise.allSettled(P)}entries(Y,oe){const ue=this.db.createReadStream(Y,{...oe,keyEncoding:_});return oe&&oe.ignore&&(ue._readableState.map=Q(oe.ignore)),ue}async download(Y="/",oe){if(typeof Y=="object")return this.download(void 0,Y);const ue=[],O=!Y||Y.endsWith("/")?null:await this.entry(Y);if(O){const Z=O.value.blob;if(!Z)return;await(await this.getBlobs()).core.download({start:Z.blockOffset,length:Z.blockLength}).downloaded();return}for await(const Z of this.list(Y,oe));for await(const Z of this.list(Y,oe)){const he=Z.value.blob;if(!he)continue;const se=await this.getBlobs();ue.push(se.core.download({start:he.blockOffset,length:he.blockLength}))}const P=[];for(const Z of ue)P.push(Z.downloaded());await Promise.allSettled(P)}list(Y,oe={}){if(typeof Y=="object")return this.list(void 0,Y);Y=v(Y||"/",!0);const ue=oe.ignore?U(oe.ignore):null;return oe&&oe.recursive===!1?M(this.db,Y,!1,ue,oe):this.entries(R(Y),{...oe,ignore:ue})}readdir(Y,oe){return Y=v(Y||"/",!0),M(this.db,Y,!0,null,oe)}mirror(Y,oe){return new h(this,Y,oe)}createReadStream(Y,oe){const ue=this;let O=!1,P=null;const Z=new g({open(he){ue.getBlobs().then(se,he);function se(){ue.entry(Y).then(G,he)}function G(re){if(O)return he(null);if(!re)return he(new Error("Blob does not exist"));if(ue.closing)return he(new Error("Closed"));if(!re.value.blob)return Z.push(null),he(null);P=ue.blobs.createReadStream(re.value.blob,oe),P.on("data",function(W){Z.push(W)||P.pause()}),P.on("end",function(){Z.push(null)}),P.on("error",function(W){Z.destroy(W)}),he(null)}},read(he){P.resume(),he(null)},predestroy(){O=!0,P&&P.destroy()}});return Z}createWriteStream(Y,{executable:oe=!1,metadata:ue=null}={}){const O=this;let P=!1,Z=null,he=null,se=null;const G=new l({open($){O.getBlobs().then(S,$);function S(){if(P)return $(null);Z=O.blobs.createWriteStream(),Z.on("error",function(N){G.destroy(N)}),Z.on("close",function(){const N=new Error("Closed");W(N),re(N)}),Z.on("finish",function(){re(null)}),Z.on("drain",function(){W(null)}),$(null)}},write($,S){if(Z.write($)===!0)return S(null);he=S},final($){se=$,Z.end()},predestroy(){P=!0,Z&&Z.destroy()}});return G;function re($){if(!se)return;const S=se;if(se=null,$)return S($);O.db.put(v(Y,!1),{executable:oe,linkname:null,blob:Z.id,metadata:ue},{keyEncoding:_}).then(()=>S(null),S)}function W($){if(he){const S=he;he=null,S($)}}}static normalizePath(Y){return v(Y,!1)}};function M(le,Y,oe,ue,O){let P="/",Z="";return new g({async read(he){let se=null;try{se=await le.peek(R(Y,P),{...O,keyEncoding:_})}catch($){return he($)}if(!se)return this.push(null),he(null);const G=se.key.slice(Y.length+1),re=G.indexOf("/"),W=re===-1?G:G.slice(0,re);if(P="/"+W+(re===-1?"":"0"),W===Z){this._read(he);return}if(Z=W,ue&&T(se.key,ue)){this._read(he);return}this.push(oe?W:se),he(null)}})}function z(le,Y,oe={}){const ue=le?void 0:"db",O=Y.get({key:le,name:ue,exclusive:!0,onwait:oe.onwait,encryptionKey:oe.encryptionKey,compat:oe.compat,active:oe.active});return new n(O,{keyEncoding:"utf-8",valueEncoding:"json",metadata:{contentFeed:null}})}function j(le){return le.tree||le}function v(le,Y){return le=y("/",le),Y&&le.endsWith("/")&&(le=le.slice(0,-1)),w(le),le}function w(le){if(le==="/")throw new Error("Invalid filename: "+le)}function R(le,Y="/"){return{gt:le+Y,lt:le+"0"}}function A(le,Y){if(le.version<1)return null;const oe=[];Y||(Y=f.key(le));for(const ue of le.signers){const O=u.hash([B,Y,ue.namespace]);oe.push({...ue,namespace:O})}return{version:le.version,hash:"blake2b",allowPatch:le.allowPatch,quorum:le.quorum,signers:oe,prologue:null}}async function q(le){let Y=0;for await(const{value:oe}of le.createReadStream()){const ue=oe&&oe.blob;if(!ue)continue;const O=ue.blockOffset+ue.blockLength;O>Y&&(Y=O)}return Y}function U(le){return[].concat(le).map(Y=>y("/",Y))}function T(le,Y){return Y.some(oe=>oe===le||le.startsWith(oe+"/"))}function Q(le){return Y=>T(Y.key,le)?null:Y}return pf}var qx=Nx();const Ja=ti(qx);var yf,iv;function Cx(){if(iv)return yf;iv=1;const n=sn(),a=Ue();function p(y){const h=a.allocUnsafe(32);return n.crypto_generichash(h,y),h}function l(y){const h=a.allocUnsafeSlow(32);return n.crypto_generichash(h,y),h}function g(y){const h=a.alloc(32),o=a.alloc(64);return y?n.crypto_sign_seed_keypair(h,o,y):n.crypto_sign_keypair(h,o),{publicKey:h,secretKey:o}}return yf={hash:p,unslabbedHash:l,createKeyPair:g},yf}var _f,sv;function Mx(){if(sv)return _f;sv=1;const{hash:n,createKeyPair:a}=Cx();return _f=class{constructor(){throw new Error("hyperdht is not supported in browsers")}static keyPair(l){return a(l)}static hash(l){return n(l)}},_f}var Qs={},rv;function Ux(){if(rv)return Qs;rv=1,Qs.add=n,Qs.has=a,Qs.remove=p,Qs.swap=l;function n(g,y){return a(g,y)||(y._index=g.length,g.push(y)),y}function a(g,y){return y._index<g.length&&g[y._index]===y}function p(g,y){if(!a(g,y))return null;var h=g.pop();return h!==y&&(g[y._index]=h,h._index=y._index),y}function l(g,y,h){if(!(!a(g,y)||!a(g,h))){var o=y._index;y._index=h._index,g[y._index]=y,h._index=o,g[h._index]=h}}return Qs}var mf,ov;function Ox(){if(ov)return mf;ov=1;const n=Ux();mf=h=>new a(h);class a{constructor(o){this.priorities=[],this.equals=o&&o.equals||null}get length(){return this.priorities.reduce(y,0)}[Symbol.iterator](){return new p(this)}head(){for(let o=this.priorities.length-1;o>=0;o--){const c=this.priorities[o];if(c.length)return l(c,0)}return null}tail(){for(let o=0;o<this.priorities.length;o++){const c=this.priorities[o];if(c.length)return l(c,0)}return null}prev(o){return o?g(this.priorities,o,1):this.tail()}next(o){return o?g(this.priorities,o,-1):this.head()}shift(){return this.remove(this.head())}pop(){return this.remove(this.tail())}add(o){const c=o.priority||0;for(;c>=this.priorities.length;)this.priorities.push([]);return n.add(this.priorities[c],o),o}remove(o){return!o||o._index===void 0&&(o=this.find(o),!o)?null:n.remove(this.priorities[o.priority||0],o)}has(o){if(o._index===void 0)return this.find(o);const c=o.priority||0;return c>=this.priorities.length?!1:n.has(this.priorities[c],o)}find(o){if(o._index!==void 0)return o;const c=o.priority||0,s=this.priorities;if(c>=s.length)return null;const u=s[c];for(let f=0;f<u.length;f++)if(this.equals(u[f],o))return u[f];return null}}class p{constructor(o){this.prev=null,this.queue=o}next(){const o=this.queue.next(this.prev);return this.prev=o,{done:!o,value:o}}}function l(h,o){const c=o+Math.floor(Math.random()*(h.length-o));return n.swap(h,h[c],h[o]),h[o]}function g(h,o,c){let s=o.priority||0,u=(o._index||0)+1;for(;;){if(s<0||s>=h.length)return null;const f=h[s];if(u>=f.length){s+=c,u=0;continue}return l(f,u)}}function y(h,o){return h+o.length}return mf}var wf,av;function Px(){if(av)return wf;av=1;const{EventEmitter:n}=nn,a=Ue(),p=Xt(),l=15e3,g=0,y=1,h=2,o=3,c=4;return wf=class extends n{constructor({publicKey:u,relayAddresses:f}){super(),this.publicKey=p(u),this.relayAddresses=f,this.reconnecting=!0,this.proven=!1,this.connectedTime=-1,this.disconnectedTime=0,this.banned=!1,this.tried=!1,this.explicit=!1,this.waiting=!1,this.forceRelaying=!1,this.queued=!1,this.client=!1,this.topics=[],this.attempts=0,this.priority=h,this._index=0,this._flushTick=0,this._seenTopics=new Set}get server(){return!this.client}get prioritized(){return this.priority>=h}_getPriority(){return this.tried&&!this.proven||this.attempts>3?g:this.attempts===3?y:this.attempts===2?o:this.attempts===1?c:h}_connected(){this.proven=!0,this.connectedTime=Date.now()}_disconnected(){this.disconnectedTime=Date.now(),this.connectedTime>-1&&(this.disconnectedTime-this.connectedTime>=l&&(this.attempts=0),this.connectedTime=-1),this.attempts++}_deprioritize(){this.attempts=3}_reset(){this.client=!1,this.proven=!1,this.tried=!1,this.attempts=0}_updatePriority(){return this.explicit&&this.attempts>3&&this._deprioritize(),this.banned||this.queued||this.attempts>3?!1:(this.priority=this._getPriority(),!0)}_topic(u){const f=a.toString(u,"hex");this._seenTopics.has(f)||(this._seenTopics.add(f),this.topics.push(u),this.emit("topic",u))}reconnect(u){this.reconnecting=!!u}ban(u){this.banned=!!u}shouldGC(){return!(this.banned||this.queued||this.explicit||this.waiting)}},wf}var bf,lv;function Ix(){return lv||(lv=1,bf=class{constructor(a,p){this._time=a,this._fn=p,this._interval=null,this._next=[],this._pending=[],this._destroyed=!1}destroy(){this._destroyed||(this._destroyed=!0,clearInterval(this._interval),this._interval=null)}_ontick(){!this._next.length&&!this._pending.length||(this._next.length&&this._fn(this._next),this._next=this._pending,this._pending=[])}add(a){this._destroyed||(this._interval||(this._interval=setInterval(this._ontick.bind(this),Math.floor(this._time*.66))),this._pending.push(a))}}),bf}var vf,cv;function Kx(){if(cv)return vf;cv=1;const n=Ix(),a=500,p=1e3+Math.round(a*Math.random()),l=5e3+Math.round(2*a*Math.random()),g=15e3+Math.round(4*a*Math.random()),y=1e3*60*10+Math.round(240*a*Math.random());return vf=class{constructor(o,{backoffs:c=[p,l,g,y],jitter:s=a}={}){this.jitter=s,this.backoffs=c,this._sTimer=new n(c[0]+Math.round(s*Math.random()),o),this._mTimer=new n(c[1]+Math.round(s*Math.random()),o),this._lTimer=new n(c[2]+Math.round(s*Math.random()),o),this._xTimer=new n(c[3]+Math.round(s*Math.random()),o)}_selectRetryTimer(o){if(o.banned||!o.reconnecting)return null;if(o.attempts>3)return o.explicit?this._xTimer:null;if(o.attempts===0)return this._sTimer;if(o.proven)switch(o.attempts){case 1:return this._sTimer;case 2:return this._mTimer;case 3:return this._lTimer}else switch(o.attempts){case 1:return this._mTimer;case 2:return this._lTimer;case 3:return this._lTimer}return null}add(o){const c=this._selectRetryTimer(o);return c?(c.add(o),!0):!1}destroy(){this._sTimer.destroy(),this._mTimer.destroy(),this._lTimer.destroy(),this._xTimer.destroy()}},vf}var kf,hv;function zx(){if(hv)return kf;hv=1;const n=Ue();return kf=class{constructor(){this._byPublicKey=new Map}[Symbol.iterator](){return this._byPublicKey.values()}get size(){return this._byPublicKey.size}has(p){return this._byPublicKey.has(n.toString(p,"hex"))}get(p){return this._byPublicKey.get(n.toString(p,"hex"))}add(p){this._byPublicKey.set(n.toString(p.remotePublicKey,"hex"),p)}delete(p){const l=n.toString(p.remotePublicKey,"hex");this._byPublicKey.get(l)===p&&this._byPublicKey.delete(l)}},kf}var Sf,uv;function Hx(){if(uv)return Sf;uv=1;const n=jt(),a=Ue(),p=1e3*60*10,l=1e3*60*2,g=1e3*30;Sf=class{constructor(s,u,{limit:f=1/0,wait:m=null,suspended:E=!1,onpeer:b=o,onerror:_=n}){this.limit=f,this.swarm=s,this.topic=u,this.isClient=!1,this.isServer=!1,this.destroyed=!1,this.destroying=null,this.suspended=E,this._sessions=[],this._clientSessions=0,this._serverSessions=0,this._onpeer=b,this._onerror=_,this._activeQuery=null,this._timer=null,this._currentRefresh=null,this._closestNodes=null,this._firstAnnounce=!0,this._needsUnannounce=!1,this._refreshes=0,this._wait=m}session({server:s=!0,client:u=!0,limit:f=1/0,onerror:m=n}){if(this.destroyed)throw new Error("PeerDiscovery is destroyed");const E=new y(this);return E.refresh({server:s,client:u,limit:f}).catch(m),this._sessions.push(E),E}_refreshLater(s){const u=Math.round(Math.random()*l),f=s?u:p+u;this._timer&&clearTimeout(this._timer);const m=Date.now();this._timer=setTimeout(()=>{Date.now()-m>f+g?this._refreshLater(!0):this.refresh().catch(this._onerror)},f)}_isActive(){return!this.destroyed&&!this.suspended}async _refresh(){if(this.suspended)return;const s=++this._refreshes;if(this._wait&&(await this._wait,this._wait=null,s!==this._refreshes||!this._isActive()))return;const u=this.isServer&&this._firstAnnounce;u&&(this._firstAnnounce=!1);const f={clear:u,closestNodes:this._closestNodes};if(this.isServer){if(await this.swarm.listen(),s!==this._refreshes||!this._isActive())return;this._needsUnannounce=!0}const m=this.isServer,E=this._activeQuery=m?this.swarm.dht.announce(this.topic,this.swarm.keyPair,this.swarm.server.relayAddresses,f):this._needsUnannounce?this.swarm.dht.lookupAndUnannounce(this.topic,this.swarm.keyPair,f):this.swarm.dht.lookup(this.topic,f);try{for await(const b of this._activeQuery)if(!(!this.isClient||!this._isActive()))for(const _ of b.peers){if(this.limit===0)return;this.limit--,this._onpeer(_,b)}}catch(b){if(this._isActive())throw b}finally{this._activeQuery===E&&(this._activeQuery=null,!this.destroyed&&!this.suspended&&this._refreshLater(!1))}this._closestNodes=E.closestNodes,s===this._refreshes&&(m||(this._needsUnannounce=!1))}async refresh(){if(this.destroyed)throw new Error("PeerDiscovery is destroyed");const s=this._serverSessions>0,u=this._clientSessions>0;if(this.suspended)return;if(s===this.isServer&&u===this.isClient){if(this._currentRefresh)return this._currentRefresh;this._currentRefresh=this._refresh()}else this._activeQuery&&this._activeQuery.destroy(),this.isServer=s,this.isClient=u,this._currentRefresh=this._refresh();const f=this._currentRefresh;try{await f}catch{return!1}finally{f===this._currentRefresh&&(this._currentRefresh=null)}return!0}async flushed(){this.swarm.listening&&await this.swarm.listening;try{return await this._currentRefresh,!0}catch{return!1}}async _destroyMaybe(){if(!this.destroyed)try{this._sessions.length===0?await this.swarm.leave(this.topic):this._serverSessions===0&&this._needsUnannounce&&await this.refresh()}catch(s){n(s)}}destroy(){return this.destroying?this.destroying:(this.destroying=this._destroy(),this.destroying)}async _abort(s){const u=s===o?"":a.toString(this.topic,"hex");s("Aborting discovery",u),this._wait&&await this._wait,s("Aborting discovery (post wait)",u),this._activeQuery&&(this._activeQuery.destroy(),this._activeQuery=null),this._timer&&(clearTimeout(this._timer),this._timer=null);let f=this._closestNodes;if(this._currentRefresh)try{await this._currentRefresh}catch{}if(s("Aborting discovery (post refresh)",u),!this._isActive()){if(!f)f=this._closestNodes;else if(this._closestNodes!==f){const m=f.length;for(const E of this._closestNodes)E.id&&!h(f,m,E)&&f.push(E)}this._needsUnannounce&&(s("Unannouncing discovery",u),f&&f.length&&await this.swarm.dht.unannounce(this.topic,this.swarm.keyPair,{closestNodes:f,onlyClosestNodes:!0,force:!0}),this._needsUnannounce=!1,s("Unannouncing discovery (done)",u))}}_destroy(){if(!this.destroyed)return this.destroyed=!0,this._abort(o)}async suspend({log:s=o}={}){if(!this.suspended){this.suspended=!0;try{await this._abort(s)}catch{}}}resume(){this.suspended&&(this.suspended=!1,this.refresh().catch(o))}};class y{constructor(s){this.discovery=s,this.isClient=!1,this.isServer=!1,this.destroyed=!1}get swarm(){return this.discovery.swarm}get topic(){return this.discovery.topic}async refresh({client:s=this.isClient,server:u=this.isServer,limit:f=1/0}={}){if(this.destroyed)throw new Error("PeerDiscovery is destroyed");if(!s&&!u)throw new Error("Cannot refresh with neither client nor server option");return s!==this.isClient&&(this.isClient=s,this.discovery._clientSessions+=s?1:-1),u!==this.isServer&&(this.isServer=u,this.discovery._serverSessions+=u?1:-1),this.discovery.limit=f,this.discovery.refresh()}async flushed(){return this.discovery.flushed()}async destroy(){if(this.destroyed)return;this.destroyed=!0,this.isClient&&this.discovery._clientSessions--,this.isServer&&this.discovery._serverSessions--;const s=this.discovery._sessions.indexOf(this),u=this.discovery._sessions.pop();return u!==this&&(this.discovery._sessions[s]=u),this.discovery._destroyMaybe()}}function h(c,s,u){for(let f=0;f<s;f++){const m=c[f];if(m.id&&a.equals(m.id,u.id))return!0}return!1}function o(){}return Sf}var xf,dv;function Fx(){if(dv)return xf;dv=1;const{EventEmitter:n}=nn,a=Mx(),p=Ox(),l=Ue(),g=Xt(),y=Px(),h=Kx(),o=zx(),c=Hx(),s=64,u=3,f=1/0,m=1/0,E="Topic is required and must be a 32-byte buffer",b="Swarm has been destroyed",_="Duplicate connection";xf=class extends n{constructor(v={}){super();const{seed:w,relayThrough:R,keyPair:A=a.keyPair(w),maxPeers:q=s,maxClientConnections:U=f,maxServerConnections:T=m,maxParallel:Q=u,firewall:le=M}=v;this.keyPair=A,this.dht=v.dht||new a({bootstrap:v.bootstrap,nodes:v.nodes,port:v.port}),this.server=this.dht.createServer({firewall:this._handleFirewall.bind(this),relayThrough:this._maybeRelayConnection.bind(this)},this._handleServerConnection.bind(this)),this.destroyed=!1,this.suspended=!1,this.maxPeers=q,this.maxClientConnections=U,this.maxServerConnections=T,this.maxParallel=Q,this.relayThrough=R||null,this.connecting=0,this.connections=new Set,this.peers=new Map,this.explicitPeers=new Set,this.listening=null,this.stats={updates:0,connects:{client:{opened:0,closed:0,attempted:0},server:{opened:0,closed:0}}},this._discovery=new Map,this._timer=new h(this._requeue.bind(this),{backoffs:v.backoffs,jitter:v.jitter}),this._queue=p(),this._allConnections=new o,this._pendingFlushes=[],this._flushTick=0,this._drainingQueue=!1,this._clientConnections=0,this._serverConnections=0,this._firewall=le,this.dht.on("network-change",this._handleNetworkChange.bind(this)),this.on("update",this._handleUpdate)}_maybeRelayConnection(v){return this.relayThrough?this.relayThrough(v):null}_enqueue(v){v.queued||(v.queued=!0,v._flushTick=this._flushTick,this._queue.add(v),this._attemptClientConnections())}_requeue(v){if(!this.suspended){for(const w of v)w.waiting=!1,!(w._updatePriority()===!1||this._allConnections.has(w.publicKey)||w.queued)&&(w.queued=!0,w._flushTick=this._flushTick,this._queue.add(w));this._attemptClientConnections()}}_flushMaybe(v){for(let w=0;w<this._pendingFlushes.length;w++){const R=this._pendingFlushes[w];v._flushTick>R.tick||--R.missing>0||(R.onflush(!0),this._pendingFlushes.splice(w--,1))}}_flushAllMaybe(){if(this.connecting>0||this._allConnections.size<this.maxPeers&&this._clientConnections<this.maxClientConnections)return!1;for(;this._pendingFlushes.length;)this._pendingFlushes.pop().onflush(!0);return!0}_shouldConnectExplicit(){return!this.destroyed&&!this.suspended&&this.connecting<this.maxParallel}_shouldConnect(){return!this.destroyed&&!this.suspended&&this.connecting<this.maxParallel&&this._allConnections.size<this.maxPeers&&this._clientConnections<this.maxClientConnections}_shouldRequeue(v){if(this.suspended)return!1;if(v.explicit)return!0;for(const w of v.topics)if(this._discovery.has(l.toString(w,"hex"))&&!this.destroyed)return!0;return!1}_connect(v,w){if(v.banned||this._allConnections.has(v.publicKey)){w&&this._flushMaybe(v);return}if(this._handleFirewall(v.publicKey,null)){v.ban(!0),w&&this._flushMaybe(v);return}const R=this._maybeRelayConnection(v.forceRelaying),A=this.dht.connect(v.publicKey,{relayAddresses:v.relayAddresses,keyPair:this.keyPair,relayThrough:R});this._allConnections.add(A),this.stats.connects.client.attempted++,this.connecting++,this._clientConnections++;let q=!1;const U=T=>{this.relayThrough&&z(T.code)&&(v.forceRelaying=!0,v.attempts=0)};A.on("error",U),A.on("open",()=>{q=!0,this.stats.connects.client.opened++,this._connectDone(),this.connections.add(A),A.removeListener("error",U),v._connected(),v.client=!0,this.emit("connection",A,v),w&&this._flushMaybe(v),this.emit("update")}),A.on("close",()=>{q||this._connectDone(),this.stats.connects.client.closed++,this.connections.delete(A),this._allConnections.delete(A),this._clientConnections--,v._disconnected(),v.waiting=this._shouldRequeue(v)&&this._timer.add(v),this._maybeDeletePeer(v),!q&&w&&this._flushMaybe(v),this._attemptClientConnections(),this.emit("update")}),this.emit("update")}_connectDone(){this.connecting--,this.connecting<this.maxParallel&&this._attemptClientConnections(),this.connecting===0&&this._flushAllMaybe()}_attemptClientConnections(){if(!this._drainingQueue){this._drainingQueue=!0;for(const v of this.explicitPeers){if(!this._shouldConnectExplicit())break;v.attempts>=5||Date.now()-v.disconnectedTime<v.attempts*1e3||this._connect(v,!1)}for(;this._queue.length&&this._shouldConnect();){const v=this._queue.shift();v.queued=!1,this._connect(v,!0)}this._drainingQueue=!1,this.connecting===0&&this._flushAllMaybe()}}_handleFirewall(v,w){if(this.suspended||l.equals(v,this.keyPair.publicKey))return!0;const R=this.peers.get(l.toString(v,"hex"));return R&&R.banned?!0:this._firewall(v,w)}_handleServerConnectionSwap(v,w){let R=!1;v.on("close",()=>{R||(w.removeListener("error",B),w.removeListener("close",A),this._handleServerConnection(w))}),w.on("error",B),w.on("close",A);function A(){R=!0}}_handleServerConnection(v){if(this.destroyed||this.suspended)return v.on("error",B),v.destroy(b);const w=this._allConnections.get(v.remotePublicKey);if(w){const A=w.rawBytesRead>0&&w.rawBytesWritten>0,q=l.compare(v.publicKey,v.remotePublicKey)>0;if((A||q===v.isInitiator)===!1){w.sendKeepAlive(),v.on("error",B),v.destroy(new Error(_));return}w.on("error",B),w.destroy(new Error(_)),this._handleServerConnectionSwap(w,v);return}this.stats.connects.server.opened++;const R=this._upsertPeer(v.remotePublicKey,null);this.connections.add(v),this._allConnections.add(v),this._serverConnections++,v.on("close",()=>{this.connections.delete(v),this._allConnections.delete(v),this._serverConnections--,this.stats.connects.server.closed++,this._maybeDeletePeer(R),this._attemptClientConnections(),this.emit("update")}),R.client=!1,this.emit("connection",v,R),this.emit("update")}_upsertPeer(v,w){if(l.equals(v,this.keyPair.publicKey))return null;const R=l.toString(v,"hex");let A=this.peers.get(R);return A?(A.relayAddresses=w,A):(A=new y({publicKey:v,relayAddresses:w}),this.peers.set(R,A),A)}_handleUpdate(){this.stats.updates++}_maybeDeletePeer(v){if(!v.shouldGC()||this._allConnections.has(v.publicKey))return;const R=l.toString(v.publicKey,"hex");this.peers.delete(R)}_handlePeer(v,w){const R=this._upsertPeer(v.publicKey,v.relayAddresses);R&&R._topic(w),!(!R||this._allConnections.has(v.publicKey))&&((!R.prioritized||R.server)&&R._reset(),R._updatePriority()&&this._enqueue(R))}async _handleNetworkChange(){for(const w of this._allConnections)w.sendKeepAlive();const v=[];for(const w of this._discovery.values())v.push(w.refresh());await Promise.allSettled(v)}status(v){return this._discovery.get(l.toString(v,"hex"))||null}listen(){return this.listening||(this.listening=this.server.listen(this.keyPair)),this.listening}join(v,w={}){if(!v)throw new Error(E);v=g(v);const R=l.toString(v,"hex");let A=this._discovery.get(R);return A&&!A.destroyed||(A=new c(this,v,{limit:w.limit,wait:A?A.destroy():null,suspended:this.suspended,onpeer:q=>this._handlePeer(q,v)}),this._discovery.set(R,A)),A.session(w)}async leave(v){if(!v)throw new Error(E);const w=l.toString(v,"hex");if(!this._discovery.has(w))return Promise.resolve();const R=this._discovery.get(w);try{await R.destroy()}catch{}this._discovery.get(w)===R&&this._discovery.delete(w)}joinPeer(v){const w=this._upsertPeer(v,null);w&&(this.explicitPeers.has(w)||(w.explicit=!0,this.explicitPeers.add(w)),!this._allConnections.has(v)&&w._updatePriority()&&this._enqueue(w))}leavePeer(v){const w=l.toString(v,"hex");if(!this.peers.has(w))return;const R=this.peers.get(w);R.explicit=!1,this.explicitPeers.delete(R),this._maybeDeletePeer(R)}async flush(){const v=[...this._discovery.values()].map(R=>R.flushed());if(await Promise.all(v),this._flushAllMaybe())return!0;const w=this._allConnections.size-this.connections.size;return!this._queue.length&&!w?!0:new Promise(R=>{this._pendingFlushes.push({onflush:R,missing:this._queue.length+w,tick:this._flushTick++})})}async clear(){const v=Promise.allSettled([...this._discovery.values()].map(w=>w.destroy()));return this._discovery.clear(),v}async destroy({force:v}={}){if(!(this.destroyed&&!v)){for(this.destroyed=!0,this._timer.destroy(),v||await this.clear(),await this.server.close();this._pendingFlushes.length;)this._pendingFlushes.pop().onflush(!1);await this.dht.destroy({force:v})}}async suspend({log:v=B}={}){if(this.suspended)return;const w=[];w.push(this.server.suspend({log:v}));for(const R of this._discovery.values())w.push(R.suspend({log:v}));for(const R of this._allConnections)R.destroy();this.suspended=!0,v("Suspending server and discovery... ("+w.length+")"),await Promise.allSettled(w),v("Done, suspending the dht..."),await this.dht.suspend({log:v}),v("Done, swarm fully suspended")}async resume({log:v=B}={}){if(this.suspended){v("Resuming the dht"),await this.dht.resume(),v("Done, resuming the server"),await this.server.resume(),v("Done, all discovery");for(const w of this._discovery.values())w.resume();this._attemptClientConnections(),this.suspended=!1}}topics(){return this._discovery.values()}};function B(){}function M(){return!1}function z(j){return j==="HOLEPUNCH_ABORTED"||j==="HOLEPUNCH_DOUBLE_RANDOMIZED_NATS"||j==="REMOTE_NOT_HOLEPUNCHABLE"}return xf}var Vx=Fx();const Ef=ti(Vx);var Af,fv;function jx(){return fv||(fv=1,Af=async function*(a,{dryRun:p=!1}={}){for await(const{discoveryKey:l}of a.storage.createCoreStream()){const g=a.get({discoveryKey:l,active:!1});await g.ready(),yield{discoveryKey:l,key:g.key,audit:await g.core.audit({dryRun:p})};try{await g.close()}catch{}}}),Af}var Rf,gv;function Gx(){if(gv)return Rf;gv=1;const n=Ue(),a=Wf(),p=Rn(),l=sn(),g=_t(),y=ol(),{isAndroid:h}=zv(),{STORAGE_EMPTY:o}=Lt(),c=jx(),[s]=g.namespace("corestore",1),u=n.alloc(32);class f{constructor(){this.records=[]}add(A,q){const U={index:0,stream:A,isExternal:q};return U.index=this.records.push(U)-1,U}remove(A){const q=this.records.pop();q!==A&&(this.records[q.index=A.index]=q)}attachAll(A){for(let q=0;q<this.records.length;q++){const T=this.records[q].stream.noiseStream.userData;A.replicator.attached(T)||A.replicator.attachTo(T)}}destroy(){for(let A=this.records.length-1;A>=0;A--){const q=this.records[A];q.isExternal||q.stream.destroy()}}}class m{constructor(){this.map=new Map}get size(){return this.map.size}get(A){const q=this.map.get(A);if(q!==void 0)return q;const U=[];return this.map.set(A,U),U}gc(A){this.map.delete(A)}list(A){return A?this.map.get(A)||[]:[...this]}*[Symbol.iterator](){for(const A of this.map.values())yield*A[Symbol.iterator]()}}class E{constructor(){this.map=new Map,this.watching=[],this._gcing=new Set,this._gcInterval=null,this._gcCycleBound=this._gcCycle.bind(this)}get size(){return this.map.size}watch(A){A.watchIndex===-1&&(A.watchIndex=this.watching.push(A)-1)}unwatch(A){if(A.watchIndex===-1)return;const q=this.watching.pop();q!==A&&(this.watching[q.watchIndex=A.watchIndex]=q),A.watchIndex=-1}resume(A){const q=this.map.get(A);return q?(q.closing||q.gc&&(this._gcing.delete(q),this._gcing.size===0&&this._stopGC(),q.gc=0),q):null}opened(A){const q=this.map.get(A);return!!(q&&q.opened&&!q.closing)}get(A){n.isBuffer(A)&&(A=n.toString(A,"hex"));const q=this.map.get(A);return!q||q.closing?null:q}set(A,q){this.map.set(A,q),this.watching.length>0&&this._emit(q)}_emit(A){for(let q=this.watching.length-1;q>=0;q--){const U=this.watching[q];for(const T of U.watchers)T(A)}}_gc(A){const q=w(A.discoveryKey);this.map.get(q)===A&&this.map.delete(q)}_gcCycle(){for(const A of this._gcing){if(++A.gc<4)continue;const q=this._gc.bind(this,A);A.close().then(q,q),this._gcing.delete(A)}this._gcing.size===0&&this._stopGC()}gc(A){A.gc=1,this._gcing.add(A),this._gcing.size===1&&this._startGC()}_stopGC(){clearInterval(this._gcInterval),this._gcInterval=null}_startGC(){this._gcInterval||(this._gcInterval=setInterval(this._gcCycleBound,2e3),this._gcInterval.unref&&this._gcInterval.unref())}close(){this._stopGC(),this._gcing.clear();const A=[];for(const q of this.map.values())q.onidle=v,A.push(q.close());return this.map.clear(),Promise.all(A)}*[Symbol.iterator](){for(const A of this.map.values())A.closing||(yield A)}}class b{constructor(){this.count=0,this.pending=[]}add(A){this.count!==0&&this.pending.push(A.findingPeers())}inc(A){if(++this.count===1)for(const q of A)this.pending.push(q.findingPeers())}dec(A){if(--this.count===0)for(;this.pending.length>0;)this.pending.pop()()}}class _ extends p{constructor(A,q={}){super(),this.root=q.root||null,this.storage=this.root?this.root.storage:a.defaultStorage(A,{id:q.id,allowBackup:q.allowBackup}),this.streamTracker=this.root?this.root.streamTracker:new f,this.cores=this.root?this.root.cores:new E,this.sessions=new m,this.corestores=this.root?this.root.corestores:new Set,this.readOnly=q.writable===!1,this.globalCache=this.root?this.root.globalCache:q.globalCache||null,this.primaryKey=this.root?this.root.primaryKey:q.primaryKey||null,this.ns=q.namespace||u,this.manifestVersion=q.manifestVersion||1,this.shouldSuspend=h?!!q.suspend:q.suspend!==!1,this.active=q.active!==!1,this.watchers=null,this.watchIndex=-1,this._findingPeers=null,this._ongcBound=this._ongc.bind(this),this.root&&this.corestores.add(this),this.ready().catch(v)}watch(A){this.watchers===null&&(this.watchers=new Set,this.cores.watch(this)),this.watchers.add(A)}unwatch(A){this.watchers!==null&&(this.watchers.delete(A),this.watchers.size===0&&(this.watchers=null,this.cores.unwatch(this)))}findingPeers(){this._findingPeers===null&&(this._findingPeers=new b),this._findingPeers.inc(this.sessions);let A=!1;return()=>{A||(A=!0,this._findingPeers.dec(this.sessions))}}audit(A={}){return c(this,A)}async suspend({log:A=v}={}){await A("Flushing db..."),await this.storage.db.flush(),this.shouldSuspend&&(await A("Suspending db..."),await this.storage.db.suspend())}resume(){return this.storage.db.resume()}session(A){this._maybeClosed();const q=this.root||this;return new _(null,{manifestVersion:this.manifestVersion,...A,root:q})}namespace(A,q){return this.session({...q,namespace:M(this.ns,A)})}list(A){return this.storage.createDiscoveryKeyStream(A)}getAuth(A){return this.storage.getAuth(A)}_ongc(A){A.sessions.length===0&&this.sessions.gc(A.id)}async _getOrSetSeed(){const A=await this.storage.getSeed();return A!==null?A:await this.storage.setSeed(this.primaryKey||g.randomBytes(32))}async _open(){if(this.root!==null){this.root.opened===!1&&await this.root.ready(),this.primaryKey=this.root.primaryKey;return}const A=await this._getOrSetSeed();if(this.primaryKey===null){this.primaryKey=A;return}if(!n.equals(A,this.primaryKey))throw new Error("Another corestore is stored here")}async _close(){const A=[],q=[...this.sessions];for(const U of q)A.push(U.close());if(this.watchers!==null&&this.cores.unwatch(this),this.root!==null){await Promise.all(A);return}for(const U of this.corestores)A.push(U.close());await Promise.all(A),await this.cores.close(),await this.storage.close()}async _attachMaybe(A,q){if(this.opened===!1&&await this.ready(),!this.cores.opened(w(q))&&!await this.storage.has(q,{ifMigrated:!0})||this.closing)return;const U=this._openCore(q,{createIfMissing:!1});U&&(U.opened||await U.ready(),U.replicator.attached(A)||U.replicator.attachTo(A),U.checkIfIdle())}replicate(A,q){this._maybeClosed();const U=B(A),T=a.createProtocolStream(A,{...q,ondiscoverykey:le=>{if(this.closing)return;const Y=T.noiseStream.userData;return this._attachMaybe(Y,le)}});if(this.cores.size>0){const le=T.noiseStream.userData,Y=le.uncork.bind(le);le.cork();for(const oe of this.cores)!oe.replicator.downloading||oe.replicator.attached(le)||!oe.opened||!this.active||oe.replicator.attachTo(le);T.noiseStream.opened.then(Y)}const Q=this.streamTracker.add(T,U);return T.once("close",()=>this.streamTracker.remove(Q)),T}_maybeClosed(){if(this.closing||this.root!==null&&this.root.closing)throw new Error("Corestore is closed")}get(A){this._maybeClosed(),(n.isBuffer(A)||typeof A=="string")&&(A={key:A}),A||(A={});const q={preload:null,sessions:null,ongc:null,core:null,active:A.active!==!1,encryption:A.encryption||null,encryptionKey:A.encryptionKey||null,isBlockKey:!!A.isBlockKey,valueEncoding:A.valueEncoding||null,exclusive:!!A.exclusive,manifest:A.manifest||null,keyPair:A.keyPair||null,onwait:A.onwait||null,wait:A.wait!==!1,timeout:A.timeout||0,draft:!!A.draft,writable:A.writable===void 0&&this.readOnly?!1:A.writable};if(A.name||A.preload)return q.preload=this._preload(A),this._makeSession(q);if(A.discoveryKey&&!A.key&&!A.manifest)return q.preload=this._preloadCheckIfExists(A),this._makeSession(q);const U=this._openCore(null,A);return q.core=U,q.sessions=this.sessions.get(U.id),q.ongc=this._ongcBound,this._makeSession(q)}_makeSession(A){const q=new a(null,null,A);return this._findingPeers!==null&&this._findingPeers.add(q),q}async createKeyPair(A,q=this.ns){return this.opened===!1&&await this.ready(),j(this.primaryKey,q,A)}async _preloadCheckIfExists(A){if(!await this.storage.has(A.discoveryKey))throw o("No Hypercore is stored here");return this._preload(A)}async _preload(A){A.preload&&(A={...A,...await A.preload}),this.opened===!1&&await this.ready();const q=A.name?await this.storage.getAlias({name:A.name,namespace:this.ns}):null;this._maybeClosed();const U=this._openCore(q,A);return{core:U,sessions:this.sessions.get(U.id),ongc:this._ongcBound,encryption:A.encryption||null,encryptionKey:A.encryptionKey||null,isBlockKey:!!A.isBlockKey}}_auth(A,q){const U={keyPair:null,key:null,discoveryKey:A,manifest:null};if(q.name?U.keyPair=j(this.primaryKey,this.ns,q.name):q.keyPair&&(U.keyPair=q.keyPair),q.manifest?U.manifest=q.manifest:U.keyPair&&!U.discoveryKey&&(U.manifest={version:this.manifestVersion,signers:[{publicKey:U.keyPair.publicKey}]}),q.key?U.key=y.decode(q.key):U.manifest&&(U.key=a.key(U.manifest)),U.discoveryKey)return U;if(q.discoveryKey)U.discoveryKey=y.decode(q.discoveryKey);else if(U.key)U.discoveryKey=g.discoveryKey(U.key);else throw new Error("Could not derive discovery from input");return U}_openCore(A,q){const U=this._auth(A,q),T=w(U.discoveryKey),Q=this.cores.resume(T);if(Q&&!Q.closing)return Q;const le=a.createCore(this.storage,{preopen:Q&&Q.opened?Q.closing:null,eagerUpgrade:!0,notDownloadingLinger:q.notDownloadingLinger,allowFork:q.allowFork!==!1,inflightRange:q.inflightRange,compat:!1,force:q.force,createIfMissing:q.createIfMissing,discoveryKey:U.discoveryKey,overwrite:q.overwrite,key:U.key,keyPair:U.keyPair,legacy:q.legacy,manifest:U.manifest,globalCache:q.globalCache||this.globalCache||null,alias:q.name?{name:q.name,namespace:this.ns}:null});return le.onidle=()=>{this.cores.gc(le)},le.replicator.ondownloading=()=>{this.active&&this.streamTracker.attachAll(le)},this.cores.set(T,le),le}}Rf=_;function B(R){return typeof R=="object"&&R&&typeof R.pipe=="function"}function M(R,A){n.isBuffer(A)||(A=n.from(A));const q=n.allocUnsafeSlow(32);return l.crypto_generichash_batch(q,[R,A]),q}function z(R,A,q){n.isBuffer(q)||(q=n.from(q));const U=n.alloc(32);return l.crypto_generichash_batch(U,[s,A,q],R),U}function j(R,A,q){const U=z(R,A,q),T=n.alloc(l.crypto_sign_PUBLICKEYBYTES+l.crypto_sign_SECRETKEYBYTES),Q={publicKey:T.subarray(0,l.crypto_sign_PUBLICKEYBYTES),secretKey:T.subarray(l.crypto_sign_PUBLICKEYBYTES)};return l.crypto_sign_seed_keypair(Q.publicKey,Q.secretKey,U),Q}function v(){}function w(R){return n.toString(R,"hex")}return Rf}var Yx=Gx();const el=ti(Yx);var Wx=_t();const cs=ti(Wx);var Qx=Ue();const We=ti(Qx);var Xx=Qf();const Zx=ti(Xx);function Lf(n){return new Zx(n.get({name:"hyperbee-view"}),{keyEncoding:"utf-8",valueEncoding:"json"})}async function Tf(n,a,p){for(const l of n){const{value:g}=l;if(g)try{switch(g.type){case"PUBLISH_DRIVE":await a.put(`/drives/${g.driveKey}`,{key:g.driveKey,topic:g.topic,owner:{id:l.from?We.toString(l.from.key,"hex"):g.metadata.ownerId,name:g.metadata.ownerName||"Unknown"},name:g.metadata.name,description:g.metadata.description||"",categories:g.metadata.categories||[],tags:g.metadata.tags||[],stats:g.metadata.stats,files:g.files,publishedAt:g.timestamp,verified:!1});for(const o of g.files){const c=o.name.toLowerCase(),s=cs.randomBytes(16).toString("hex");await a.put(`/search/files/${c}/${s}`,{ref:`/files/${g.driveKey}/${o.path}`}),await a.put(`/files/${g.driveKey}/${o.path}`,{...o,driveKey:g.driveKey})}break;case"UNPUBLISH_DRIVE":const y=await a.get(`/drives/${g.driveKey}`);if(y){for(const o of y.value.files){const s=`/search/files/${o.name.toLowerCase()}/`;for await(const{key:u}of a.createReadStream({gt:s,lt:s+"~"}))await a.del(u);await a.del(`/files/${g.driveKey}/${o.path}`)}await a.del(`/drives/${g.driveKey}`)}break;case"ADD_ADMIN":if(await a.put(`/admins/${g.writerKey}`,{key:g.writerKey,name:g.name,addedAt:g.timestamp,founder:g.founder||!1,adminPublicKey:g.adminPublicKey}),await a.put(`/admin-registry/${g.writerKey}`,{key:g.writerKey,name:g.name,addedAt:g.timestamp,founder:g.founder||!1,adminPublicKey:g.adminPublicKey}),!g.founder&&p.addWriter)try{await p.addWriter(We.from(g.writerKey,"hex"),{indexer:!0})}catch(o){console.error("Failed to add writer:",o)}break;case"VERIFY_DRIVE":const h=await a.get(`/drives/${g.driveKey}`);h?.value&&await a.put(`/drives/${g.driveKey}`,{...h.value,verified:!0,verifiedBy:l.from?We.toString(l.from.key,"hex"):"system",verifiedAt:g.timestamp});break}}catch(y){console.error("Apply error:",y)}}}function $x(n,a,p="New Member"){if(a==="admin"&&!n.adminKeypair)throw console.error("Admin keypair is missing for invite creation"),new Error("Cannot create admin invite without an admin keypair.");const l={network:n.key,name:n.name,role:a,adminAuth:null};if(a==="admin"){const g=We.toString(n.adminKeypair.publicKey,"hex"),y={network:n.key,name:n.name,inviter:We.toString(n.autobase.local.key,"hex"),inviteeName:p,role:"admin",timestamp:Date.now()},h=We.from(JSON.stringify(y)),o=cs.sign(h,n.adminKeypair.secretKey);l.adminAuth={message:y,signature:We.toString(o,"hex"),adminPublicKey:g}}return We.toString(We.from(JSON.stringify(l)),"base64")}function Jx(n){if(!n||typeof n!="string")return"application/octet-stream";const a=n.split(".").pop().toLowerCase();return{mkv:"video/x-matroska",mp4:"video/mp4",avi:"video/x-msvideo",mp3:"audio/mpeg",flac:"audio/flac",pdf:"application/pdf",zip:"application/zip",txt:"text/plain",md:"text/markdown",json:"application/json"}[a]||"application/octet-stream"}class eE{constructor(){this.networks=new Map,this.activeNetwork=null,this.ready=!1,this.storagePath=null,this.localStore=null,this.networksCore=null,this.driveCache=new Map,this.drivesListCache=null,this.cacheTimeout=null}async init(){console.log("HyperShareNetwork.init() called"),this.storagePath=Pear.config.storage,console.log("Storage path from Pear.config.storage:",this.storagePath),await this.initLocalStorage(),await this.loadSavedNetworks(),this.ready=!0,console.log("HyperShareNetwork initialization complete. Ready:",this.ready),console.log("Networks loaded:",this.networks.size),console.log("Active network:",this.activeNetwork?this.activeNetwork.name:"None")}async initLocalStorage(){try{console.log("Initializing local hypercore storage..."),console.log("Storage path:",this.storagePath);const a=Kt.join(this.storagePath,"local-networks");console.log("Local storage path:",a),this.localStore=new el(a),this.networksCore=this.localStore.get({name:"networks"}),await this.networksCore.ready(),console.log("Local hypercore storage initialized successfully"),console.log("Networks core length:",this.networksCore.length)}catch(a){console.error("Failed to initialize local storage:",a),this.localStore=null,this.networksCore=null}}async createNetwork(a,p){const l=Kt.join(this.storagePath,"networks",cs.randomBytes(16).toString("hex")),g=new el(l),y=new Nd(g,null,{apply:Tf,open:Lf,valueEncoding:"json"});await y.ready(),await y.view.ready();const h=new Ef;Pear.teardown(()=>h.destroy()),h.on("connection",f=>{console.log("[Swarm] Connection established"),g.replicate(f),y.replicate(f),f.on("error",m=>console.error("[Swarm] Connection error:",m))}),h.on("update",()=>{console.log("[Swarm] Swarm updated, topics:",Array.from(h.topics.keys()).map(f=>f.toString("hex")))}),h.join(y.discoveryKey,{server:!0,client:!0});const o=cs.keyPair(),c=We.toString(o.publicKey,"hex");await y.append({type:"ADD_ADMIN",writerKey:We.toString(y.local.key,"hex"),name:"Founder",founder:!0,timestamp:Date.now(),adminPublicKey:c});const s=new Ja(g.namespace("user-drive"));await s.ready(),h.join(s.discoveryKey,{server:!0,client:!0});const u={key:We.toString(y.key,"hex"),name:a,description:p,role:"admin",autobase:y,store:g,swarm:h,userDrive:s,storage:l,created:Date.now(),adminKeypair:o};return this.networks.set(u.key,u),this.activeNetwork=u,await this.saveNetworkInfo(u),this.startWriterAdditionMonitoring(u),{network:u,adminInvite:this.createInvite(u,"admin"),readerInvite:this.createInvite(u,"reader")}}createInvite(a,p,l="New Member"){if(p==="admin"&&(!a.adminKeypair||a.role!=="admin"))throw console.error("Cannot create admin invite: network role is",a.role,"and adminKeypair exists:",!!a.adminKeypair),new Error("Cannot create admin invite: insufficient permissions or missing admin keypair");return $x(a,p,l)}isAdminWriter(){return!this.activeNetwork||this.activeNetwork.role!=="admin"?!1:this.activeNetwork.autobase.writable}getAdminStatus(){if(!this.activeNetwork)return{isAdmin:!1,canWrite:!1,message:"No active network"};const a=this.activeNetwork.role==="admin",p=this.activeNetwork.autobase.writable;let l="";return a&&p?l="Full admin access":a&&!p?l="Admin (can create invites, but cannot publish/unpublish drives)":l="Reader access",{isAdmin:a,canWrite:p,message:l}}getLocalKey(){return this.activeNetwork?We.toString(this.activeNetwork.autobase.local.key,"hex"):null}async joinNetwork(a){try{const p=JSON.parse(We.toString(We.from(a,"base64")));if(this.networks.has(p.network))throw new Error("You are already a member of this network");const l=Kt.join(this.storagePath,"networks",cs.randomBytes(16).toString("hex")),g=new el(l),y=new Ef;Pear.teardown(()=>y.destroy());const h=new Nd(g,We.from(p.network,"hex"),{apply:Tf,open:Lf,valueEncoding:"json"});await h.ready(),await h.view.ready(),y.on("connection",s=>{console.log("[Swarm] Connection established"),g.replicate(s),h.replicate(s),s.on("error",u=>console.error("[Swarm] Connection error:",u))}),y.on("update",()=>{console.log("[Swarm] Swarm updated, topics:",Array.from(y.topics.keys()).map(s=>s.toString("hex")))}),y.join(h.discoveryKey,{server:!0,client:!0});const o=new Ja(g.namespace("user-drive"));await o.ready(),y.join(o.discoveryKey,{server:!0,client:!0});const c={key:We.toString(h.key,"hex"),name:p.name,role:"reader",autobase:h,store:g,swarm:y,userDrive:o,storage:l,created:Date.now(),pendingAdminAuth:p.role==="admin"?p.adminAuth:null};return this.networks.set(c.key,c),this.activeNetwork=c,c.pendingAdminAuth&&this.listenForAdminPromotion(c),await this.saveNetworkInfo(c),c}catch(p){throw console.error("Failed to join network:",p),new Error("Invalid invite code")}}listenForAdminPromotion(a){const p=async()=>{if(!a.pendingAdminAuth){a.autobase.removeListener("update",p);return}await this.processAdminAuthorization(a)&&a.autobase.removeListener("update",p)};a.autobase.on("update",p),p()}async processAdminAuthorization(a){if(!a.pendingAdminAuth)return!1;const{message:p,signature:l,adminPublicKey:g}=a.pendingAdminAuth,y=a.autobase.view;try{await a.autobase.update();const h=await this.getAdminRegistry(y);if(h.length===0)return!1;const o=We.from(JSON.stringify(p)),c=We.from(l,"hex");let s=!1;for(const u of h)if(u.adminPublicKey===g){const f=We.from(u.adminPublicKey,"hex");if(cs.verify(o,c,f)){s=!0;break}}if(s){console.log("Admin authorization successful, promoting user to admin"),a.role="admin",a.pendingAdminAuth=null,a.adminKeypair=cs.keyPair();const u=We.toString(a.adminKeypair.publicKey,"hex");console.log("Generated admin keypair for promoted user"),console.log("New admin public key:",u);try{await a.autobase.append({type:"ADD_ADMIN",writerKey:We.toString(a.autobase.local.key,"hex"),name:p.inviteeName||"New Admin",founder:!1,timestamp:Date.now(),adminPublicKey:u}),console.log("Successfully added admin to registry")}catch{console.log("Expected error: Admin not yet a writer, will be added by existing writers")}const f=We.toString(a.autobase.local.key,"hex");return await this.requestWriterAddition(a,f,p.inviteeName||"New Admin",u),await this.saveNetworkInfo(a),console.log("Admin role and keypair saved to network info"),typeof window<"u"&&window.dispatchEvent(new CustomEvent("role-updated",{detail:{role:"admin"}})),!0}return!1}catch(h){return console.error("Error processing admin authorization:",h),!1}}async requestWriterAddition(a,p,l,g){if(console.log("Requesting writer addition for:",l,p),this.networksCore){const h={type:"WRITER_REQUEST",networkKey:a.key,writerKey:p,name:l,adminPublicKey:g,timestamp:Date.now(),status:"pending"};try{await this.networksCore.append(JSON.stringify(h)),console.log("Writer request stored in local hypercore")}catch(o){console.error("Failed to store writer request:",o)}}const y=async()=>{if(a.autobase.writable&&(console.log("Admin has been granted writer access!"),a.autobase.removeListener("update",y),this.networksCore)){const h={type:"WRITER_STATUS_UPDATE",networkKey:a.key,writerKey:p,status:"granted",timestamp:Date.now()};try{await this.networksCore.append(JSON.stringify(h))}catch(o){console.error("Failed to update writer status:",o)}}};a.autobase.on("update",y),y()}async getAdminRegistry(a){const p=[];try{const l="/admins/";for await(const g of a.createReadStream({gt:l,lt:l+"~"}))g.value&&p.push(g.value)}catch(l){console.error("Error reading admin registry:",l)}return p}async getDriveStats(a){if(!this.activeNetwork)return null;const p=await this.getDrive(a);if(!p)return null;await p.update();const l={peers:p.core.peers.length,totalBlocks:p.core.length,downloadedBlocks:p.core.downloaded()};return p.blobs&&(await p.blobs.update(),l.totalBlocks+=p.blobs.core.length,l.downloadedBlocks+=p.blobs.core.downloaded()),l}async startWriterAdditionMonitoring(a){console.log("Starting writer addition monitoring for network:",a.name);const p=async()=>{if(a.autobase.writable)try{await a.autobase.update();const g=a.autobase.view,y=await this.getAdminRegistry(g);for(const h of y)!h.founder&&h.writerKey&&(await this.isAdminWriter(a,h.writerKey)||(console.log("Found non-writer admin:",h.name,h.writerKey),await this.addAdminAsWriter(a,h.writerKey,h.name)))}catch(g){console.error("Error in writer addition monitoring:",g)}},l=async()=>{if(!(!this.networksCore||!a.autobase.writable))try{const g=Math.max(0,this.networksCore.length-100);for(let y=g;y<this.networksCore.length;y++){const h=await this.networksCore.get(y);if(h){const o=JSON.parse(h.toString());o.type==="WRITER_REQUEST"&&o.networkKey===a.key&&o.status==="pending"&&(await this.isAdminWriter(a,o.writerKey)||(console.log("Processing writer request:",o.name,o.writerKey),await this.addAdminAsWriter(a,o.writerKey,o.name),await a.autobase.append({type:"ADD_ADMIN",writerKey:o.writerKey,name:o.name,founder:!1,timestamp:Date.now(),adminPublicKey:o.adminPublicKey}),console.log("Added promoted admin to registry:",o.name)))}}}catch(g){console.error("Error processing writer requests:",g)}};a.autobase.on("update",p),this.networksCore&&this.networksCore.on("append",l),p(),l()}async isAdminWriter(a,p){try{return(a.autobase.inputs||[]).some(g=>We.toString(g.key,"hex")===p)}catch(l){return console.error("Error checking if admin is writer:",l),!1}}async addAdminAsWriter(a,p,l){try{console.log("Adding admin as writer:",l,p),await a.autobase.addWriter(We.from(p,"hex"),{indexer:!0}),console.log("Successfully added admin as writer:",l)}catch(g){console.error("Failed to add admin as writer:",g)}}async getNetworkStats(){if(!this.activeNetwork)throw new Error("No active network");await this.activeNetwork.autobase.update();const a=this.activeNetwork.autobase.view;let p=0,l=0,g=0;if(a){const y="/drives/";for await(const h of a.createReadStream({gt:y,lt:y+"~"}))p++,l+=h.value.stats?.fileCount||0,g+=h.value.stats?.totalSize||0}return{drives:p,files:l,size:g,peers:this.activeNetwork.swarm.connections.size,swarm:this.getSwarmStats()}}getSwarmStats(){if(!this.activeNetwork)return null;const a=this.activeNetwork.swarm,p=a.stats;return{peers:a.connections.size,connecting:a.connecting,topics:a.topics.size,uploadedBytes:p?.totals?.uploadedBytes||0,downloadedBytes:p?.totals?.downloadedBytes||0}}async scanDrive(a){const p=[];try{for await(const l of a.list("/",{recursive:!0}))l.value&&!l.value.linkname&&p.push({path:l.key,name:l.key.split("/").pop(),size:l.value.blob?l.value.blob.byteLength:0,type:Jx(l.key),mtime:l.value.metadata?.mtime||Date.now()})}catch(l){console.error("Error scanning drive:",l)}return p}async publishDrive(a){if(!this.activeNetwork||this.activeNetwork.role!=="admin")throw new Error("Action not allowed");const p=this.activeNetwork,l=p.autobase.view,g=We.toString(p.autobase.local.key,"hex"),y=await l.get(`/admins/${g}`),h=y?y.value.name:"Anonymous",o=await this.scanDrive(p.userDrive);try{await p.autobase.append({type:"PUBLISH_DRIVE",driveKey:We.toString(p.userDrive.key,"hex"),topic:We.toString(p.userDrive.discoveryKey,"hex"),metadata:{...a,ownerId:g,ownerName:h,stats:{totalSize:o.reduce((c,s)=>c+s.size,0),fileCount:o.length}},files:o,timestamp:Date.now()}),console.log("Drive published successfully")}catch(c){throw c.message==="Not writable"?new Error("Cannot publish drive: You need to be added as a writer by an existing admin first"):c}}async unpublishDrive(a){if(!this.activeNetwork||this.activeNetwork.role!=="admin")throw new Error("Action not allowed");try{await this.activeNetwork.autobase.append({type:"UNPUBLISH_DRIVE",driveKey:a,timestamp:Date.now()}),console.log("Drive unpublished successfully")}catch(p){throw p.message==="Not writable"?new Error("Cannot unpublish drive: You need to be added as a writer by an existing admin first"):p}}async getMyDrives(){if(!this.activeNetwork)return[];await this.activeNetwork.autobase.update();const a=this.activeNetwork.autobase.view;if(!a)return[];const p=[],l=We.toString(this.activeNetwork.autobase.local.key,"hex"),g="/drives/";for await(const y of a.createReadStream({gt:g,lt:g+"~"}))y.value.owner.id===l&&p.push({key:y.key.replace(g,""),...y.value});return p}async uploadFile(a,p){if(!this.activeNetwork)throw new Error("No active network");await this.activeNetwork.userDrive.put(a,p)}createFileUploadStream(a){if(!this.activeNetwork)throw new Error("No active network");return this.activeNetwork.userDrive.createWriteStream(a)}async createFileDownloadStream(a,p){if(!this.activeNetwork)throw new Error("No active network");return(await this.getDrive(a)).createReadStream(p)}async deleteFile(a,p){if(!this.activeNetwork)throw new Error("No active network");const l=We.toString(this.activeNetwork.userDrive.key,"hex");if(a!==l)throw new Error("You can only delete files from your own drive");await this.activeNetwork.userDrive.del(p)}async browseDrives(a={},p=!1){if(!this.activeNetwork)return[];if(this.drivesListCache&&!p&&this.cacheTimeout>Date.now())return this.drivesListCache;typeof window<"u"&&window.dispatchEvent(new CustomEvent("loading-drives-start")),await this.activeNetwork.autobase.update();const l=this.activeNetwork.autobase.view;if(!l)return typeof window<"u"&&window.dispatchEvent(new CustomEvent("loading-drives-end")),[];const g=[],y="/drives/";for await(const h of l.createReadStream({gt:y,lt:y+"~"})){const o=h.value;a.verified&&!o.verified||a.category&&!o.categories?.includes(a.category)||g.push({key:h.key.replace(y,""),...o})}return this.drivesListCache=g,this.cacheTimeout=Date.now()+3e4,typeof window<"u"&&window.dispatchEvent(new CustomEvent("loading-drives-end")),g}async searchFiles(a,p={}){if(!this.activeNetwork)return[];await this.activeNetwork.autobase.update();const l=this.activeNetwork.autobase.view;if(!l)return[];const g=[],h=`/search/files/${a.toLowerCase()}`;for await(const o of l.createReadStream({gt:h,lt:h+"~"})){if(o.value.ref){const c=await l.get(o.value.ref);if(c?.value){const s=c.value;if(p.minSize&&s.size<p.minSize||p.maxSize&&s.size>p.maxSize)continue;g.push(s)}}if(g.length>=100)break}return g}async browseFiles(a,p="/"){if(!this.activeNetwork)return[];typeof window<"u"&&window.dispatchEvent(new CustomEvent("loading-files-start",{detail:{driveKey:a}}));const l=await this.getDrive(a),g=[];try{for await(const y of l.list(p,{recursive:!1})){if(y.key===p)continue;let h=y.key.slice(p.length);if(h.startsWith("/")&&(h=h.slice(1)),h.includes("/")){const o=h.split("/")[0],c=p==="/"?`/${o}`:`${p}/${o}`;g.find(s=>s.path===c)||g.push({path:c,name:o,size:0,isDirectory:!0,mtime:Date.now()})}else g.push({path:y.key,name:y.key.split("/").pop(),size:y.value.blob?y.value.blob.byteLength:0,isDirectory:!1,mtime:y.value.metadata?.mtime||Date.now()})}}catch(y){console.error("Error browsing files:",y)}finally{typeof window<"u"&&window.dispatchEvent(new CustomEvent("loading-files-end",{detail:{driveKey:a}}))}return g}async downloadFile(a,p){if(!this.activeNetwork)throw new Error("No active network");return await(await this.getDrive(a)).get(p)}async getDrive(a){const p=this.activeNetwork;if(!p)throw new Error("No active network");if(this.driveCache.has(a))return this.driveCache.get(a);const l=We.toString(p.userDrive.key,"hex");if(a===l)return p.userDrive;const g=We.from(a,"hex"),y=new Ja(p.store,g);return await y.ready(),p.swarm.join(y.discoveryKey,{server:!0,client:!0}),await y.update(),this.driveCache.set(a,y),y}async reannounceDrives(){if(this.activeNetwork){console.log("[Swarm] Re-announcing all known drives..."),this.activeNetwork.swarm.join(this.activeNetwork.autobase.discoveryKey);for(const a of this.driveCache.values())this.activeNetwork.swarm.join(a.discoveryKey);console.log("[Swarm] Re-announcement complete.")}}async waitForDriveSync(a,p=3e3){if(typeof window<"u"&&window.dispatchEvent(new CustomEvent("drive-sync-start",{detail:{driveKey:We.toString(a.key,"hex")}})),await a.update(),a.core.length>1&&a.core.contiguousLength===a.core.length){typeof window<"u"&&window.dispatchEvent(new CustomEvent("drive-sync-end",{detail:{driveKey:We.toString(a.key,"hex")}}));return}await new Promise(g=>{const y=setTimeout(g,p);a.core.once("download",()=>{clearTimeout(y),g()})}),typeof window<"u"&&window.dispatchEvent(new CustomEvent("drive-sync-end",{detail:{driveKey:We.toString(a.key,"hex")}}))}async saveNetworkInfo(a){const p={key:a.key,name:a.name,description:a.description,role:a.role,storage:a.storage,created:a.created,adminKeypair:a.adminKeypair?{publicKey:We.toString(a.adminKeypair.publicKey,"hex"),secretKey:We.toString(a.adminKeypair.secretKey,"hex")}:null};console.log("--- Saving Network Info ---"),console.log("Time:",new Date().toISOString()),console.log("Network Name:",p.name),console.log("Role being saved:",p.role),console.log("Admin Keypair exists:",!!p.adminKeypair),p.role==="admin"&&!p.adminKeypair&&(console.error("CRITICAL: Saving admin role without a keypair!"),console.trace()),console.log("--------------------------");const l=Kt.join(this.storagePath,"networks.json");let g=[];try{g=JSON.parse(await Kt.promises.readFile(l,"utf8"))}catch{}const y=g.findIndex(h=>h.key===a.key);y>=0?g[y]=p:g.push(p),await Kt.promises.writeFile(l,JSON.stringify(g,null,2))}async saveNetworkInfoToFile(a){const p=Kt.join(this.storagePath,"networks.json");let l=[];try{l=JSON.parse(await Kt.promises.readFile(p,"utf8"))}catch{}const g=l.findIndex(y=>y.key===a.key);g>=0?l[g]=a:l.push(a),await Kt.promises.writeFile(p,JSON.stringify(l,null,2))}async leaveNetwork(a){const p=this.networks.get(a);if(!p)return;await p.swarm.destroy(),await p.store.close(),this.networks.delete(a),this.activeNetwork&&this.activeNetwork.key===a&&(this.activeNetwork=this.networks.size>0?this.networks.values().next().value:null);const l=Kt.join(this.storagePath,"networks.json");let g=[];try{g=JSON.parse(await Kt.promises.readFile(l,"utf8"))}catch{}const y=g.filter(h=>h.key!==a);return await Kt.promises.writeFile(l,JSON.stringify(y,null,2)),this.activeNetwork}async loadSavedNetworks(){const a=Kt.join(this.storagePath,"networks.json");try{const p=JSON.parse(await Kt.promises.readFile(a,"utf8"));for(const l of p){const g=new el(l.storage),y=new Ef;Pear.teardown(()=>y.destroy());const h=new Nd(g,We.from(l.key,"hex"),{apply:Tf,open:Lf,valueEncoding:"json"});await h.ready(),await h.view.ready(),y.on("connection",s=>{g.replicate(s),h.replicate(s)}),y.join(h.discoveryKey,{server:!0,client:!0});const o=new Ja(g.namespace("user-drive"));await o.ready(),y.join(o.discoveryKey,{server:!0,client:!0});const c={key:l.key,name:l.name,description:l.description,storage:l.storage,created:l.created,autobase:h,store:g,swarm:y,userDrive:o,role:l.role||"reader",adminKeypair:null};if(c.role==="admin")if(l.adminKeypair)try{c.adminKeypair={publicKey:We.from(l.adminKeypair.publicKey,"hex"),secretKey:We.from(l.adminKeypair.secretKey,"hex")}}catch(s){console.error(`Corrupt admin keypair for "${l.name}". Downgrading to reader.`,s),c.role="reader"}else console.warn(`Network "${l.name}" has admin role but no saved keypair. Downgrading to reader.`),c.role="reader";this.networks.set(c.key,c)}}catch(p){p.code!=="ENOENT"&&console.error("Failed to load saved networks:",p)}}async loadNetworksFromHypercore(){const a=[];try{console.log("Loading networks from hypercore, length:",this.networksCore.length);for(let p=0;p<this.networksCore.length;p++){const l=await this.networksCore.get(p);if(l){const g=JSON.parse(l.toString());if(g.key&&g.name&&g.storage){console.log("Found network in hypercore:",g.name);const y=a.findIndex(h=>h.key===g.key);y>=0?a[y]=g:a.push(g)}}}}catch(p){console.error("Failed to load networks from hypercore:",p)}return console.log("Loaded",a.length,"networks from hypercore"),a}async loadNetworksFromFile(){const a=Kt.join(this.storagePath,"networks.json");try{return JSON.parse(await Kt.promises.readFile(a,"utf8"))}catch(p){return p.code!=="ENOENT"&&console.error("Failed to load networks from file:",p),[]}}}window.addEventListener("DOMContentLoaded",async()=>{try{console.log("Initializing HyperShare network...");const n=new eE;await n.init(),globalThis.window&&(window.hyperShare=n,console.log("HyperShare assigned to window.hyperShare")),Pear.updates(()=>Pear.reload()),console.log("HyperShare network ready")}catch(n){console.error("Failed to initialize HyperShare:",n)}});var Df={exports:{}},uo={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var pv;function tE(){if(pv)return uo;pv=1;var n=Symbol.for("react.transitional.element"),a=Symbol.for("react.fragment");function p(l,g,y){var h=null;if(y!==void 0&&(h=""+y),g.key!==void 0&&(h=""+g.key),"key"in g){y={};for(var o in g)o!=="key"&&(y[o]=g[o])}else y=g;return g=y.ref,{$$typeof:n,type:l,key:h,ref:g!==void 0?g:null,props:y}}return uo.Fragment=a,uo.jsx=p,uo.jsxs=p,uo}var yv;function nE(){return yv||(yv=1,Df.exports=tE()),Df.exports}var ke=nE(),Bf={exports:{}},Ye={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _v;function iE(){if(_v)return Ye;_v=1;var n=Symbol.for("react.transitional.element"),a=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),l=Symbol.for("react.strict_mode"),g=Symbol.for("react.profiler"),y=Symbol.for("react.consumer"),h=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),s=Symbol.for("react.memo"),u=Symbol.for("react.lazy"),f=Symbol.iterator;function m(se){return se===null||typeof se!="object"?null:(se=f&&se[f]||se["@@iterator"],typeof se=="function"?se:null)}var E={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},b=Object.assign,_={};function B(se,G,re){this.props=se,this.context=G,this.refs=_,this.updater=re||E}B.prototype.isReactComponent={},B.prototype.setState=function(se,G){if(typeof se!="object"&&typeof se!="function"&&se!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,se,G,"setState")},B.prototype.forceUpdate=function(se){this.updater.enqueueForceUpdate(this,se,"forceUpdate")};function M(){}M.prototype=B.prototype;function z(se,G,re){this.props=se,this.context=G,this.refs=_,this.updater=re||E}var j=z.prototype=new M;j.constructor=z,b(j,B.prototype),j.isPureReactComponent=!0;var v=Array.isArray,w={H:null,A:null,T:null,S:null,V:null},R=Object.prototype.hasOwnProperty;function A(se,G,re,W,$,S){return re=S.ref,{$$typeof:n,type:se,key:G,ref:re!==void 0?re:null,props:S}}function q(se,G){return A(se.type,G,void 0,void 0,void 0,se.props)}function U(se){return typeof se=="object"&&se!==null&&se.$$typeof===n}function T(se){var G={"=":"=0",":":"=2"};return"$"+se.replace(/[=:]/g,function(re){return G[re]})}var Q=/\/+/g;function le(se,G){return typeof se=="object"&&se!==null&&se.key!=null?T(""+se.key):G.toString(36)}function Y(){}function oe(se){switch(se.status){case"fulfilled":return se.value;case"rejected":throw se.reason;default:switch(typeof se.status=="string"?se.then(Y,Y):(se.status="pending",se.then(function(G){se.status==="pending"&&(se.status="fulfilled",se.value=G)},function(G){se.status==="pending"&&(se.status="rejected",se.reason=G)})),se.status){case"fulfilled":return se.value;case"rejected":throw se.reason}}throw se}function ue(se,G,re,W,$){var S=typeof se;(S==="undefined"||S==="boolean")&&(se=null);var N=!1;if(se===null)N=!0;else switch(S){case"bigint":case"string":case"number":N=!0;break;case"object":switch(se.$$typeof){case n:case a:N=!0;break;case u:return N=se._init,ue(N(se._payload),G,re,W,$)}}if(N)return $=$(se),N=W===""?"."+le(se,0):W,v($)?(re="",N!=null&&(re=N.replace(Q,"$&/")+"/"),ue($,G,re,"",function(_e){return _e})):$!=null&&(U($)&&($=q($,re+($.key==null||se&&se.key===$.key?"":(""+$.key).replace(Q,"$&/")+"/")+N)),G.push($)),1;N=0;var D=W===""?".":W+":";if(v(se))for(var H=0;H<se.length;H++)W=se[H],S=D+le(W,H),N+=ue(W,G,re,S,$);else if(H=m(se),typeof H=="function")for(se=H.call(se),H=0;!(W=se.next()).done;)W=W.value,S=D+le(W,H++),N+=ue(W,G,re,S,$);else if(S==="object"){if(typeof se.then=="function")return ue(oe(se),G,re,W,$);throw G=String(se),Error("Objects are not valid as a React child (found: "+(G==="[object Object]"?"object with keys {"+Object.keys(se).join(", ")+"}":G)+"). If you meant to render a collection of children, use an array instead.")}return N}function O(se,G,re){if(se==null)return se;var W=[],$=0;return ue(se,W,"","",function(S){return G.call(re,S,$++)}),W}function P(se){if(se._status===-1){var G=se._result;G=G(),G.then(function(re){(se._status===0||se._status===-1)&&(se._status=1,se._result=re)},function(re){(se._status===0||se._status===-1)&&(se._status=2,se._result=re)}),se._status===-1&&(se._status=0,se._result=G)}if(se._status===1)return se._result.default;throw se._result}var Z=typeof reportError=="function"?reportError:function(se){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var G=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof se=="object"&&se!==null&&typeof se.message=="string"?String(se.message):String(se),error:se});if(!window.dispatchEvent(G))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",se);return}console.error(se)};function he(){}return Ye.Children={map:O,forEach:function(se,G,re){O(se,function(){G.apply(this,arguments)},re)},count:function(se){var G=0;return O(se,function(){G++}),G},toArray:function(se){return O(se,function(G){return G})||[]},only:function(se){if(!U(se))throw Error("React.Children.only expected to receive a single React element child.");return se}},Ye.Component=B,Ye.Fragment=p,Ye.Profiler=g,Ye.PureComponent=z,Ye.StrictMode=l,Ye.Suspense=c,Ye.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=w,Ye.__COMPILER_RUNTIME={__proto__:null,c:function(se){return w.H.useMemoCache(se)}},Ye.cache=function(se){return function(){return se.apply(null,arguments)}},Ye.cloneElement=function(se,G,re){if(se==null)throw Error("The argument must be a React element, but you passed "+se+".");var W=b({},se.props),$=se.key,S=void 0;if(G!=null)for(N in G.ref!==void 0&&(S=void 0),G.key!==void 0&&($=""+G.key),G)!R.call(G,N)||N==="key"||N==="__self"||N==="__source"||N==="ref"&&G.ref===void 0||(W[N]=G[N]);var N=arguments.length-2;if(N===1)W.children=re;else if(1<N){for(var D=Array(N),H=0;H<N;H++)D[H]=arguments[H+2];W.children=D}return A(se.type,$,void 0,void 0,S,W)},Ye.createContext=function(se){return se={$$typeof:h,_currentValue:se,_currentValue2:se,_threadCount:0,Provider:null,Consumer:null},se.Provider=se,se.Consumer={$$typeof:y,_context:se},se},Ye.createElement=function(se,G,re){var W,$={},S=null;if(G!=null)for(W in G.key!==void 0&&(S=""+G.key),G)R.call(G,W)&&W!=="key"&&W!=="__self"&&W!=="__source"&&($[W]=G[W]);var N=arguments.length-2;if(N===1)$.children=re;else if(1<N){for(var D=Array(N),H=0;H<N;H++)D[H]=arguments[H+2];$.children=D}if(se&&se.defaultProps)for(W in N=se.defaultProps,N)$[W]===void 0&&($[W]=N[W]);return A(se,S,void 0,void 0,null,$)},Ye.createRef=function(){return{current:null}},Ye.forwardRef=function(se){return{$$typeof:o,render:se}},Ye.isValidElement=U,Ye.lazy=function(se){return{$$typeof:u,_payload:{_status:-1,_result:se},_init:P}},Ye.memo=function(se,G){return{$$typeof:s,type:se,compare:G===void 0?null:G}},Ye.startTransition=function(se){var G=w.T,re={};w.T=re;try{var W=se(),$=w.S;$!==null&&$(re,W),typeof W=="object"&&W!==null&&typeof W.then=="function"&&W.then(he,Z)}catch(S){Z(S)}finally{w.T=G}},Ye.unstable_useCacheRefresh=function(){return w.H.useCacheRefresh()},Ye.use=function(se){return w.H.use(se)},Ye.useActionState=function(se,G,re){return w.H.useActionState(se,G,re)},Ye.useCallback=function(se,G){return w.H.useCallback(se,G)},Ye.useContext=function(se){return w.H.useContext(se)},Ye.useDebugValue=function(){},Ye.useDeferredValue=function(se,G){return w.H.useDeferredValue(se,G)},Ye.useEffect=function(se,G,re){var W=w.H;if(typeof re=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return W.useEffect(se,G)},Ye.useId=function(){return w.H.useId()},Ye.useImperativeHandle=function(se,G,re){return w.H.useImperativeHandle(se,G,re)},Ye.useInsertionEffect=function(se,G){return w.H.useInsertionEffect(se,G)},Ye.useLayoutEffect=function(se,G){return w.H.useLayoutEffect(se,G)},Ye.useMemo=function(se,G){return w.H.useMemo(se,G)},Ye.useOptimistic=function(se,G){return w.H.useOptimistic(se,G)},Ye.useReducer=function(se,G,re){return w.H.useReducer(se,G,re)},Ye.useRef=function(se){return w.H.useRef(se)},Ye.useState=function(se){return w.H.useState(se)},Ye.useSyncExternalStore=function(se,G,re){return w.H.useSyncExternalStore(se,G,re)},Ye.useTransition=function(){return w.H.useTransition()},Ye.version="19.1.0",Ye}var mv;function Xf(){return mv||(mv=1,Bf.exports=iE()),Bf.exports}var rt=Xf();const sE=ti(rt);var Nf={exports:{}},fo={},qf={exports:{}},Cf={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var wv;function rE(){return wv||(wv=1,function(n){function a(O,P){var Z=O.length;O.push(P);e:for(;0<Z;){var he=Z-1>>>1,se=O[he];if(0<g(se,P))O[he]=P,O[Z]=se,Z=he;else break e}}function p(O){return O.length===0?null:O[0]}function l(O){if(O.length===0)return null;var P=O[0],Z=O.pop();if(Z!==P){O[0]=Z;e:for(var he=0,se=O.length,G=se>>>1;he<G;){var re=2*(he+1)-1,W=O[re],$=re+1,S=O[$];if(0>g(W,Z))$<se&&0>g(S,W)?(O[he]=S,O[$]=Z,he=$):(O[he]=W,O[re]=Z,he=re);else if($<se&&0>g(S,Z))O[he]=S,O[$]=Z,he=$;else break e}}return P}function g(O,P){var Z=O.sortIndex-P.sortIndex;return Z!==0?Z:O.id-P.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var y=performance;n.unstable_now=function(){return y.now()}}else{var h=Date,o=h.now();n.unstable_now=function(){return h.now()-o}}var c=[],s=[],u=1,f=null,m=3,E=!1,b=!1,_=!1,B=!1,M=typeof setTimeout=="function"?setTimeout:null,z=typeof clearTimeout=="function"?clearTimeout:null,j=typeof setImmediate<"u"?setImmediate:null;function v(O){for(var P=p(s);P!==null;){if(P.callback===null)l(s);else if(P.startTime<=O)l(s),P.sortIndex=P.expirationTime,a(c,P);else break;P=p(s)}}function w(O){if(_=!1,v(O),!b)if(p(c)!==null)b=!0,R||(R=!0,le());else{var P=p(s);P!==null&&ue(w,P.startTime-O)}}var R=!1,A=-1,q=5,U=-1;function T(){return B?!0:!(n.unstable_now()-U<q)}function Q(){if(B=!1,R){var O=n.unstable_now();U=O;var P=!0;try{e:{b=!1,_&&(_=!1,z(A),A=-1),E=!0;var Z=m;try{t:{for(v(O),f=p(c);f!==null&&!(f.expirationTime>O&&T());){var he=f.callback;if(typeof he=="function"){f.callback=null,m=f.priorityLevel;var se=he(f.expirationTime<=O);if(O=n.unstable_now(),typeof se=="function"){f.callback=se,v(O),P=!0;break t}f===p(c)&&l(c),v(O)}else l(c);f=p(c)}if(f!==null)P=!0;else{var G=p(s);G!==null&&ue(w,G.startTime-O),P=!1}}break e}finally{f=null,m=Z,E=!1}P=void 0}}finally{P?le():R=!1}}}var le;if(typeof j=="function")le=function(){j(Q)};else if(typeof MessageChannel<"u"){var Y=new MessageChannel,oe=Y.port2;Y.port1.onmessage=Q,le=function(){oe.postMessage(null)}}else le=function(){M(Q,0)};function ue(O,P){A=M(function(){O(n.unstable_now())},P)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(O){O.callback=null},n.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):q=0<O?Math.floor(1e3/O):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(O){switch(m){case 1:case 2:case 3:var P=3;break;default:P=m}var Z=m;m=P;try{return O()}finally{m=Z}},n.unstable_requestPaint=function(){B=!0},n.unstable_runWithPriority=function(O,P){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var Z=m;m=O;try{return P()}finally{m=Z}},n.unstable_scheduleCallback=function(O,P,Z){var he=n.unstable_now();switch(typeof Z=="object"&&Z!==null?(Z=Z.delay,Z=typeof Z=="number"&&0<Z?he+Z:he):Z=he,O){case 1:var se=-1;break;case 2:se=250;break;case 5:se=1073741823;break;case 4:se=1e4;break;default:se=5e3}return se=Z+se,O={id:u++,callback:P,priorityLevel:O,startTime:Z,expirationTime:se,sortIndex:-1},Z>he?(O.sortIndex=Z,a(s,O),p(c)===null&&O===p(s)&&(_?(z(A),A=-1):_=!0,ue(w,Z-he))):(O.sortIndex=se,a(c,O),b||E||(b=!0,R||(R=!0,le()))),O},n.unstable_shouldYield=T,n.unstable_wrapCallback=function(O){var P=m;return function(){var Z=m;m=P;try{return O.apply(this,arguments)}finally{m=Z}}}}(Cf)),Cf}var bv;function oE(){return bv||(bv=1,qf.exports=rE()),qf.exports}var Mf={exports:{}},Vt={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var vv;function aE(){if(vv)return Vt;vv=1;var n=Xf();function a(c){var s="https://react.dev/errors/"+c;if(1<arguments.length){s+="?args[]="+encodeURIComponent(arguments[1]);for(var u=2;u<arguments.length;u++)s+="&args[]="+encodeURIComponent(arguments[u])}return"Minified React error #"+c+"; visit "+s+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function p(){}var l={d:{f:p,r:function(){throw Error(a(522))},D:p,C:p,L:p,m:p,X:p,S:p,M:p},p:0,findDOMNode:null},g=Symbol.for("react.portal");function y(c,s,u){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:g,key:f==null?null:""+f,children:c,containerInfo:s,implementation:u}}var h=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(c,s){if(c==="font")return"";if(typeof s=="string")return s==="use-credentials"?s:""}return Vt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=l,Vt.createPortal=function(c,s){var u=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!s||s.nodeType!==1&&s.nodeType!==9&&s.nodeType!==11)throw Error(a(299));return y(c,s,null,u)},Vt.flushSync=function(c){var s=h.T,u=l.p;try{if(h.T=null,l.p=2,c)return c()}finally{h.T=s,l.p=u,l.d.f()}},Vt.preconnect=function(c,s){typeof c=="string"&&(s?(s=s.crossOrigin,s=typeof s=="string"?s==="use-credentials"?s:"":void 0):s=null,l.d.C(c,s))},Vt.prefetchDNS=function(c){typeof c=="string"&&l.d.D(c)},Vt.preinit=function(c,s){if(typeof c=="string"&&s&&typeof s.as=="string"){var u=s.as,f=o(u,s.crossOrigin),m=typeof s.integrity=="string"?s.integrity:void 0,E=typeof s.fetchPriority=="string"?s.fetchPriority:void 0;u==="style"?l.d.S(c,typeof s.precedence=="string"?s.precedence:void 0,{crossOrigin:f,integrity:m,fetchPriority:E}):u==="script"&&l.d.X(c,{crossOrigin:f,integrity:m,fetchPriority:E,nonce:typeof s.nonce=="string"?s.nonce:void 0})}},Vt.preinitModule=function(c,s){if(typeof c=="string")if(typeof s=="object"&&s!==null){if(s.as==null||s.as==="script"){var u=o(s.as,s.crossOrigin);l.d.M(c,{crossOrigin:u,integrity:typeof s.integrity=="string"?s.integrity:void 0,nonce:typeof s.nonce=="string"?s.nonce:void 0})}}else s==null&&l.d.M(c)},Vt.preload=function(c,s){if(typeof c=="string"&&typeof s=="object"&&s!==null&&typeof s.as=="string"){var u=s.as,f=o(u,s.crossOrigin);l.d.L(c,u,{crossOrigin:f,integrity:typeof s.integrity=="string"?s.integrity:void 0,nonce:typeof s.nonce=="string"?s.nonce:void 0,type:typeof s.type=="string"?s.type:void 0,fetchPriority:typeof s.fetchPriority=="string"?s.fetchPriority:void 0,referrerPolicy:typeof s.referrerPolicy=="string"?s.referrerPolicy:void 0,imageSrcSet:typeof s.imageSrcSet=="string"?s.imageSrcSet:void 0,imageSizes:typeof s.imageSizes=="string"?s.imageSizes:void 0,media:typeof s.media=="string"?s.media:void 0})}},Vt.preloadModule=function(c,s){if(typeof c=="string")if(s){var u=o(s.as,s.crossOrigin);l.d.m(c,{as:typeof s.as=="string"&&s.as!=="script"?s.as:void 0,crossOrigin:u,integrity:typeof s.integrity=="string"?s.integrity:void 0})}else l.d.m(c)},Vt.requestFormReset=function(c){l.d.r(c)},Vt.unstable_batchedUpdates=function(c,s){return c(s)},Vt.useFormState=function(c,s,u){return h.H.useFormState(c,s,u)},Vt.useFormStatus=function(){return h.H.useHostTransitionStatus()},Vt.version="19.1.0",Vt}var kv;function lE(){if(kv)return Mf.exports;kv=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(a){console.error(a)}}return n(),Mf.exports=aE(),Mf.exports}var Sv;function cE(){if(Sv)return fo;Sv=1;/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var n=oE(),a=Xf(),p=lE();function l(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var i=2;i<arguments.length;i++)t+="&args[]="+encodeURIComponent(arguments[i])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function g(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function y(e){var t=e,i=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,(t.flags&4098)!==0&&(i=t.return),e=t.return;while(e)}return t.tag===3?i:null}function h(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function o(e){if(y(e)!==e)throw Error(l(188))}function c(e){var t=e.alternate;if(!t){if(t=y(e),t===null)throw Error(l(188));return t!==e?null:e}for(var i=e,r=t;;){var x=i.return;if(x===null)break;var K=x.alternate;if(K===null){if(r=x.return,r!==null){i=r;continue}break}if(x.child===K.child){for(K=x.child;K;){if(K===i)return o(x),e;if(K===r)return o(x),t;K=K.sibling}throw Error(l(188))}if(i.return!==r.return)i=x,r=K;else{for(var ae=!1,ge=x.child;ge;){if(ge===i){ae=!0,i=x,r=K;break}if(ge===r){ae=!0,r=x,i=K;break}ge=ge.sibling}if(!ae){for(ge=K.child;ge;){if(ge===i){ae=!0,i=K,r=x;break}if(ge===r){ae=!0,r=K,i=x;break}ge=ge.sibling}if(!ae)throw Error(l(189))}}if(i.alternate!==r)throw Error(l(190))}if(i.tag!==3)throw Error(l(188));return i.stateNode.current===i?e:t}function s(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e;for(e=e.child;e!==null;){if(t=s(e),t!==null)return t;e=e.sibling}return null}var u=Object.assign,f=Symbol.for("react.element"),m=Symbol.for("react.transitional.element"),E=Symbol.for("react.portal"),b=Symbol.for("react.fragment"),_=Symbol.for("react.strict_mode"),B=Symbol.for("react.profiler"),M=Symbol.for("react.provider"),z=Symbol.for("react.consumer"),j=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),A=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),U=Symbol.for("react.activity"),T=Symbol.for("react.memo_cache_sentinel"),Q=Symbol.iterator;function le(e){return e===null||typeof e!="object"?null:(e=Q&&e[Q]||e["@@iterator"],typeof e=="function"?e:null)}var Y=Symbol.for("react.client.reference");function oe(e){if(e==null)return null;if(typeof e=="function")return e.$$typeof===Y?null:e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case b:return"Fragment";case B:return"Profiler";case _:return"StrictMode";case w:return"Suspense";case R:return"SuspenseList";case U:return"Activity"}if(typeof e=="object")switch(e.$$typeof){case E:return"Portal";case j:return(e.displayName||"Context")+".Provider";case z:return(e._context.displayName||"Context")+".Consumer";case v:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case A:return t=e.displayName||null,t!==null?t:oe(e.type)||"Memo";case q:t=e._payload,e=e._init;try{return oe(e(t))}catch{}}return null}var ue=Array.isArray,O=a.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,P=p.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,Z={pending:!1,data:null,method:null,action:null},he=[],se=-1;function G(e){return{current:e}}function re(e){0>se||(e.current=he[se],he[se]=null,se--)}function W(e,t){se++,he[se]=e.current,e.current=t}var $=G(null),S=G(null),N=G(null),D=G(null);function H(e,t){switch(W(N,t),W(S,e),W($,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?Qy(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)t=Qy(t),e=Xy(t,e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}re($),W($,e)}function _e(){re($),re(S),re(N)}function ce(e){e.memoizedState!==null&&W(D,e);var t=$.current,i=Xy(t,e.type);t!==i&&(W(S,e),W($,i))}function J(e){S.current===e&&(re($),re(S)),D.current===e&&(re(D),eo._currentValue=Z)}var d=Object.prototype.hasOwnProperty,k=n.unstable_scheduleCallback,X=n.unstable_cancelCallback,ie=n.unstable_shouldYield,I=n.unstable_requestPaint,L=n.unstable_now,V=n.unstable_getCurrentPriorityLevel,te=n.unstable_ImmediatePriority,de=n.unstable_UserBlockingPriority,C=n.unstable_NormalPriority,ee=n.unstable_LowPriority,fe=n.unstable_IdlePriority,ve=n.log,we=n.unstable_setDisableYieldValue,F=null,ne=null;function ye(e){if(typeof ve=="function"&&we(e),ne&&typeof ne.setStrictMode=="function")try{ne.setStrictMode(F,e)}catch{}}var me=Math.clz32?Math.clz32:Oe,Ee=Math.log,qe=Math.LN2;function Oe(e){return e>>>=0,e===0?32:31-(Ee(e)/qe|0)|0}var Pe=256,ze=4194304;function it(e){var t=e&42;if(t!==0)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return e&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function at(e,t,i){var r=e.pendingLanes;if(r===0)return 0;var x=0,K=e.suspendedLanes,ae=e.pingedLanes;e=e.warmLanes;var ge=r&134217727;return ge!==0?(r=ge&~K,r!==0?x=it(r):(ae&=ge,ae!==0?x=it(ae):i||(i=ge&~e,i!==0&&(x=it(i))))):(ge=r&~K,ge!==0?x=it(ge):ae!==0?x=it(ae):i||(i=r&~e,i!==0&&(x=it(i)))),x===0?0:t!==0&&t!==x&&(t&K)===0&&(K=x&-x,i=t&-t,K>=i||K===32&&(i&4194048)!==0)?t:x}function xt(e,t){return(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)===0}function ii(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function si(){var e=Pe;return Pe<<=1,(Pe&4194048)===0&&(Pe=256),e}function hs(){var e=ze;return ze<<=1,(ze&62914560)===0&&(ze=4194304),e}function Ui(e){for(var t=[],i=0;31>i;i++)t.push(e);return t}function Oi(e,t){e.pendingLanes|=t,t!==268435456&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function cl(e,t,i,r,x,K){var ae=e.pendingLanes;e.pendingLanes=i,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=i,e.entangledLanes&=i,e.errorRecoveryDisabledLanes&=i,e.shellSuspendCounter=0;var ge=e.entanglements,be=e.expirationTimes,Re=e.hiddenUpdates;for(i=ae&~i;0<i;){var De=31-me(i),Ne=1<<De;ge[De]=0,be[De]=-1;var Le=Re[De];if(Le!==null)for(Re[De]=null,De=0;De<Le.length;De++){var Te=Le[De];Te!==null&&(Te.lane&=-536870913)}i&=~Ne}r!==0&&vo(e,r,0),K!==0&&x===0&&e.tag!==0&&(e.suspendedLanes|=K&~(ae&~t))}function vo(e,t,i){e.pendingLanes|=t,e.suspendedLanes&=~t;var r=31-me(t);e.entangledLanes|=t,e.entanglements[r]=e.entanglements[r]|1073741824|i&4194090}function ko(e,t){var i=e.entangledLanes|=t;for(e=e.entanglements;i;){var r=31-me(i),x=1<<r;x&t|e[r]&t&&(e[r]|=t),i&=~x}}function rr(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function us(e){return e&=-e,2<e?8<e?(e&134217727)!==0?32:268435456:8:2}function So(){var e=P.p;return e!==0?e:(e=window.event,e===void 0?32:p_(e.type))}function xo(e,t){var i=P.p;try{return P.p=e,t()}finally{P.p=i}}var Ln=Math.random().toString(36).slice(2),Bt="__reactFiber$"+Ln,zt="__reactProps$"+Ln,ri="__reactContainer$"+Ln,or="__reactEvents$"+Ln,hl="__reactListeners$"+Ln,ds="__reactHandles$"+Ln,ar="__reactResources$"+Ln,Pi="__reactMarker$"+Ln;function lr(e){delete e[Bt],delete e[zt],delete e[or],delete e[hl],delete e[ds]}function oi(e){var t=e[Bt];if(t)return t;for(var i=e.parentNode;i;){if(t=i[ri]||i[Bt]){if(i=t.alternate,t.child!==null||i!==null&&i.child!==null)for(e=e_(e);e!==null;){if(i=e[Bt])return i;e=e_(e)}return t}e=i,i=e.parentNode}return null}function ai(e){if(e=e[Bt]||e[ri]){var t=e.tag;if(t===5||t===6||t===13||t===26||t===27||t===3)return e}return null}function Ii(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e.stateNode;throw Error(l(33))}function Pn(e){var t=e[ar];return t||(t=e[ar]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function Et(e){e[Pi]=!0}var Eo=new Set,Ao={};function In(e,t){li(e,t),li(e+"Capture",t)}function li(e,t){for(Ao[e]=t,e=0;e<t.length;e++)Eo.add(t[e])}var Ro=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Lo={},To={};function cr(e){return d.call(To,e)?!0:d.call(Lo,e)?!1:Ro.test(e)?To[e]=!0:(Lo[e]=!0,!1)}function Tn(e,t,i){if(cr(t))if(i===null)e.removeAttribute(t);else{switch(typeof i){case"undefined":case"function":case"symbol":e.removeAttribute(t);return;case"boolean":var r=t.toLowerCase().slice(0,5);if(r!=="data-"&&r!=="aria-"){e.removeAttribute(t);return}}e.setAttribute(t,""+i)}}function Ki(e,t,i){if(i===null)e.removeAttribute(t);else{switch(typeof i){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(t);return}e.setAttribute(t,""+i)}}function on(e,t,i,r){if(r===null)e.removeAttribute(i);else{switch(typeof r){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(i);return}e.setAttributeNS(t,i,""+r)}}var fs,Do;function ci(e){if(fs===void 0)try{throw Error()}catch(i){var t=i.stack.trim().match(/\n( *(at )?)/);fs=t&&t[1]||"",Do=-1<i.stack.indexOf(`
    at`)?" (<anonymous>)":-1<i.stack.indexOf("@")?"@unknown:0:0":""}return`
`+fs+e+Do}var hr=!1;function gs(e,t){if(!e||hr)return"";hr=!0;var i=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var r={DetermineComponentFrameRoot:function(){try{if(t){var Ne=function(){throw Error()};if(Object.defineProperty(Ne.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Ne,[])}catch(Te){var Le=Te}Reflect.construct(e,[],Ne)}else{try{Ne.call()}catch(Te){Le=Te}e.call(Ne.prototype)}}else{try{throw Error()}catch(Te){Le=Te}(Ne=e())&&typeof Ne.catch=="function"&&Ne.catch(function(){})}}catch(Te){if(Te&&Le&&typeof Te.stack=="string")return[Te.stack,Le.stack]}return[null,null]}};r.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var x=Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot,"name");x&&x.configurable&&Object.defineProperty(r.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var K=r.DetermineComponentFrameRoot(),ae=K[0],ge=K[1];if(ae&&ge){var be=ae.split(`
`),Re=ge.split(`
`);for(x=r=0;r<be.length&&!be[r].includes("DetermineComponentFrameRoot");)r++;for(;x<Re.length&&!Re[x].includes("DetermineComponentFrameRoot");)x++;if(r===be.length||x===Re.length)for(r=be.length-1,x=Re.length-1;1<=r&&0<=x&&be[r]!==Re[x];)x--;for(;1<=r&&0<=x;r--,x--)if(be[r]!==Re[x]){if(r!==1||x!==1)do if(r--,x--,0>x||be[r]!==Re[x]){var De=`
`+be[r].replace(" at new "," at ");return e.displayName&&De.includes("<anonymous>")&&(De=De.replace("<anonymous>",e.displayName)),De}while(1<=r&&0<=x);break}}}finally{hr=!1,Error.prepareStackTrace=i}return(i=e?e.displayName||e.name:"")?ci(i):""}function ul(e){switch(e.tag){case 26:case 27:case 5:return ci(e.type);case 16:return ci("Lazy");case 13:return ci("Suspense");case 19:return ci("SuspenseList");case 0:case 15:return gs(e.type,!1);case 11:return gs(e.type.render,!1);case 1:return gs(e.type,!0);case 31:return ci("Activity");default:return""}}function ur(e){try{var t="";do t+=ul(e),e=e.return;while(e);return t}catch(i){return`
Error generating stack: `+i.message+`
`+i.stack}}function Nt(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function Bo(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function dl(e){var t=Bo(e)?"checked":"value",i=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof i<"u"&&typeof i.get=="function"&&typeof i.set=="function"){var x=i.get,K=i.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return x.call(this)},set:function(ae){r=""+ae,K.call(this,ae)}}),Object.defineProperty(e,t,{enumerable:i.enumerable}),{getValue:function(){return r},setValue:function(ae){r=""+ae},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function ps(e){e._valueTracker||(e._valueTracker=dl(e))}function No(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var i=t.getValue(),r="";return e&&(r=Bo(e)?e.checked?"true":"false":e.value),e=r,e!==i?(t.setValue(e),!0):!1}function ys(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}var fl=/[\n"\\]/g;function Gt(e){return e.replace(fl,function(t){return"\\"+t.charCodeAt(0).toString(16)+" "})}function _s(e,t,i,r,x,K,ae,ge){e.name="",ae!=null&&typeof ae!="function"&&typeof ae!="symbol"&&typeof ae!="boolean"?e.type=ae:e.removeAttribute("type"),t!=null?ae==="number"?(t===0&&e.value===""||e.value!=t)&&(e.value=""+Nt(t)):e.value!==""+Nt(t)&&(e.value=""+Nt(t)):ae!=="submit"&&ae!=="reset"||e.removeAttribute("value"),t!=null?dr(e,ae,Nt(t)):i!=null?dr(e,ae,Nt(i)):r!=null&&e.removeAttribute("value"),x==null&&K!=null&&(e.defaultChecked=!!K),x!=null&&(e.checked=x&&typeof x!="function"&&typeof x!="symbol"),ge!=null&&typeof ge!="function"&&typeof ge!="symbol"&&typeof ge!="boolean"?e.name=""+Nt(ge):e.removeAttribute("name")}function qo(e,t,i,r,x,K,ae,ge){if(K!=null&&typeof K!="function"&&typeof K!="symbol"&&typeof K!="boolean"&&(e.type=K),t!=null||i!=null){if(!(K!=="submit"&&K!=="reset"||t!=null))return;i=i!=null?""+Nt(i):"",t=t!=null?""+Nt(t):i,ge||t===e.value||(e.value=t),e.defaultValue=t}r=r??x,r=typeof r!="function"&&typeof r!="symbol"&&!!r,e.checked=ge?e.checked:!!r,e.defaultChecked=!!r,ae!=null&&typeof ae!="function"&&typeof ae!="symbol"&&typeof ae!="boolean"&&(e.name=ae)}function dr(e,t,i){t==="number"&&ys(e.ownerDocument)===e||e.defaultValue===""+i||(e.defaultValue=""+i)}function Me(e,t,i,r){if(e=e.options,t){t={};for(var x=0;x<i.length;x++)t["$"+i[x]]=!0;for(i=0;i<e.length;i++)x=t.hasOwnProperty("$"+e[i].value),e[i].selected!==x&&(e[i].selected=x),x&&r&&(e[i].defaultSelected=!0)}else{for(i=""+Nt(i),t=null,x=0;x<e.length;x++){if(e[x].value===i){e[x].selected=!0,r&&(e[x].defaultSelected=!0);return}t!==null||e[x].disabled||(t=e[x])}t!==null&&(t.selected=!0)}}function pe(e,t,i){if(t!=null&&(t=""+Nt(t),t!==e.value&&(e.value=t),i==null)){e.defaultValue!==t&&(e.defaultValue=t);return}e.defaultValue=i!=null?""+Nt(i):""}function Ce(e,t,i,r){if(t==null){if(r!=null){if(i!=null)throw Error(l(92));if(ue(r)){if(1<r.length)throw Error(l(93));r=r[0]}i=r}i==null&&(i=""),t=i}i=Nt(t),e.defaultValue=i,r=e.textContent,r===i&&r!==""&&r!==null&&(e.value=r)}function He(e,t){if(t){var i=e.firstChild;if(i&&i===e.lastChild&&i.nodeType===3){i.nodeValue=t;return}}e.textContent=t}var Xe=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function gt(e,t,i){var r=t.indexOf("--")===0;i==null||typeof i=="boolean"||i===""?r?e.setProperty(t,""):t==="float"?e.cssFloat="":e[t]="":r?e.setProperty(t,i):typeof i!="number"||i===0||Xe.has(t)?t==="float"?e.cssFloat=i:e[t]=(""+i).trim():e[t]=i+"px"}function ht(e,t,i){if(t!=null&&typeof t!="object")throw Error(l(62));if(e=e.style,i!=null){for(var r in i)!i.hasOwnProperty(r)||t!=null&&t.hasOwnProperty(r)||(r.indexOf("--")===0?e.setProperty(r,""):r==="float"?e.cssFloat="":e[r]="");for(var x in t)r=t[x],t.hasOwnProperty(x)&&i[x]!==r&&gt(e,x,r)}else for(var K in t)t.hasOwnProperty(K)&&gt(e,K,t[K])}function Dn(e){if(e.indexOf("-")===-1)return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var zi=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),tt=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Yt(e){return tt.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}var gn=null;function Hi(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var hi=null,ms=null;function Zf(e){var t=ai(e);if(t&&(e=t.stateNode)){var i=e[zt]||null;e:switch(e=t.stateNode,t.type){case"input":if(_s(e,i.value,i.defaultValue,i.defaultValue,i.checked,i.defaultChecked,i.type,i.name),t=i.name,i.type==="radio"&&t!=null){for(i=e;i.parentNode;)i=i.parentNode;for(i=i.querySelectorAll('input[name="'+Gt(""+t)+'"][type="radio"]'),t=0;t<i.length;t++){var r=i[t];if(r!==e&&r.form===e.form){var x=r[zt]||null;if(!x)throw Error(l(90));_s(r,x.value,x.defaultValue,x.defaultValue,x.checked,x.defaultChecked,x.type,x.name)}}for(t=0;t<i.length;t++)r=i[t],r.form===e.form&&No(r)}break e;case"textarea":pe(e,i.value,i.defaultValue);break e;case"select":t=i.value,t!=null&&Me(e,!!i.multiple,t,!1)}}}var gl=!1;function $f(e,t,i){if(gl)return e(t,i);gl=!0;try{var r=e(t);return r}finally{if(gl=!1,(hi!==null||ms!==null)&&(ma(),hi&&(t=hi,e=ms,ms=hi=null,Zf(t),e)))for(t=0;t<e.length;t++)Zf(e[t])}}function fr(e,t){var i=e.stateNode;if(i===null)return null;var r=i[zt]||null;if(r===null)return null;i=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(i&&typeof i!="function")throw Error(l(231,t,typeof i));return i}var Kn=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),pl=!1;if(Kn)try{var gr={};Object.defineProperty(gr,"passive",{get:function(){pl=!0}}),window.addEventListener("test",gr,gr),window.removeEventListener("test",gr,gr)}catch{pl=!1}var ui=null,yl=null,Co=null;function Jf(){if(Co)return Co;var e,t=yl,i=t.length,r,x="value"in ui?ui.value:ui.textContent,K=x.length;for(e=0;e<i&&t[e]===x[e];e++);var ae=i-e;for(r=1;r<=ae&&t[i-r]===x[K-r];r++);return Co=x.slice(e,1<r?1-r:void 0)}function Mo(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function Uo(){return!0}function eg(){return!1}function Zt(e){function t(i,r,x,K,ae){this._reactName=i,this._targetInst=x,this.type=r,this.nativeEvent=K,this.target=ae,this.currentTarget=null;for(var ge in e)e.hasOwnProperty(ge)&&(i=e[ge],this[ge]=i?i(K):K[ge]);return this.isDefaultPrevented=(K.defaultPrevented!=null?K.defaultPrevented:K.returnValue===!1)?Uo:eg,this.isPropagationStopped=eg,this}return u(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var i=this.nativeEvent;i&&(i.preventDefault?i.preventDefault():typeof i.returnValue!="unknown"&&(i.returnValue=!1),this.isDefaultPrevented=Uo)},stopPropagation:function(){var i=this.nativeEvent;i&&(i.stopPropagation?i.stopPropagation():typeof i.cancelBubble!="unknown"&&(i.cancelBubble=!0),this.isPropagationStopped=Uo)},persist:function(){},isPersistent:Uo}),t}var Fi={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Oo=Zt(Fi),pr=u({},Fi,{view:0,detail:0}),x0=Zt(pr),_l,ml,yr,Po=u({},pr,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:bl,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==yr&&(yr&&e.type==="mousemove"?(_l=e.screenX-yr.screenX,ml=e.screenY-yr.screenY):ml=_l=0,yr=e),_l)},movementY:function(e){return"movementY"in e?e.movementY:ml}}),tg=Zt(Po),E0=u({},Po,{dataTransfer:0}),A0=Zt(E0),R0=u({},pr,{relatedTarget:0}),wl=Zt(R0),L0=u({},Fi,{animationName:0,elapsedTime:0,pseudoElement:0}),T0=Zt(L0),D0=u({},Fi,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),B0=Zt(D0),N0=u({},Fi,{data:0}),ng=Zt(N0),q0={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},C0={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},M0={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function U0(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=M0[e])?!!t[e]:!1}function bl(){return U0}var O0=u({},pr,{key:function(e){if(e.key){var t=q0[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Mo(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?C0[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:bl,charCode:function(e){return e.type==="keypress"?Mo(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Mo(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),P0=Zt(O0),I0=u({},Po,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),ig=Zt(I0),K0=u({},pr,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:bl}),z0=Zt(K0),H0=u({},Fi,{propertyName:0,elapsedTime:0,pseudoElement:0}),F0=Zt(H0),V0=u({},Po,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),j0=Zt(V0),G0=u({},Fi,{newState:0,oldState:0}),Y0=Zt(G0),W0=[9,13,27,32],vl=Kn&&"CompositionEvent"in window,_r=null;Kn&&"documentMode"in document&&(_r=document.documentMode);var Q0=Kn&&"TextEvent"in window&&!_r,sg=Kn&&(!vl||_r&&8<_r&&11>=_r),rg=" ",og=!1;function ag(e,t){switch(e){case"keyup":return W0.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function lg(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var ws=!1;function X0(e,t){switch(e){case"compositionend":return lg(t);case"keypress":return t.which!==32?null:(og=!0,rg);case"textInput":return e=t.data,e===rg&&og?null:e;default:return null}}function Z0(e,t){if(ws)return e==="compositionend"||!vl&&ag(e,t)?(e=Jf(),Co=yl=ui=null,ws=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return sg&&t.locale!=="ko"?null:t.data;default:return null}}var $0={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function cg(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!$0[e.type]:t==="textarea"}function hg(e,t,i,r){hi?ms?ms.push(r):ms=[r]:hi=r,t=xa(t,"onChange"),0<t.length&&(i=new Oo("onChange","change",null,i,r),e.push({event:i,listeners:t}))}var mr=null,wr=null;function J0(e){Vy(e,0)}function Io(e){var t=Ii(e);if(No(t))return e}function ug(e,t){if(e==="change")return t}var dg=!1;if(Kn){var kl;if(Kn){var Sl="oninput"in document;if(!Sl){var fg=document.createElement("div");fg.setAttribute("oninput","return;"),Sl=typeof fg.oninput=="function"}kl=Sl}else kl=!1;dg=kl&&(!document.documentMode||9<document.documentMode)}function gg(){mr&&(mr.detachEvent("onpropertychange",pg),wr=mr=null)}function pg(e){if(e.propertyName==="value"&&Io(wr)){var t=[];hg(t,wr,e,Hi(e)),$f(J0,t)}}function ek(e,t,i){e==="focusin"?(gg(),mr=t,wr=i,mr.attachEvent("onpropertychange",pg)):e==="focusout"&&gg()}function tk(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return Io(wr)}function nk(e,t){if(e==="click")return Io(t)}function ik(e,t){if(e==="input"||e==="change")return Io(t)}function sk(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var an=typeof Object.is=="function"?Object.is:sk;function br(e,t){if(an(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var i=Object.keys(e),r=Object.keys(t);if(i.length!==r.length)return!1;for(r=0;r<i.length;r++){var x=i[r];if(!d.call(t,x)||!an(e[x],t[x]))return!1}return!0}function yg(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function _g(e,t){var i=yg(e);e=0;for(var r;i;){if(i.nodeType===3){if(r=e+i.textContent.length,e<=t&&r>=t)return{node:i,offset:t-e};e=r}e:{for(;i;){if(i.nextSibling){i=i.nextSibling;break e}i=i.parentNode}i=void 0}i=yg(i)}}function mg(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?mg(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function wg(e){e=e!=null&&e.ownerDocument!=null&&e.ownerDocument.defaultView!=null?e.ownerDocument.defaultView:window;for(var t=ys(e.document);t instanceof e.HTMLIFrameElement;){try{var i=typeof t.contentWindow.location.href=="string"}catch{i=!1}if(i)e=t.contentWindow;else break;t=ys(e.document)}return t}function xl(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}var rk=Kn&&"documentMode"in document&&11>=document.documentMode,bs=null,El=null,vr=null,Al=!1;function bg(e,t,i){var r=i.window===i?i.document:i.nodeType===9?i:i.ownerDocument;Al||bs==null||bs!==ys(r)||(r=bs,"selectionStart"in r&&xl(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),vr&&br(vr,r)||(vr=r,r=xa(El,"onSelect"),0<r.length&&(t=new Oo("onSelect","select",null,t,i),e.push({event:t,listeners:r}),t.target=bs)))}function Vi(e,t){var i={};return i[e.toLowerCase()]=t.toLowerCase(),i["Webkit"+e]="webkit"+t,i["Moz"+e]="moz"+t,i}var vs={animationend:Vi("Animation","AnimationEnd"),animationiteration:Vi("Animation","AnimationIteration"),animationstart:Vi("Animation","AnimationStart"),transitionrun:Vi("Transition","TransitionRun"),transitionstart:Vi("Transition","TransitionStart"),transitioncancel:Vi("Transition","TransitionCancel"),transitionend:Vi("Transition","TransitionEnd")},Rl={},vg={};Kn&&(vg=document.createElement("div").style,"AnimationEvent"in window||(delete vs.animationend.animation,delete vs.animationiteration.animation,delete vs.animationstart.animation),"TransitionEvent"in window||delete vs.transitionend.transition);function ji(e){if(Rl[e])return Rl[e];if(!vs[e])return e;var t=vs[e],i;for(i in t)if(t.hasOwnProperty(i)&&i in vg)return Rl[e]=t[i];return e}var kg=ji("animationend"),Sg=ji("animationiteration"),xg=ji("animationstart"),ok=ji("transitionrun"),ak=ji("transitionstart"),lk=ji("transitioncancel"),Eg=ji("transitionend"),Ag=new Map,Ll="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Ll.push("scrollEnd");function xn(e,t){Ag.set(e,t),In(t,[e])}var Rg=new WeakMap;function pn(e,t){if(typeof e=="object"&&e!==null){var i=Rg.get(e);return i!==void 0?i:(t={value:e,source:t,stack:ur(t)},Rg.set(e,t),t)}return{value:e,source:t,stack:ur(t)}}var yn=[],ks=0,Tl=0;function Ko(){for(var e=ks,t=Tl=ks=0;t<e;){var i=yn[t];yn[t++]=null;var r=yn[t];yn[t++]=null;var x=yn[t];yn[t++]=null;var K=yn[t];if(yn[t++]=null,r!==null&&x!==null){var ae=r.pending;ae===null?x.next=x:(x.next=ae.next,ae.next=x),r.pending=x}K!==0&&Lg(i,x,K)}}function zo(e,t,i,r){yn[ks++]=e,yn[ks++]=t,yn[ks++]=i,yn[ks++]=r,Tl|=r,e.lanes|=r,e=e.alternate,e!==null&&(e.lanes|=r)}function Dl(e,t,i,r){return zo(e,t,i,r),Ho(e)}function Ss(e,t){return zo(e,null,null,t),Ho(e)}function Lg(e,t,i){e.lanes|=i;var r=e.alternate;r!==null&&(r.lanes|=i);for(var x=!1,K=e.return;K!==null;)K.childLanes|=i,r=K.alternate,r!==null&&(r.childLanes|=i),K.tag===22&&(e=K.stateNode,e===null||e._visibility&1||(x=!0)),e=K,K=K.return;return e.tag===3?(K=e.stateNode,x&&t!==null&&(x=31-me(i),e=K.hiddenUpdates,r=e[x],r===null?e[x]=[t]:r.push(t),t.lane=i|536870912),K):null}function Ho(e){if(50<Gr)throw Gr=0,Uc=null,Error(l(185));for(var t=e.return;t!==null;)e=t,t=e.return;return e.tag===3?e.stateNode:null}var xs={};function ck(e,t,i,r){this.tag=e,this.key=i,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ln(e,t,i,r){return new ck(e,t,i,r)}function Bl(e){return e=e.prototype,!(!e||!e.isReactComponent)}function zn(e,t){var i=e.alternate;return i===null?(i=ln(e.tag,t,e.key,e.mode),i.elementType=e.elementType,i.type=e.type,i.stateNode=e.stateNode,i.alternate=e,e.alternate=i):(i.pendingProps=t,i.type=e.type,i.flags=0,i.subtreeFlags=0,i.deletions=null),i.flags=e.flags&65011712,i.childLanes=e.childLanes,i.lanes=e.lanes,i.child=e.child,i.memoizedProps=e.memoizedProps,i.memoizedState=e.memoizedState,i.updateQueue=e.updateQueue,t=e.dependencies,i.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},i.sibling=e.sibling,i.index=e.index,i.ref=e.ref,i.refCleanup=e.refCleanup,i}function Tg(e,t){e.flags&=65011714;var i=e.alternate;return i===null?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=i.childLanes,e.lanes=i.lanes,e.child=i.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=i.memoizedProps,e.memoizedState=i.memoizedState,e.updateQueue=i.updateQueue,e.type=i.type,t=i.dependencies,e.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function Fo(e,t,i,r,x,K){var ae=0;if(r=e,typeof e=="function")Bl(e)&&(ae=1);else if(typeof e=="string")ae=u1(e,i,$.current)?26:e==="html"||e==="head"||e==="body"?27:5;else e:switch(e){case U:return e=ln(31,i,t,x),e.elementType=U,e.lanes=K,e;case b:return Gi(i.children,x,K,t);case _:ae=8,x|=24;break;case B:return e=ln(12,i,t,x|2),e.elementType=B,e.lanes=K,e;case w:return e=ln(13,i,t,x),e.elementType=w,e.lanes=K,e;case R:return e=ln(19,i,t,x),e.elementType=R,e.lanes=K,e;default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case M:case j:ae=10;break e;case z:ae=9;break e;case v:ae=11;break e;case A:ae=14;break e;case q:ae=16,r=null;break e}ae=29,i=Error(l(130,e===null?"null":typeof e,"")),r=null}return t=ln(ae,i,t,x),t.elementType=e,t.type=r,t.lanes=K,t}function Gi(e,t,i,r){return e=ln(7,e,r,t),e.lanes=i,e}function Nl(e,t,i){return e=ln(6,e,null,t),e.lanes=i,e}function ql(e,t,i){return t=ln(4,e.children!==null?e.children:[],e.key,t),t.lanes=i,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var Es=[],As=0,Vo=null,jo=0,_n=[],mn=0,Yi=null,Hn=1,Fn="";function Wi(e,t){Es[As++]=jo,Es[As++]=Vo,Vo=e,jo=t}function Dg(e,t,i){_n[mn++]=Hn,_n[mn++]=Fn,_n[mn++]=Yi,Yi=e;var r=Hn;e=Fn;var x=32-me(r)-1;r&=~(1<<x),i+=1;var K=32-me(t)+x;if(30<K){var ae=x-x%5;K=(r&(1<<ae)-1).toString(32),r>>=ae,x-=ae,Hn=1<<32-me(t)+x|i<<x|r,Fn=K+e}else Hn=1<<K|i<<x|r,Fn=e}function Cl(e){e.return!==null&&(Wi(e,1),Dg(e,1,0))}function Ml(e){for(;e===Vo;)Vo=Es[--As],Es[As]=null,jo=Es[--As],Es[As]=null;for(;e===Yi;)Yi=_n[--mn],_n[mn]=null,Fn=_n[--mn],_n[mn]=null,Hn=_n[--mn],_n[mn]=null}var Wt=null,bt=null,ot=!1,Qi=null,Bn=!1,Ul=Error(l(519));function Xi(e){var t=Error(l(418,""));throw xr(pn(t,e)),Ul}function Bg(e){var t=e.stateNode,i=e.type,r=e.memoizedProps;switch(t[Bt]=e,t[zt]=r,i){case"dialog":Je("cancel",t),Je("close",t);break;case"iframe":case"object":case"embed":Je("load",t);break;case"video":case"audio":for(i=0;i<Wr.length;i++)Je(Wr[i],t);break;case"source":Je("error",t);break;case"img":case"image":case"link":Je("error",t),Je("load",t);break;case"details":Je("toggle",t);break;case"input":Je("invalid",t),qo(t,r.value,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name,!0),ps(t);break;case"select":Je("invalid",t);break;case"textarea":Je("invalid",t),Ce(t,r.value,r.defaultValue,r.children),ps(t)}i=r.children,typeof i!="string"&&typeof i!="number"&&typeof i!="bigint"||t.textContent===""+i||r.suppressHydrationWarning===!0||Wy(t.textContent,i)?(r.popover!=null&&(Je("beforetoggle",t),Je("toggle",t)),r.onScroll!=null&&Je("scroll",t),r.onScrollEnd!=null&&Je("scrollend",t),r.onClick!=null&&(t.onclick=Ea),t=!0):t=!1,t||Xi(e)}function Ng(e){for(Wt=e.return;Wt;)switch(Wt.tag){case 5:case 13:Bn=!1;return;case 27:case 3:Bn=!0;return;default:Wt=Wt.return}}function kr(e){if(e!==Wt)return!1;if(!ot)return Ng(e),ot=!0,!1;var t=e.tag,i;if((i=t!==3&&t!==27)&&((i=t===5)&&(i=e.type,i=!(i!=="form"&&i!=="button")||$c(e.type,e.memoizedProps)),i=!i),i&&bt&&Xi(e),Ng(e),t===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(l(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8)if(i=e.data,i==="/$"){if(t===0){bt=An(e.nextSibling);break e}t--}else i!=="$"&&i!=="$!"&&i!=="$?"||t++;e=e.nextSibling}bt=null}}else t===27?(t=bt,Ri(e.type)?(e=nh,nh=null,bt=e):bt=t):bt=Wt?An(e.stateNode.nextSibling):null;return!0}function Sr(){bt=Wt=null,ot=!1}function qg(){var e=Qi;return e!==null&&(en===null?en=e:en.push.apply(en,e),Qi=null),e}function xr(e){Qi===null?Qi=[e]:Qi.push(e)}var Ol=G(null),Zi=null,Vn=null;function di(e,t,i){W(Ol,t._currentValue),t._currentValue=i}function jn(e){e._currentValue=Ol.current,re(Ol)}function Pl(e,t,i){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===i)break;e=e.return}}function Il(e,t,i,r){var x=e.child;for(x!==null&&(x.return=e);x!==null;){var K=x.dependencies;if(K!==null){var ae=x.child;K=K.firstContext;e:for(;K!==null;){var ge=K;K=x;for(var be=0;be<t.length;be++)if(ge.context===t[be]){K.lanes|=i,ge=K.alternate,ge!==null&&(ge.lanes|=i),Pl(K.return,i,e),r||(ae=null);break e}K=ge.next}}else if(x.tag===18){if(ae=x.return,ae===null)throw Error(l(341));ae.lanes|=i,K=ae.alternate,K!==null&&(K.lanes|=i),Pl(ae,i,e),ae=null}else ae=x.child;if(ae!==null)ae.return=x;else for(ae=x;ae!==null;){if(ae===e){ae=null;break}if(x=ae.sibling,x!==null){x.return=ae.return,ae=x;break}ae=ae.return}x=ae}}function Er(e,t,i,r){e=null;for(var x=t,K=!1;x!==null;){if(!K){if((x.flags&524288)!==0)K=!0;else if((x.flags&262144)!==0)break}if(x.tag===10){var ae=x.alternate;if(ae===null)throw Error(l(387));if(ae=ae.memoizedProps,ae!==null){var ge=x.type;an(x.pendingProps.value,ae.value)||(e!==null?e.push(ge):e=[ge])}}else if(x===D.current){if(ae=x.alternate,ae===null)throw Error(l(387));ae.memoizedState.memoizedState!==x.memoizedState.memoizedState&&(e!==null?e.push(eo):e=[eo])}x=x.return}e!==null&&Il(t,e,i,r),t.flags|=262144}function Go(e){for(e=e.firstContext;e!==null;){if(!an(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function $i(e){Zi=e,Vn=null,e=e.dependencies,e!==null&&(e.firstContext=null)}function Ht(e){return Cg(Zi,e)}function Yo(e,t){return Zi===null&&$i(e),Cg(e,t)}function Cg(e,t){var i=t._currentValue;if(t={context:t,memoizedValue:i,next:null},Vn===null){if(e===null)throw Error(l(308));Vn=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else Vn=Vn.next=t;return i}var hk=typeof AbortController<"u"?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(i,r){e.push(r)}};this.abort=function(){t.aborted=!0,e.forEach(function(i){return i()})}},uk=n.unstable_scheduleCallback,dk=n.unstable_NormalPriority,Tt={$$typeof:j,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Kl(){return{controller:new hk,data:new Map,refCount:0}}function Ar(e){e.refCount--,e.refCount===0&&uk(dk,function(){e.controller.abort()})}var Rr=null,zl=0,Rs=0,Ls=null;function fk(e,t){if(Rr===null){var i=Rr=[];zl=0,Rs=Fc(),Ls={status:"pending",value:void 0,then:function(r){i.push(r)}}}return zl++,t.then(Mg,Mg),t}function Mg(){if(--zl===0&&Rr!==null){Ls!==null&&(Ls.status="fulfilled");var e=Rr;Rr=null,Rs=0,Ls=null;for(var t=0;t<e.length;t++)(0,e[t])()}}function gk(e,t){var i=[],r={status:"pending",value:null,reason:null,then:function(x){i.push(x)}};return e.then(function(){r.status="fulfilled",r.value=t;for(var x=0;x<i.length;x++)(0,i[x])(t)},function(x){for(r.status="rejected",r.reason=x,x=0;x<i.length;x++)(0,i[x])(void 0)}),r}var Ug=O.S;O.S=function(e,t){typeof t=="object"&&t!==null&&typeof t.then=="function"&&fk(e,t),Ug!==null&&Ug(e,t)};var Ji=G(null);function Hl(){var e=Ji.current;return e!==null?e:yt.pooledCache}function Wo(e,t){t===null?W(Ji,Ji.current):W(Ji,t.pool)}function Og(){var e=Hl();return e===null?null:{parent:Tt._currentValue,pool:e}}var Lr=Error(l(460)),Pg=Error(l(474)),Qo=Error(l(542)),Fl={then:function(){}};function Ig(e){return e=e.status,e==="fulfilled"||e==="rejected"}function Xo(){}function Kg(e,t,i){switch(i=e[i],i===void 0?e.push(t):i!==t&&(t.then(Xo,Xo),t=i),t.status){case"fulfilled":return t.value;case"rejected":throw e=t.reason,Hg(e),e;default:if(typeof t.status=="string")t.then(Xo,Xo);else{if(e=yt,e!==null&&100<e.shellSuspendCounter)throw Error(l(482));e=t,e.status="pending",e.then(function(r){if(t.status==="pending"){var x=t;x.status="fulfilled",x.value=r}},function(r){if(t.status==="pending"){var x=t;x.status="rejected",x.reason=r}})}switch(t.status){case"fulfilled":return t.value;case"rejected":throw e=t.reason,Hg(e),e}throw Tr=t,Lr}}var Tr=null;function zg(){if(Tr===null)throw Error(l(459));var e=Tr;return Tr=null,e}function Hg(e){if(e===Lr||e===Qo)throw Error(l(483))}var fi=!1;function Vl(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function jl(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function gi(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function pi(e,t,i){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,(lt&2)!==0){var x=r.pending;return x===null?t.next=t:(t.next=x.next,x.next=t),r.pending=t,t=Ho(e),Lg(e,null,i),t}return zo(e,r,t,i),Ho(e)}function Dr(e,t,i){if(t=t.updateQueue,t!==null&&(t=t.shared,(i&4194048)!==0)){var r=t.lanes;r&=e.pendingLanes,i|=r,t.lanes=i,ko(e,i)}}function Gl(e,t){var i=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,i===r)){var x=null,K=null;if(i=i.firstBaseUpdate,i!==null){do{var ae={lane:i.lane,tag:i.tag,payload:i.payload,callback:null,next:null};K===null?x=K=ae:K=K.next=ae,i=i.next}while(i!==null);K===null?x=K=t:K=K.next=t}else x=K=t;i={baseState:r.baseState,firstBaseUpdate:x,lastBaseUpdate:K,shared:r.shared,callbacks:r.callbacks},e.updateQueue=i;return}e=i.lastBaseUpdate,e===null?i.firstBaseUpdate=t:e.next=t,i.lastBaseUpdate=t}var Yl=!1;function Br(){if(Yl){var e=Ls;if(e!==null)throw e}}function Nr(e,t,i,r){Yl=!1;var x=e.updateQueue;fi=!1;var K=x.firstBaseUpdate,ae=x.lastBaseUpdate,ge=x.shared.pending;if(ge!==null){x.shared.pending=null;var be=ge,Re=be.next;be.next=null,ae===null?K=Re:ae.next=Re,ae=be;var De=e.alternate;De!==null&&(De=De.updateQueue,ge=De.lastBaseUpdate,ge!==ae&&(ge===null?De.firstBaseUpdate=Re:ge.next=Re,De.lastBaseUpdate=be))}if(K!==null){var Ne=x.baseState;ae=0,De=Re=be=null,ge=K;do{var Le=ge.lane&-536870913,Te=Le!==ge.lane;if(Te?(nt&Le)===Le:(r&Le)===Le){Le!==0&&Le===Rs&&(Yl=!0),De!==null&&(De=De.next={lane:0,tag:ge.tag,payload:ge.payload,callback:null,next:null});e:{var Ge=e,Fe=ge;Le=t;var ft=i;switch(Fe.tag){case 1:if(Ge=Fe.payload,typeof Ge=="function"){Ne=Ge.call(ft,Ne,Le);break e}Ne=Ge;break e;case 3:Ge.flags=Ge.flags&-65537|128;case 0:if(Ge=Fe.payload,Le=typeof Ge=="function"?Ge.call(ft,Ne,Le):Ge,Le==null)break e;Ne=u({},Ne,Le);break e;case 2:fi=!0}}Le=ge.callback,Le!==null&&(e.flags|=64,Te&&(e.flags|=8192),Te=x.callbacks,Te===null?x.callbacks=[Le]:Te.push(Le))}else Te={lane:Le,tag:ge.tag,payload:ge.payload,callback:ge.callback,next:null},De===null?(Re=De=Te,be=Ne):De=De.next=Te,ae|=Le;if(ge=ge.next,ge===null){if(ge=x.shared.pending,ge===null)break;Te=ge,ge=Te.next,Te.next=null,x.lastBaseUpdate=Te,x.shared.pending=null}}while(!0);De===null&&(be=Ne),x.baseState=be,x.firstBaseUpdate=Re,x.lastBaseUpdate=De,K===null&&(x.shared.lanes=0),Si|=ae,e.lanes=ae,e.memoizedState=Ne}}function Fg(e,t){if(typeof e!="function")throw Error(l(191,e));e.call(t)}function Vg(e,t){var i=e.callbacks;if(i!==null)for(e.callbacks=null,e=0;e<i.length;e++)Fg(i[e],t)}var Ts=G(null),Zo=G(0);function jg(e,t){e=$n,W(Zo,e),W(Ts,t),$n=e|t.baseLanes}function Wl(){W(Zo,$n),W(Ts,Ts.current)}function Ql(){$n=Zo.current,re(Ts),re(Zo)}var yi=0,Qe=null,ut=null,At=null,$o=!1,Ds=!1,es=!1,Jo=0,qr=0,Bs=null,pk=0;function kt(){throw Error(l(321))}function Xl(e,t){if(t===null)return!1;for(var i=0;i<t.length&&i<e.length;i++)if(!an(e[i],t[i]))return!1;return!0}function Zl(e,t,i,r,x,K){return yi=K,Qe=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,O.H=e===null||e.memoizedState===null?Lp:Tp,es=!1,K=i(r,x),es=!1,Ds&&(K=Yg(t,i,r,x)),Gg(e),K}function Gg(e){O.H=ra;var t=ut!==null&&ut.next!==null;if(yi=0,At=ut=Qe=null,$o=!1,qr=0,Bs=null,t)throw Error(l(300));e===null||qt||(e=e.dependencies,e!==null&&Go(e)&&(qt=!0))}function Yg(e,t,i,r){Qe=e;var x=0;do{if(Ds&&(Bs=null),qr=0,Ds=!1,25<=x)throw Error(l(301));if(x+=1,At=ut=null,e.updateQueue!=null){var K=e.updateQueue;K.lastEffect=null,K.events=null,K.stores=null,K.memoCache!=null&&(K.memoCache.index=0)}O.H=kk,K=t(i,r)}while(Ds);return K}function yk(){var e=O.H,t=e.useState()[0];return t=typeof t.then=="function"?Cr(t):t,e=e.useState()[0],(ut!==null?ut.memoizedState:null)!==e&&(Qe.flags|=1024),t}function $l(){var e=Jo!==0;return Jo=0,e}function Jl(e,t,i){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~i}function ec(e){if($o){for(e=e.memoizedState;e!==null;){var t=e.queue;t!==null&&(t.pending=null),e=e.next}$o=!1}yi=0,At=ut=Qe=null,Ds=!1,qr=Jo=0,Bs=null}function $t(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return At===null?Qe.memoizedState=At=e:At=At.next=e,At}function Rt(){if(ut===null){var e=Qe.alternate;e=e!==null?e.memoizedState:null}else e=ut.next;var t=At===null?Qe.memoizedState:At.next;if(t!==null)At=t,ut=e;else{if(e===null)throw Qe.alternate===null?Error(l(467)):Error(l(310));ut=e,e={memoizedState:ut.memoizedState,baseState:ut.baseState,baseQueue:ut.baseQueue,queue:ut.queue,next:null},At===null?Qe.memoizedState=At=e:At=At.next=e}return At}function tc(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Cr(e){var t=qr;return qr+=1,Bs===null&&(Bs=[]),e=Kg(Bs,e,t),t=Qe,(At===null?t.memoizedState:At.next)===null&&(t=t.alternate,O.H=t===null||t.memoizedState===null?Lp:Tp),e}function ea(e){if(e!==null&&typeof e=="object"){if(typeof e.then=="function")return Cr(e);if(e.$$typeof===j)return Ht(e)}throw Error(l(438,String(e)))}function nc(e){var t=null,i=Qe.updateQueue;if(i!==null&&(t=i.memoCache),t==null){var r=Qe.alternate;r!==null&&(r=r.updateQueue,r!==null&&(r=r.memoCache,r!=null&&(t={data:r.data.map(function(x){return x.slice()}),index:0})))}if(t==null&&(t={data:[],index:0}),i===null&&(i=tc(),Qe.updateQueue=i),i.memoCache=t,i=t.data[t.index],i===void 0)for(i=t.data[t.index]=Array(e),r=0;r<e;r++)i[r]=T;return t.index++,i}function Gn(e,t){return typeof t=="function"?t(e):t}function ta(e){var t=Rt();return ic(t,ut,e)}function ic(e,t,i){var r=e.queue;if(r===null)throw Error(l(311));r.lastRenderedReducer=i;var x=e.baseQueue,K=r.pending;if(K!==null){if(x!==null){var ae=x.next;x.next=K.next,K.next=ae}t.baseQueue=x=K,r.pending=null}if(K=e.baseState,x===null)e.memoizedState=K;else{t=x.next;var ge=ae=null,be=null,Re=t,De=!1;do{var Ne=Re.lane&-536870913;if(Ne!==Re.lane?(nt&Ne)===Ne:(yi&Ne)===Ne){var Le=Re.revertLane;if(Le===0)be!==null&&(be=be.next={lane:0,revertLane:0,action:Re.action,hasEagerState:Re.hasEagerState,eagerState:Re.eagerState,next:null}),Ne===Rs&&(De=!0);else if((yi&Le)===Le){Re=Re.next,Le===Rs&&(De=!0);continue}else Ne={lane:0,revertLane:Re.revertLane,action:Re.action,hasEagerState:Re.hasEagerState,eagerState:Re.eagerState,next:null},be===null?(ge=be=Ne,ae=K):be=be.next=Ne,Qe.lanes|=Le,Si|=Le;Ne=Re.action,es&&i(K,Ne),K=Re.hasEagerState?Re.eagerState:i(K,Ne)}else Le={lane:Ne,revertLane:Re.revertLane,action:Re.action,hasEagerState:Re.hasEagerState,eagerState:Re.eagerState,next:null},be===null?(ge=be=Le,ae=K):be=be.next=Le,Qe.lanes|=Ne,Si|=Ne;Re=Re.next}while(Re!==null&&Re!==t);if(be===null?ae=K:be.next=ge,!an(K,e.memoizedState)&&(qt=!0,De&&(i=Ls,i!==null)))throw i;e.memoizedState=K,e.baseState=ae,e.baseQueue=be,r.lastRenderedState=K}return x===null&&(r.lanes=0),[e.memoizedState,r.dispatch]}function sc(e){var t=Rt(),i=t.queue;if(i===null)throw Error(l(311));i.lastRenderedReducer=e;var r=i.dispatch,x=i.pending,K=t.memoizedState;if(x!==null){i.pending=null;var ae=x=x.next;do K=e(K,ae.action),ae=ae.next;while(ae!==x);an(K,t.memoizedState)||(qt=!0),t.memoizedState=K,t.baseQueue===null&&(t.baseState=K),i.lastRenderedState=K}return[K,r]}function Wg(e,t,i){var r=Qe,x=Rt(),K=ot;if(K){if(i===void 0)throw Error(l(407));i=i()}else i=t();var ae=!an((ut||x).memoizedState,i);ae&&(x.memoizedState=i,qt=!0),x=x.queue;var ge=Zg.bind(null,r,x,e);if(Mr(2048,8,ge,[e]),x.getSnapshot!==t||ae||At!==null&&At.memoizedState.tag&1){if(r.flags|=2048,Ns(9,na(),Xg.bind(null,r,x,i,t),null),yt===null)throw Error(l(349));K||(yi&124)!==0||Qg(r,t,i)}return i}function Qg(e,t,i){e.flags|=16384,e={getSnapshot:t,value:i},t=Qe.updateQueue,t===null?(t=tc(),Qe.updateQueue=t,t.stores=[e]):(i=t.stores,i===null?t.stores=[e]:i.push(e))}function Xg(e,t,i,r){t.value=i,t.getSnapshot=r,$g(t)&&Jg(e)}function Zg(e,t,i){return i(function(){$g(t)&&Jg(e)})}function $g(e){var t=e.getSnapshot;e=e.value;try{var i=t();return!an(e,i)}catch{return!0}}function Jg(e){var t=Ss(e,2);t!==null&&fn(t,e,2)}function rc(e){var t=$t();if(typeof e=="function"){var i=e;if(e=i(),es){ye(!0);try{i()}finally{ye(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Gn,lastRenderedState:e},t}function ep(e,t,i,r){return e.baseState=i,ic(e,ut,typeof r=="function"?r:Gn)}function _k(e,t,i,r,x){if(sa(e))throw Error(l(485));if(e=t.action,e!==null){var K={payload:x,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(ae){K.listeners.push(ae)}};O.T!==null?i(!0):K.isTransition=!1,r(K),i=t.pending,i===null?(K.next=t.pending=K,tp(t,K)):(K.next=i.next,t.pending=i.next=K)}}function tp(e,t){var i=t.action,r=t.payload,x=e.state;if(t.isTransition){var K=O.T,ae={};O.T=ae;try{var ge=i(x,r),be=O.S;be!==null&&be(ae,ge),np(e,t,ge)}catch(Re){oc(e,t,Re)}finally{O.T=K}}else try{K=i(x,r),np(e,t,K)}catch(Re){oc(e,t,Re)}}function np(e,t,i){i!==null&&typeof i=="object"&&typeof i.then=="function"?i.then(function(r){ip(e,t,r)},function(r){return oc(e,t,r)}):ip(e,t,i)}function ip(e,t,i){t.status="fulfilled",t.value=i,sp(t),e.state=i,t=e.pending,t!==null&&(i=t.next,i===t?e.pending=null:(i=i.next,t.next=i,tp(e,i)))}function oc(e,t,i){var r=e.pending;if(e.pending=null,r!==null){r=r.next;do t.status="rejected",t.reason=i,sp(t),t=t.next;while(t!==r)}e.action=null}function sp(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function rp(e,t){return t}function op(e,t){if(ot){var i=yt.formState;if(i!==null){e:{var r=Qe;if(ot){if(bt){t:{for(var x=bt,K=Bn;x.nodeType!==8;){if(!K){x=null;break t}if(x=An(x.nextSibling),x===null){x=null;break t}}K=x.data,x=K==="F!"||K==="F"?x:null}if(x){bt=An(x.nextSibling),r=x.data==="F!";break e}}Xi(r)}r=!1}r&&(t=i[0])}}return i=$t(),i.memoizedState=i.baseState=t,r={pending:null,lanes:0,dispatch:null,lastRenderedReducer:rp,lastRenderedState:t},i.queue=r,i=Ep.bind(null,Qe,r),r.dispatch=i,r=rc(!1),K=uc.bind(null,Qe,!1,r.queue),r=$t(),x={state:t,dispatch:null,action:e,pending:null},r.queue=x,i=_k.bind(null,Qe,x,K,i),x.dispatch=i,r.memoizedState=e,[t,i,!1]}function ap(e){var t=Rt();return lp(t,ut,e)}function lp(e,t,i){if(t=ic(e,t,rp)[0],e=ta(Gn)[0],typeof t=="object"&&t!==null&&typeof t.then=="function")try{var r=Cr(t)}catch(ae){throw ae===Lr?Qo:ae}else r=t;t=Rt();var x=t.queue,K=x.dispatch;return i!==t.memoizedState&&(Qe.flags|=2048,Ns(9,na(),mk.bind(null,x,i),null)),[r,K,e]}function mk(e,t){e.action=t}function cp(e){var t=Rt(),i=ut;if(i!==null)return lp(t,i,e);Rt(),t=t.memoizedState,i=Rt();var r=i.queue.dispatch;return i.memoizedState=e,[t,r,!1]}function Ns(e,t,i,r){return e={tag:e,create:i,deps:r,inst:t,next:null},t=Qe.updateQueue,t===null&&(t=tc(),Qe.updateQueue=t),i=t.lastEffect,i===null?t.lastEffect=e.next=e:(r=i.next,i.next=e,e.next=r,t.lastEffect=e),e}function na(){return{destroy:void 0,resource:void 0}}function hp(){return Rt().memoizedState}function ia(e,t,i,r){var x=$t();r=r===void 0?null:r,Qe.flags|=e,x.memoizedState=Ns(1|t,na(),i,r)}function Mr(e,t,i,r){var x=Rt();r=r===void 0?null:r;var K=x.memoizedState.inst;ut!==null&&r!==null&&Xl(r,ut.memoizedState.deps)?x.memoizedState=Ns(t,K,i,r):(Qe.flags|=e,x.memoizedState=Ns(1|t,K,i,r))}function up(e,t){ia(8390656,8,e,t)}function dp(e,t){Mr(2048,8,e,t)}function fp(e,t){return Mr(4,2,e,t)}function gp(e,t){return Mr(4,4,e,t)}function pp(e,t){if(typeof t=="function"){e=e();var i=t(e);return function(){typeof i=="function"?i():t(null)}}if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function yp(e,t,i){i=i!=null?i.concat([e]):null,Mr(4,4,pp.bind(null,t,e),i)}function ac(){}function _p(e,t){var i=Rt();t=t===void 0?null:t;var r=i.memoizedState;return t!==null&&Xl(t,r[1])?r[0]:(i.memoizedState=[e,t],e)}function mp(e,t){var i=Rt();t=t===void 0?null:t;var r=i.memoizedState;if(t!==null&&Xl(t,r[1]))return r[0];if(r=e(),es){ye(!0);try{e()}finally{ye(!1)}}return i.memoizedState=[r,t],r}function lc(e,t,i){return i===void 0||(yi&1073741824)!==0?e.memoizedState=t:(e.memoizedState=i,e=vy(),Qe.lanes|=e,Si|=e,i)}function wp(e,t,i,r){return an(i,t)?i:Ts.current!==null?(e=lc(e,i,r),an(e,t)||(qt=!0),e):(yi&42)===0?(qt=!0,e.memoizedState=i):(e=vy(),Qe.lanes|=e,Si|=e,t)}function bp(e,t,i,r,x){var K=P.p;P.p=K!==0&&8>K?K:8;var ae=O.T,ge={};O.T=ge,uc(e,!1,t,i);try{var be=x(),Re=O.S;if(Re!==null&&Re(ge,be),be!==null&&typeof be=="object"&&typeof be.then=="function"){var De=gk(be,r);Ur(e,t,De,dn(e))}else Ur(e,t,r,dn(e))}catch(Ne){Ur(e,t,{then:function(){},status:"rejected",reason:Ne},dn())}finally{P.p=K,O.T=ae}}function wk(){}function cc(e,t,i,r){if(e.tag!==5)throw Error(l(476));var x=vp(e).queue;bp(e,x,t,Z,i===null?wk:function(){return kp(e),i(r)})}function vp(e){var t=e.memoizedState;if(t!==null)return t;t={memoizedState:Z,baseState:Z,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Gn,lastRenderedState:Z},next:null};var i={};return t.next={memoizedState:i,baseState:i,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Gn,lastRenderedState:i},next:null},e.memoizedState=t,e=e.alternate,e!==null&&(e.memoizedState=t),t}function kp(e){var t=vp(e).next.queue;Ur(e,t,{},dn())}function hc(){return Ht(eo)}function Sp(){return Rt().memoizedState}function xp(){return Rt().memoizedState}function bk(e){for(var t=e.return;t!==null;){switch(t.tag){case 24:case 3:var i=dn();e=gi(i);var r=pi(t,e,i);r!==null&&(fn(r,t,i),Dr(r,t,i)),t={cache:Kl()},e.payload=t;return}t=t.return}}function vk(e,t,i){var r=dn();i={lane:r,revertLane:0,action:i,hasEagerState:!1,eagerState:null,next:null},sa(e)?Ap(t,i):(i=Dl(e,t,i,r),i!==null&&(fn(i,e,r),Rp(i,t,r)))}function Ep(e,t,i){var r=dn();Ur(e,t,i,r)}function Ur(e,t,i,r){var x={lane:r,revertLane:0,action:i,hasEagerState:!1,eagerState:null,next:null};if(sa(e))Ap(t,x);else{var K=e.alternate;if(e.lanes===0&&(K===null||K.lanes===0)&&(K=t.lastRenderedReducer,K!==null))try{var ae=t.lastRenderedState,ge=K(ae,i);if(x.hasEagerState=!0,x.eagerState=ge,an(ge,ae))return zo(e,t,x,0),yt===null&&Ko(),!1}catch{}finally{}if(i=Dl(e,t,x,r),i!==null)return fn(i,e,r),Rp(i,t,r),!0}return!1}function uc(e,t,i,r){if(r={lane:2,revertLane:Fc(),action:r,hasEagerState:!1,eagerState:null,next:null},sa(e)){if(t)throw Error(l(479))}else t=Dl(e,i,r,2),t!==null&&fn(t,e,2)}function sa(e){var t=e.alternate;return e===Qe||t!==null&&t===Qe}function Ap(e,t){Ds=$o=!0;var i=e.pending;i===null?t.next=t:(t.next=i.next,i.next=t),e.pending=t}function Rp(e,t,i){if((i&4194048)!==0){var r=t.lanes;r&=e.pendingLanes,i|=r,t.lanes=i,ko(e,i)}}var ra={readContext:Ht,use:ea,useCallback:kt,useContext:kt,useEffect:kt,useImperativeHandle:kt,useLayoutEffect:kt,useInsertionEffect:kt,useMemo:kt,useReducer:kt,useRef:kt,useState:kt,useDebugValue:kt,useDeferredValue:kt,useTransition:kt,useSyncExternalStore:kt,useId:kt,useHostTransitionStatus:kt,useFormState:kt,useActionState:kt,useOptimistic:kt,useMemoCache:kt,useCacheRefresh:kt},Lp={readContext:Ht,use:ea,useCallback:function(e,t){return $t().memoizedState=[e,t===void 0?null:t],e},useContext:Ht,useEffect:up,useImperativeHandle:function(e,t,i){i=i!=null?i.concat([e]):null,ia(4194308,4,pp.bind(null,t,e),i)},useLayoutEffect:function(e,t){return ia(4194308,4,e,t)},useInsertionEffect:function(e,t){ia(4,2,e,t)},useMemo:function(e,t){var i=$t();t=t===void 0?null:t;var r=e();if(es){ye(!0);try{e()}finally{ye(!1)}}return i.memoizedState=[r,t],r},useReducer:function(e,t,i){var r=$t();if(i!==void 0){var x=i(t);if(es){ye(!0);try{i(t)}finally{ye(!1)}}}else x=t;return r.memoizedState=r.baseState=x,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:x},r.queue=e,e=e.dispatch=vk.bind(null,Qe,e),[r.memoizedState,e]},useRef:function(e){var t=$t();return e={current:e},t.memoizedState=e},useState:function(e){e=rc(e);var t=e.queue,i=Ep.bind(null,Qe,t);return t.dispatch=i,[e.memoizedState,i]},useDebugValue:ac,useDeferredValue:function(e,t){var i=$t();return lc(i,e,t)},useTransition:function(){var e=rc(!1);return e=bp.bind(null,Qe,e.queue,!0,!1),$t().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,i){var r=Qe,x=$t();if(ot){if(i===void 0)throw Error(l(407));i=i()}else{if(i=t(),yt===null)throw Error(l(349));(nt&124)!==0||Qg(r,t,i)}x.memoizedState=i;var K={value:i,getSnapshot:t};return x.queue=K,up(Zg.bind(null,r,K,e),[e]),r.flags|=2048,Ns(9,na(),Xg.bind(null,r,K,i,t),null),i},useId:function(){var e=$t(),t=yt.identifierPrefix;if(ot){var i=Fn,r=Hn;i=(r&~(1<<32-me(r)-1)).toString(32)+i,t="«"+t+"R"+i,i=Jo++,0<i&&(t+="H"+i.toString(32)),t+="»"}else i=pk++,t="«"+t+"r"+i.toString(32)+"»";return e.memoizedState=t},useHostTransitionStatus:hc,useFormState:op,useActionState:op,useOptimistic:function(e){var t=$t();t.memoizedState=t.baseState=e;var i={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=i,t=uc.bind(null,Qe,!0,i),i.dispatch=t,[e,t]},useMemoCache:nc,useCacheRefresh:function(){return $t().memoizedState=bk.bind(null,Qe)}},Tp={readContext:Ht,use:ea,useCallback:_p,useContext:Ht,useEffect:dp,useImperativeHandle:yp,useInsertionEffect:fp,useLayoutEffect:gp,useMemo:mp,useReducer:ta,useRef:hp,useState:function(){return ta(Gn)},useDebugValue:ac,useDeferredValue:function(e,t){var i=Rt();return wp(i,ut.memoizedState,e,t)},useTransition:function(){var e=ta(Gn)[0],t=Rt().memoizedState;return[typeof e=="boolean"?e:Cr(e),t]},useSyncExternalStore:Wg,useId:Sp,useHostTransitionStatus:hc,useFormState:ap,useActionState:ap,useOptimistic:function(e,t){var i=Rt();return ep(i,ut,e,t)},useMemoCache:nc,useCacheRefresh:xp},kk={readContext:Ht,use:ea,useCallback:_p,useContext:Ht,useEffect:dp,useImperativeHandle:yp,useInsertionEffect:fp,useLayoutEffect:gp,useMemo:mp,useReducer:sc,useRef:hp,useState:function(){return sc(Gn)},useDebugValue:ac,useDeferredValue:function(e,t){var i=Rt();return ut===null?lc(i,e,t):wp(i,ut.memoizedState,e,t)},useTransition:function(){var e=sc(Gn)[0],t=Rt().memoizedState;return[typeof e=="boolean"?e:Cr(e),t]},useSyncExternalStore:Wg,useId:Sp,useHostTransitionStatus:hc,useFormState:cp,useActionState:cp,useOptimistic:function(e,t){var i=Rt();return ut!==null?ep(i,ut,e,t):(i.baseState=e,[e,i.queue.dispatch])},useMemoCache:nc,useCacheRefresh:xp},qs=null,Or=0;function oa(e){var t=Or;return Or+=1,qs===null&&(qs=[]),Kg(qs,e,t)}function Pr(e,t){t=t.props.ref,e.ref=t!==void 0?t:null}function aa(e,t){throw t.$$typeof===f?Error(l(525)):(e=Object.prototype.toString.call(t),Error(l(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)))}function Dp(e){var t=e._init;return t(e._payload)}function Bp(e){function t(xe,Se){if(e){var Ae=xe.deletions;Ae===null?(xe.deletions=[Se],xe.flags|=16):Ae.push(Se)}}function i(xe,Se){if(!e)return null;for(;Se!==null;)t(xe,Se),Se=Se.sibling;return null}function r(xe){for(var Se=new Map;xe!==null;)xe.key!==null?Se.set(xe.key,xe):Se.set(xe.index,xe),xe=xe.sibling;return Se}function x(xe,Se){return xe=zn(xe,Se),xe.index=0,xe.sibling=null,xe}function K(xe,Se,Ae){return xe.index=Ae,e?(Ae=xe.alternate,Ae!==null?(Ae=Ae.index,Ae<Se?(xe.flags|=67108866,Se):Ae):(xe.flags|=67108866,Se)):(xe.flags|=1048576,Se)}function ae(xe){return e&&xe.alternate===null&&(xe.flags|=67108866),xe}function ge(xe,Se,Ae,Be){return Se===null||Se.tag!==6?(Se=Nl(Ae,xe.mode,Be),Se.return=xe,Se):(Se=x(Se,Ae),Se.return=xe,Se)}function be(xe,Se,Ae,Be){var Ie=Ae.type;return Ie===b?De(xe,Se,Ae.props.children,Be,Ae.key):Se!==null&&(Se.elementType===Ie||typeof Ie=="object"&&Ie!==null&&Ie.$$typeof===q&&Dp(Ie)===Se.type)?(Se=x(Se,Ae.props),Pr(Se,Ae),Se.return=xe,Se):(Se=Fo(Ae.type,Ae.key,Ae.props,null,xe.mode,Be),Pr(Se,Ae),Se.return=xe,Se)}function Re(xe,Se,Ae,Be){return Se===null||Se.tag!==4||Se.stateNode.containerInfo!==Ae.containerInfo||Se.stateNode.implementation!==Ae.implementation?(Se=ql(Ae,xe.mode,Be),Se.return=xe,Se):(Se=x(Se,Ae.children||[]),Se.return=xe,Se)}function De(xe,Se,Ae,Be,Ie){return Se===null||Se.tag!==7?(Se=Gi(Ae,xe.mode,Be,Ie),Se.return=xe,Se):(Se=x(Se,Ae),Se.return=xe,Se)}function Ne(xe,Se,Ae){if(typeof Se=="string"&&Se!==""||typeof Se=="number"||typeof Se=="bigint")return Se=Nl(""+Se,xe.mode,Ae),Se.return=xe,Se;if(typeof Se=="object"&&Se!==null){switch(Se.$$typeof){case m:return Ae=Fo(Se.type,Se.key,Se.props,null,xe.mode,Ae),Pr(Ae,Se),Ae.return=xe,Ae;case E:return Se=ql(Se,xe.mode,Ae),Se.return=xe,Se;case q:var Be=Se._init;return Se=Be(Se._payload),Ne(xe,Se,Ae)}if(ue(Se)||le(Se))return Se=Gi(Se,xe.mode,Ae,null),Se.return=xe,Se;if(typeof Se.then=="function")return Ne(xe,oa(Se),Ae);if(Se.$$typeof===j)return Ne(xe,Yo(xe,Se),Ae);aa(xe,Se)}return null}function Le(xe,Se,Ae,Be){var Ie=Se!==null?Se.key:null;if(typeof Ae=="string"&&Ae!==""||typeof Ae=="number"||typeof Ae=="bigint")return Ie!==null?null:ge(xe,Se,""+Ae,Be);if(typeof Ae=="object"&&Ae!==null){switch(Ae.$$typeof){case m:return Ae.key===Ie?be(xe,Se,Ae,Be):null;case E:return Ae.key===Ie?Re(xe,Se,Ae,Be):null;case q:return Ie=Ae._init,Ae=Ie(Ae._payload),Le(xe,Se,Ae,Be)}if(ue(Ae)||le(Ae))return Ie!==null?null:De(xe,Se,Ae,Be,null);if(typeof Ae.then=="function")return Le(xe,Se,oa(Ae),Be);if(Ae.$$typeof===j)return Le(xe,Se,Yo(xe,Ae),Be);aa(xe,Ae)}return null}function Te(xe,Se,Ae,Be,Ie){if(typeof Be=="string"&&Be!==""||typeof Be=="number"||typeof Be=="bigint")return xe=xe.get(Ae)||null,ge(Se,xe,""+Be,Ie);if(typeof Be=="object"&&Be!==null){switch(Be.$$typeof){case m:return xe=xe.get(Be.key===null?Ae:Be.key)||null,be(Se,xe,Be,Ie);case E:return xe=xe.get(Be.key===null?Ae:Be.key)||null,Re(Se,xe,Be,Ie);case q:var Ze=Be._init;return Be=Ze(Be._payload),Te(xe,Se,Ae,Be,Ie)}if(ue(Be)||le(Be))return xe=xe.get(Ae)||null,De(Se,xe,Be,Ie,null);if(typeof Be.then=="function")return Te(xe,Se,Ae,oa(Be),Ie);if(Be.$$typeof===j)return Te(xe,Se,Ae,Yo(Se,Be),Ie);aa(Se,Be)}return null}function Ge(xe,Se,Ae,Be){for(var Ie=null,Ze=null,Ke=Se,Ve=Se=0,Mt=null;Ke!==null&&Ve<Ae.length;Ve++){Ke.index>Ve?(Mt=Ke,Ke=null):Mt=Ke.sibling;var st=Le(xe,Ke,Ae[Ve],Be);if(st===null){Ke===null&&(Ke=Mt);break}e&&Ke&&st.alternate===null&&t(xe,Ke),Se=K(st,Se,Ve),Ze===null?Ie=st:Ze.sibling=st,Ze=st,Ke=Mt}if(Ve===Ae.length)return i(xe,Ke),ot&&Wi(xe,Ve),Ie;if(Ke===null){for(;Ve<Ae.length;Ve++)Ke=Ne(xe,Ae[Ve],Be),Ke!==null&&(Se=K(Ke,Se,Ve),Ze===null?Ie=Ke:Ze.sibling=Ke,Ze=Ke);return ot&&Wi(xe,Ve),Ie}for(Ke=r(Ke);Ve<Ae.length;Ve++)Mt=Te(Ke,xe,Ve,Ae[Ve],Be),Mt!==null&&(e&&Mt.alternate!==null&&Ke.delete(Mt.key===null?Ve:Mt.key),Se=K(Mt,Se,Ve),Ze===null?Ie=Mt:Ze.sibling=Mt,Ze=Mt);return e&&Ke.forEach(function(Ni){return t(xe,Ni)}),ot&&Wi(xe,Ve),Ie}function Fe(xe,Se,Ae,Be){if(Ae==null)throw Error(l(151));for(var Ie=null,Ze=null,Ke=Se,Ve=Se=0,Mt=null,st=Ae.next();Ke!==null&&!st.done;Ve++,st=Ae.next()){Ke.index>Ve?(Mt=Ke,Ke=null):Mt=Ke.sibling;var Ni=Le(xe,Ke,st.value,Be);if(Ni===null){Ke===null&&(Ke=Mt);break}e&&Ke&&Ni.alternate===null&&t(xe,Ke),Se=K(Ni,Se,Ve),Ze===null?Ie=Ni:Ze.sibling=Ni,Ze=Ni,Ke=Mt}if(st.done)return i(xe,Ke),ot&&Wi(xe,Ve),Ie;if(Ke===null){for(;!st.done;Ve++,st=Ae.next())st=Ne(xe,st.value,Be),st!==null&&(Se=K(st,Se,Ve),Ze===null?Ie=st:Ze.sibling=st,Ze=st);return ot&&Wi(xe,Ve),Ie}for(Ke=r(Ke);!st.done;Ve++,st=Ae.next())st=Te(Ke,xe,Ve,st.value,Be),st!==null&&(e&&st.alternate!==null&&Ke.delete(st.key===null?Ve:st.key),Se=K(st,Se,Ve),Ze===null?Ie=st:Ze.sibling=st,Ze=st);return e&&Ke.forEach(function(S1){return t(xe,S1)}),ot&&Wi(xe,Ve),Ie}function ft(xe,Se,Ae,Be){if(typeof Ae=="object"&&Ae!==null&&Ae.type===b&&Ae.key===null&&(Ae=Ae.props.children),typeof Ae=="object"&&Ae!==null){switch(Ae.$$typeof){case m:e:{for(var Ie=Ae.key;Se!==null;){if(Se.key===Ie){if(Ie=Ae.type,Ie===b){if(Se.tag===7){i(xe,Se.sibling),Be=x(Se,Ae.props.children),Be.return=xe,xe=Be;break e}}else if(Se.elementType===Ie||typeof Ie=="object"&&Ie!==null&&Ie.$$typeof===q&&Dp(Ie)===Se.type){i(xe,Se.sibling),Be=x(Se,Ae.props),Pr(Be,Ae),Be.return=xe,xe=Be;break e}i(xe,Se);break}else t(xe,Se);Se=Se.sibling}Ae.type===b?(Be=Gi(Ae.props.children,xe.mode,Be,Ae.key),Be.return=xe,xe=Be):(Be=Fo(Ae.type,Ae.key,Ae.props,null,xe.mode,Be),Pr(Be,Ae),Be.return=xe,xe=Be)}return ae(xe);case E:e:{for(Ie=Ae.key;Se!==null;){if(Se.key===Ie)if(Se.tag===4&&Se.stateNode.containerInfo===Ae.containerInfo&&Se.stateNode.implementation===Ae.implementation){i(xe,Se.sibling),Be=x(Se,Ae.children||[]),Be.return=xe,xe=Be;break e}else{i(xe,Se);break}else t(xe,Se);Se=Se.sibling}Be=ql(Ae,xe.mode,Be),Be.return=xe,xe=Be}return ae(xe);case q:return Ie=Ae._init,Ae=Ie(Ae._payload),ft(xe,Se,Ae,Be)}if(ue(Ae))return Ge(xe,Se,Ae,Be);if(le(Ae)){if(Ie=le(Ae),typeof Ie!="function")throw Error(l(150));return Ae=Ie.call(Ae),Fe(xe,Se,Ae,Be)}if(typeof Ae.then=="function")return ft(xe,Se,oa(Ae),Be);if(Ae.$$typeof===j)return ft(xe,Se,Yo(xe,Ae),Be);aa(xe,Ae)}return typeof Ae=="string"&&Ae!==""||typeof Ae=="number"||typeof Ae=="bigint"?(Ae=""+Ae,Se!==null&&Se.tag===6?(i(xe,Se.sibling),Be=x(Se,Ae),Be.return=xe,xe=Be):(i(xe,Se),Be=Nl(Ae,xe.mode,Be),Be.return=xe,xe=Be),ae(xe)):i(xe,Se)}return function(xe,Se,Ae,Be){try{Or=0;var Ie=ft(xe,Se,Ae,Be);return qs=null,Ie}catch(Ke){if(Ke===Lr||Ke===Qo)throw Ke;var Ze=ln(29,Ke,null,xe.mode);return Ze.lanes=Be,Ze.return=xe,Ze}finally{}}}var Cs=Bp(!0),Np=Bp(!1),wn=G(null),Nn=null;function _i(e){var t=e.alternate;W(Dt,Dt.current&1),W(wn,e),Nn===null&&(t===null||Ts.current!==null||t.memoizedState!==null)&&(Nn=e)}function qp(e){if(e.tag===22){if(W(Dt,Dt.current),W(wn,e),Nn===null){var t=e.alternate;t!==null&&t.memoizedState!==null&&(Nn=e)}}else mi()}function mi(){W(Dt,Dt.current),W(wn,wn.current)}function Yn(e){re(wn),Nn===e&&(Nn=null),re(Dt)}var Dt=G(0);function la(e){for(var t=e;t!==null;){if(t.tag===13){var i=t.memoizedState;if(i!==null&&(i=i.dehydrated,i===null||i.data==="$?"||th(i)))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if((t.flags&128)!==0)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}function dc(e,t,i,r){t=e.memoizedState,i=i(r,t),i=i==null?t:u({},t,i),e.memoizedState=i,e.lanes===0&&(e.updateQueue.baseState=i)}var fc={enqueueSetState:function(e,t,i){e=e._reactInternals;var r=dn(),x=gi(r);x.payload=t,i!=null&&(x.callback=i),t=pi(e,x,r),t!==null&&(fn(t,e,r),Dr(t,e,r))},enqueueReplaceState:function(e,t,i){e=e._reactInternals;var r=dn(),x=gi(r);x.tag=1,x.payload=t,i!=null&&(x.callback=i),t=pi(e,x,r),t!==null&&(fn(t,e,r),Dr(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var i=dn(),r=gi(i);r.tag=2,t!=null&&(r.callback=t),t=pi(e,r,i),t!==null&&(fn(t,e,i),Dr(t,e,i))}};function Cp(e,t,i,r,x,K,ae){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,K,ae):t.prototype&&t.prototype.isPureReactComponent?!br(i,r)||!br(x,K):!0}function Mp(e,t,i,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(i,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(i,r),t.state!==e&&fc.enqueueReplaceState(t,t.state,null)}function ts(e,t){var i=t;if("ref"in t){i={};for(var r in t)r!=="ref"&&(i[r]=t[r])}if(e=e.defaultProps){i===t&&(i=u({},i));for(var x in e)i[x]===void 0&&(i[x]=e[x])}return i}var ca=typeof reportError=="function"?reportError:function(e){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof e=="object"&&e!==null&&typeof e.message=="string"?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",e);return}console.error(e)};function Up(e){ca(e)}function Op(e){console.error(e)}function Pp(e){ca(e)}function ha(e,t){try{var i=e.onUncaughtError;i(t.value,{componentStack:t.stack})}catch(r){setTimeout(function(){throw r})}}function Ip(e,t,i){try{var r=e.onCaughtError;r(i.value,{componentStack:i.stack,errorBoundary:t.tag===1?t.stateNode:null})}catch(x){setTimeout(function(){throw x})}}function gc(e,t,i){return i=gi(i),i.tag=3,i.payload={element:null},i.callback=function(){ha(e,t)},i}function Kp(e){return e=gi(e),e.tag=3,e}function zp(e,t,i,r){var x=i.type.getDerivedStateFromError;if(typeof x=="function"){var K=r.value;e.payload=function(){return x(K)},e.callback=function(){Ip(t,i,r)}}var ae=i.stateNode;ae!==null&&typeof ae.componentDidCatch=="function"&&(e.callback=function(){Ip(t,i,r),typeof x!="function"&&(xi===null?xi=new Set([this]):xi.add(this));var ge=r.stack;this.componentDidCatch(r.value,{componentStack:ge!==null?ge:""})})}function Sk(e,t,i,r,x){if(i.flags|=32768,r!==null&&typeof r=="object"&&typeof r.then=="function"){if(t=i.alternate,t!==null&&Er(t,i,x,!0),i=wn.current,i!==null){switch(i.tag){case 13:return Nn===null?Pc():i.alternate===null&&vt===0&&(vt=3),i.flags&=-257,i.flags|=65536,i.lanes=x,r===Fl?i.flags|=16384:(t=i.updateQueue,t===null?i.updateQueue=new Set([r]):t.add(r),Kc(e,r,x)),!1;case 22:return i.flags|=65536,r===Fl?i.flags|=16384:(t=i.updateQueue,t===null?(t={transitions:null,markerInstances:null,retryQueue:new Set([r])},i.updateQueue=t):(i=t.retryQueue,i===null?t.retryQueue=new Set([r]):i.add(r)),Kc(e,r,x)),!1}throw Error(l(435,i.tag))}return Kc(e,r,x),Pc(),!1}if(ot)return t=wn.current,t!==null?((t.flags&65536)===0&&(t.flags|=256),t.flags|=65536,t.lanes=x,r!==Ul&&(e=Error(l(422),{cause:r}),xr(pn(e,i)))):(r!==Ul&&(t=Error(l(423),{cause:r}),xr(pn(t,i))),e=e.current.alternate,e.flags|=65536,x&=-x,e.lanes|=x,r=pn(r,i),x=gc(e.stateNode,r,x),Gl(e,x),vt!==4&&(vt=2)),!1;var K=Error(l(520),{cause:r});if(K=pn(K,i),jr===null?jr=[K]:jr.push(K),vt!==4&&(vt=2),t===null)return!0;r=pn(r,i),i=t;do{switch(i.tag){case 3:return i.flags|=65536,e=x&-x,i.lanes|=e,e=gc(i.stateNode,r,e),Gl(i,e),!1;case 1:if(t=i.type,K=i.stateNode,(i.flags&128)===0&&(typeof t.getDerivedStateFromError=="function"||K!==null&&typeof K.componentDidCatch=="function"&&(xi===null||!xi.has(K))))return i.flags|=65536,x&=-x,i.lanes|=x,x=Kp(x),zp(x,e,i,r),Gl(i,x),!1}i=i.return}while(i!==null);return!1}var Hp=Error(l(461)),qt=!1;function Ot(e,t,i,r){t.child=e===null?Np(t,null,i,r):Cs(t,e.child,i,r)}function Fp(e,t,i,r,x){i=i.render;var K=t.ref;if("ref"in r){var ae={};for(var ge in r)ge!=="ref"&&(ae[ge]=r[ge])}else ae=r;return $i(t),r=Zl(e,t,i,ae,K,x),ge=$l(),e!==null&&!qt?(Jl(e,t,x),Wn(e,t,x)):(ot&&ge&&Cl(t),t.flags|=1,Ot(e,t,r,x),t.child)}function Vp(e,t,i,r,x){if(e===null){var K=i.type;return typeof K=="function"&&!Bl(K)&&K.defaultProps===void 0&&i.compare===null?(t.tag=15,t.type=K,jp(e,t,K,r,x)):(e=Fo(i.type,null,r,t,t.mode,x),e.ref=t.ref,e.return=t,t.child=e)}if(K=e.child,!kc(e,x)){var ae=K.memoizedProps;if(i=i.compare,i=i!==null?i:br,i(ae,r)&&e.ref===t.ref)return Wn(e,t,x)}return t.flags|=1,e=zn(K,r),e.ref=t.ref,e.return=t,t.child=e}function jp(e,t,i,r,x){if(e!==null){var K=e.memoizedProps;if(br(K,r)&&e.ref===t.ref)if(qt=!1,t.pendingProps=r=K,kc(e,x))(e.flags&131072)!==0&&(qt=!0);else return t.lanes=e.lanes,Wn(e,t,x)}return pc(e,t,i,r,x)}function Gp(e,t,i){var r=t.pendingProps,x=r.children,K=e!==null?e.memoizedState:null;if(r.mode==="hidden"){if((t.flags&128)!==0){if(r=K!==null?K.baseLanes|i:i,e!==null){for(x=t.child=e.child,K=0;x!==null;)K=K|x.lanes|x.childLanes,x=x.sibling;t.childLanes=K&~r}else t.childLanes=0,t.child=null;return Yp(e,t,r,i)}if((i&536870912)!==0)t.memoizedState={baseLanes:0,cachePool:null},e!==null&&Wo(t,K!==null?K.cachePool:null),K!==null?jg(t,K):Wl(),qp(t);else return t.lanes=t.childLanes=536870912,Yp(e,t,K!==null?K.baseLanes|i:i,i)}else K!==null?(Wo(t,K.cachePool),jg(t,K),mi(),t.memoizedState=null):(e!==null&&Wo(t,null),Wl(),mi());return Ot(e,t,x,i),t.child}function Yp(e,t,i,r){var x=Hl();return x=x===null?null:{parent:Tt._currentValue,pool:x},t.memoizedState={baseLanes:i,cachePool:x},e!==null&&Wo(t,null),Wl(),qp(t),e!==null&&Er(e,t,r,!0),null}function ua(e,t){var i=t.ref;if(i===null)e!==null&&e.ref!==null&&(t.flags|=4194816);else{if(typeof i!="function"&&typeof i!="object")throw Error(l(284));(e===null||e.ref!==i)&&(t.flags|=4194816)}}function pc(e,t,i,r,x){return $i(t),i=Zl(e,t,i,r,void 0,x),r=$l(),e!==null&&!qt?(Jl(e,t,x),Wn(e,t,x)):(ot&&r&&Cl(t),t.flags|=1,Ot(e,t,i,x),t.child)}function Wp(e,t,i,r,x,K){return $i(t),t.updateQueue=null,i=Yg(t,r,i,x),Gg(e),r=$l(),e!==null&&!qt?(Jl(e,t,K),Wn(e,t,K)):(ot&&r&&Cl(t),t.flags|=1,Ot(e,t,i,K),t.child)}function Qp(e,t,i,r,x){if($i(t),t.stateNode===null){var K=xs,ae=i.contextType;typeof ae=="object"&&ae!==null&&(K=Ht(ae)),K=new i(r,K),t.memoizedState=K.state!==null&&K.state!==void 0?K.state:null,K.updater=fc,t.stateNode=K,K._reactInternals=t,K=t.stateNode,K.props=r,K.state=t.memoizedState,K.refs={},Vl(t),ae=i.contextType,K.context=typeof ae=="object"&&ae!==null?Ht(ae):xs,K.state=t.memoizedState,ae=i.getDerivedStateFromProps,typeof ae=="function"&&(dc(t,i,ae,r),K.state=t.memoizedState),typeof i.getDerivedStateFromProps=="function"||typeof K.getSnapshotBeforeUpdate=="function"||typeof K.UNSAFE_componentWillMount!="function"&&typeof K.componentWillMount!="function"||(ae=K.state,typeof K.componentWillMount=="function"&&K.componentWillMount(),typeof K.UNSAFE_componentWillMount=="function"&&K.UNSAFE_componentWillMount(),ae!==K.state&&fc.enqueueReplaceState(K,K.state,null),Nr(t,r,K,x),Br(),K.state=t.memoizedState),typeof K.componentDidMount=="function"&&(t.flags|=4194308),r=!0}else if(e===null){K=t.stateNode;var ge=t.memoizedProps,be=ts(i,ge);K.props=be;var Re=K.context,De=i.contextType;ae=xs,typeof De=="object"&&De!==null&&(ae=Ht(De));var Ne=i.getDerivedStateFromProps;De=typeof Ne=="function"||typeof K.getSnapshotBeforeUpdate=="function",ge=t.pendingProps!==ge,De||typeof K.UNSAFE_componentWillReceiveProps!="function"&&typeof K.componentWillReceiveProps!="function"||(ge||Re!==ae)&&Mp(t,K,r,ae),fi=!1;var Le=t.memoizedState;K.state=Le,Nr(t,r,K,x),Br(),Re=t.memoizedState,ge||Le!==Re||fi?(typeof Ne=="function"&&(dc(t,i,Ne,r),Re=t.memoizedState),(be=fi||Cp(t,i,be,r,Le,Re,ae))?(De||typeof K.UNSAFE_componentWillMount!="function"&&typeof K.componentWillMount!="function"||(typeof K.componentWillMount=="function"&&K.componentWillMount(),typeof K.UNSAFE_componentWillMount=="function"&&K.UNSAFE_componentWillMount()),typeof K.componentDidMount=="function"&&(t.flags|=4194308)):(typeof K.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=Re),K.props=r,K.state=Re,K.context=ae,r=be):(typeof K.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{K=t.stateNode,jl(e,t),ae=t.memoizedProps,De=ts(i,ae),K.props=De,Ne=t.pendingProps,Le=K.context,Re=i.contextType,be=xs,typeof Re=="object"&&Re!==null&&(be=Ht(Re)),ge=i.getDerivedStateFromProps,(Re=typeof ge=="function"||typeof K.getSnapshotBeforeUpdate=="function")||typeof K.UNSAFE_componentWillReceiveProps!="function"&&typeof K.componentWillReceiveProps!="function"||(ae!==Ne||Le!==be)&&Mp(t,K,r,be),fi=!1,Le=t.memoizedState,K.state=Le,Nr(t,r,K,x),Br();var Te=t.memoizedState;ae!==Ne||Le!==Te||fi||e!==null&&e.dependencies!==null&&Go(e.dependencies)?(typeof ge=="function"&&(dc(t,i,ge,r),Te=t.memoizedState),(De=fi||Cp(t,i,De,r,Le,Te,be)||e!==null&&e.dependencies!==null&&Go(e.dependencies))?(Re||typeof K.UNSAFE_componentWillUpdate!="function"&&typeof K.componentWillUpdate!="function"||(typeof K.componentWillUpdate=="function"&&K.componentWillUpdate(r,Te,be),typeof K.UNSAFE_componentWillUpdate=="function"&&K.UNSAFE_componentWillUpdate(r,Te,be)),typeof K.componentDidUpdate=="function"&&(t.flags|=4),typeof K.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof K.componentDidUpdate!="function"||ae===e.memoizedProps&&Le===e.memoizedState||(t.flags|=4),typeof K.getSnapshotBeforeUpdate!="function"||ae===e.memoizedProps&&Le===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=Te),K.props=r,K.state=Te,K.context=be,r=De):(typeof K.componentDidUpdate!="function"||ae===e.memoizedProps&&Le===e.memoizedState||(t.flags|=4),typeof K.getSnapshotBeforeUpdate!="function"||ae===e.memoizedProps&&Le===e.memoizedState||(t.flags|=1024),r=!1)}return K=r,ua(e,t),r=(t.flags&128)!==0,K||r?(K=t.stateNode,i=r&&typeof i.getDerivedStateFromError!="function"?null:K.render(),t.flags|=1,e!==null&&r?(t.child=Cs(t,e.child,null,x),t.child=Cs(t,null,i,x)):Ot(e,t,i,x),t.memoizedState=K.state,e=t.child):e=Wn(e,t,x),e}function Xp(e,t,i,r){return Sr(),t.flags|=256,Ot(e,t,i,r),t.child}var yc={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function _c(e){return{baseLanes:e,cachePool:Og()}}function mc(e,t,i){return e=e!==null?e.childLanes&~i:0,t&&(e|=bn),e}function Zp(e,t,i){var r=t.pendingProps,x=!1,K=(t.flags&128)!==0,ae;if((ae=K)||(ae=e!==null&&e.memoizedState===null?!1:(Dt.current&2)!==0),ae&&(x=!0,t.flags&=-129),ae=(t.flags&32)!==0,t.flags&=-33,e===null){if(ot){if(x?_i(t):mi(),ot){var ge=bt,be;if(be=ge){e:{for(be=ge,ge=Bn;be.nodeType!==8;){if(!ge){ge=null;break e}if(be=An(be.nextSibling),be===null){ge=null;break e}}ge=be}ge!==null?(t.memoizedState={dehydrated:ge,treeContext:Yi!==null?{id:Hn,overflow:Fn}:null,retryLane:536870912,hydrationErrors:null},be=ln(18,null,null,0),be.stateNode=ge,be.return=t,t.child=be,Wt=t,bt=null,be=!0):be=!1}be||Xi(t)}if(ge=t.memoizedState,ge!==null&&(ge=ge.dehydrated,ge!==null))return th(ge)?t.lanes=32:t.lanes=536870912,null;Yn(t)}return ge=r.children,r=r.fallback,x?(mi(),x=t.mode,ge=da({mode:"hidden",children:ge},x),r=Gi(r,x,i,null),ge.return=t,r.return=t,ge.sibling=r,t.child=ge,x=t.child,x.memoizedState=_c(i),x.childLanes=mc(e,ae,i),t.memoizedState=yc,r):(_i(t),wc(t,ge))}if(be=e.memoizedState,be!==null&&(ge=be.dehydrated,ge!==null)){if(K)t.flags&256?(_i(t),t.flags&=-257,t=bc(e,t,i)):t.memoizedState!==null?(mi(),t.child=e.child,t.flags|=128,t=null):(mi(),x=r.fallback,ge=t.mode,r=da({mode:"visible",children:r.children},ge),x=Gi(x,ge,i,null),x.flags|=2,r.return=t,x.return=t,r.sibling=x,t.child=r,Cs(t,e.child,null,i),r=t.child,r.memoizedState=_c(i),r.childLanes=mc(e,ae,i),t.memoizedState=yc,t=x);else if(_i(t),th(ge)){if(ae=ge.nextSibling&&ge.nextSibling.dataset,ae)var Re=ae.dgst;ae=Re,r=Error(l(419)),r.stack="",r.digest=ae,xr({value:r,source:null,stack:null}),t=bc(e,t,i)}else if(qt||Er(e,t,i,!1),ae=(i&e.childLanes)!==0,qt||ae){if(ae=yt,ae!==null&&(r=i&-i,r=(r&42)!==0?1:rr(r),r=(r&(ae.suspendedLanes|i))!==0?0:r,r!==0&&r!==be.retryLane))throw be.retryLane=r,Ss(e,r),fn(ae,e,r),Hp;ge.data==="$?"||Pc(),t=bc(e,t,i)}else ge.data==="$?"?(t.flags|=192,t.child=e.child,t=null):(e=be.treeContext,bt=An(ge.nextSibling),Wt=t,ot=!0,Qi=null,Bn=!1,e!==null&&(_n[mn++]=Hn,_n[mn++]=Fn,_n[mn++]=Yi,Hn=e.id,Fn=e.overflow,Yi=t),t=wc(t,r.children),t.flags|=4096);return t}return x?(mi(),x=r.fallback,ge=t.mode,be=e.child,Re=be.sibling,r=zn(be,{mode:"hidden",children:r.children}),r.subtreeFlags=be.subtreeFlags&65011712,Re!==null?x=zn(Re,x):(x=Gi(x,ge,i,null),x.flags|=2),x.return=t,r.return=t,r.sibling=x,t.child=r,r=x,x=t.child,ge=e.child.memoizedState,ge===null?ge=_c(i):(be=ge.cachePool,be!==null?(Re=Tt._currentValue,be=be.parent!==Re?{parent:Re,pool:Re}:be):be=Og(),ge={baseLanes:ge.baseLanes|i,cachePool:be}),x.memoizedState=ge,x.childLanes=mc(e,ae,i),t.memoizedState=yc,r):(_i(t),i=e.child,e=i.sibling,i=zn(i,{mode:"visible",children:r.children}),i.return=t,i.sibling=null,e!==null&&(ae=t.deletions,ae===null?(t.deletions=[e],t.flags|=16):ae.push(e)),t.child=i,t.memoizedState=null,i)}function wc(e,t){return t=da({mode:"visible",children:t},e.mode),t.return=e,e.child=t}function da(e,t){return e=ln(22,e,null,t),e.lanes=0,e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},e}function bc(e,t,i){return Cs(t,e.child,null,i),e=wc(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function $p(e,t,i){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),Pl(e.return,t,i)}function vc(e,t,i,r,x){var K=e.memoizedState;K===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:i,tailMode:x}:(K.isBackwards=t,K.rendering=null,K.renderingStartTime=0,K.last=r,K.tail=i,K.tailMode=x)}function Jp(e,t,i){var r=t.pendingProps,x=r.revealOrder,K=r.tail;if(Ot(e,t,r.children,i),r=Dt.current,(r&2)!==0)r=r&1|2,t.flags|=128;else{if(e!==null&&(e.flags&128)!==0)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&$p(e,i,t);else if(e.tag===19)$p(e,i,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}switch(W(Dt,r),x){case"forwards":for(i=t.child,x=null;i!==null;)e=i.alternate,e!==null&&la(e)===null&&(x=i),i=i.sibling;i=x,i===null?(x=t.child,t.child=null):(x=i.sibling,i.sibling=null),vc(t,!1,x,i,K);break;case"backwards":for(i=null,x=t.child,t.child=null;x!==null;){if(e=x.alternate,e!==null&&la(e)===null){t.child=x;break}e=x.sibling,x.sibling=i,i=x,x=e}vc(t,!0,i,null,K);break;case"together":vc(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Wn(e,t,i){if(e!==null&&(t.dependencies=e.dependencies),Si|=t.lanes,(i&t.childLanes)===0)if(e!==null){if(Er(e,t,i,!1),(i&t.childLanes)===0)return null}else return null;if(e!==null&&t.child!==e.child)throw Error(l(153));if(t.child!==null){for(e=t.child,i=zn(e,e.pendingProps),t.child=i,i.return=t;e.sibling!==null;)e=e.sibling,i=i.sibling=zn(e,e.pendingProps),i.return=t;i.sibling=null}return t.child}function kc(e,t){return(e.lanes&t)!==0?!0:(e=e.dependencies,!!(e!==null&&Go(e)))}function xk(e,t,i){switch(t.tag){case 3:H(t,t.stateNode.containerInfo),di(t,Tt,e.memoizedState.cache),Sr();break;case 27:case 5:ce(t);break;case 4:H(t,t.stateNode.containerInfo);break;case 10:di(t,t.type,t.memoizedProps.value);break;case 13:var r=t.memoizedState;if(r!==null)return r.dehydrated!==null?(_i(t),t.flags|=128,null):(i&t.child.childLanes)!==0?Zp(e,t,i):(_i(t),e=Wn(e,t,i),e!==null?e.sibling:null);_i(t);break;case 19:var x=(e.flags&128)!==0;if(r=(i&t.childLanes)!==0,r||(Er(e,t,i,!1),r=(i&t.childLanes)!==0),x){if(r)return Jp(e,t,i);t.flags|=128}if(x=t.memoizedState,x!==null&&(x.rendering=null,x.tail=null,x.lastEffect=null),W(Dt,Dt.current),r)break;return null;case 22:case 23:return t.lanes=0,Gp(e,t,i);case 24:di(t,Tt,e.memoizedState.cache)}return Wn(e,t,i)}function ey(e,t,i){if(e!==null)if(e.memoizedProps!==t.pendingProps)qt=!0;else{if(!kc(e,i)&&(t.flags&128)===0)return qt=!1,xk(e,t,i);qt=(e.flags&131072)!==0}else qt=!1,ot&&(t.flags&1048576)!==0&&Dg(t,jo,t.index);switch(t.lanes=0,t.tag){case 16:e:{e=t.pendingProps;var r=t.elementType,x=r._init;if(r=x(r._payload),t.type=r,typeof r=="function")Bl(r)?(e=ts(r,e),t.tag=1,t=Qp(null,t,r,e,i)):(t.tag=0,t=pc(null,t,r,e,i));else{if(r!=null){if(x=r.$$typeof,x===v){t.tag=11,t=Fp(null,t,r,e,i);break e}else if(x===A){t.tag=14,t=Vp(null,t,r,e,i);break e}}throw t=oe(r)||r,Error(l(306,t,""))}}return t;case 0:return pc(e,t,t.type,t.pendingProps,i);case 1:return r=t.type,x=ts(r,t.pendingProps),Qp(e,t,r,x,i);case 3:e:{if(H(t,t.stateNode.containerInfo),e===null)throw Error(l(387));r=t.pendingProps;var K=t.memoizedState;x=K.element,jl(e,t),Nr(t,r,null,i);var ae=t.memoizedState;if(r=ae.cache,di(t,Tt,r),r!==K.cache&&Il(t,[Tt],i,!0),Br(),r=ae.element,K.isDehydrated)if(K={element:r,isDehydrated:!1,cache:ae.cache},t.updateQueue.baseState=K,t.memoizedState=K,t.flags&256){t=Xp(e,t,r,i);break e}else if(r!==x){x=pn(Error(l(424)),t),xr(x),t=Xp(e,t,r,i);break e}else{switch(e=t.stateNode.containerInfo,e.nodeType){case 9:e=e.body;break;default:e=e.nodeName==="HTML"?e.ownerDocument.body:e}for(bt=An(e.firstChild),Wt=t,ot=!0,Qi=null,Bn=!0,i=Np(t,null,r,i),t.child=i;i;)i.flags=i.flags&-3|4096,i=i.sibling}else{if(Sr(),r===x){t=Wn(e,t,i);break e}Ot(e,t,r,i)}t=t.child}return t;case 26:return ua(e,t),e===null?(i=s_(t.type,null,t.pendingProps,null))?t.memoizedState=i:ot||(i=t.type,e=t.pendingProps,r=Aa(N.current).createElement(i),r[Bt]=t,r[zt]=e,It(r,i,e),Et(r),t.stateNode=r):t.memoizedState=s_(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return ce(t),e===null&&ot&&(r=t.stateNode=t_(t.type,t.pendingProps,N.current),Wt=t,Bn=!0,x=bt,Ri(t.type)?(nh=x,bt=An(r.firstChild)):bt=x),Ot(e,t,t.pendingProps.children,i),ua(e,t),e===null&&(t.flags|=4194304),t.child;case 5:return e===null&&ot&&((x=r=bt)&&(r=$k(r,t.type,t.pendingProps,Bn),r!==null?(t.stateNode=r,Wt=t,bt=An(r.firstChild),Bn=!1,x=!0):x=!1),x||Xi(t)),ce(t),x=t.type,K=t.pendingProps,ae=e!==null?e.memoizedProps:null,r=K.children,$c(x,K)?r=null:ae!==null&&$c(x,ae)&&(t.flags|=32),t.memoizedState!==null&&(x=Zl(e,t,yk,null,null,i),eo._currentValue=x),ua(e,t),Ot(e,t,r,i),t.child;case 6:return e===null&&ot&&((e=i=bt)&&(i=Jk(i,t.pendingProps,Bn),i!==null?(t.stateNode=i,Wt=t,bt=null,e=!0):e=!1),e||Xi(t)),null;case 13:return Zp(e,t,i);case 4:return H(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=Cs(t,null,r,i):Ot(e,t,r,i),t.child;case 11:return Fp(e,t,t.type,t.pendingProps,i);case 7:return Ot(e,t,t.pendingProps,i),t.child;case 8:return Ot(e,t,t.pendingProps.children,i),t.child;case 12:return Ot(e,t,t.pendingProps.children,i),t.child;case 10:return r=t.pendingProps,di(t,t.type,r.value),Ot(e,t,r.children,i),t.child;case 9:return x=t.type._context,r=t.pendingProps.children,$i(t),x=Ht(x),r=r(x),t.flags|=1,Ot(e,t,r,i),t.child;case 14:return Vp(e,t,t.type,t.pendingProps,i);case 15:return jp(e,t,t.type,t.pendingProps,i);case 19:return Jp(e,t,i);case 31:return r=t.pendingProps,i=t.mode,r={mode:r.mode,children:r.children},e===null?(i=da(r,i),i.ref=t.ref,t.child=i,i.return=t,t=i):(i=zn(e.child,r),i.ref=t.ref,t.child=i,i.return=t,t=i),t;case 22:return Gp(e,t,i);case 24:return $i(t),r=Ht(Tt),e===null?(x=Hl(),x===null&&(x=yt,K=Kl(),x.pooledCache=K,K.refCount++,K!==null&&(x.pooledCacheLanes|=i),x=K),t.memoizedState={parent:r,cache:x},Vl(t),di(t,Tt,x)):((e.lanes&i)!==0&&(jl(e,t),Nr(t,null,null,i),Br()),x=e.memoizedState,K=t.memoizedState,x.parent!==r?(x={parent:r,cache:r},t.memoizedState=x,t.lanes===0&&(t.memoizedState=t.updateQueue.baseState=x),di(t,Tt,r)):(r=K.cache,di(t,Tt,r),r!==x.cache&&Il(t,[Tt],i,!0))),Ot(e,t,t.pendingProps.children,i),t.child;case 29:throw t.pendingProps}throw Error(l(156,t.tag))}function Qn(e){e.flags|=4}function ty(e,t){if(t.type!=="stylesheet"||(t.state.loading&4)!==0)e.flags&=-16777217;else if(e.flags|=16777216,!c_(t)){if(t=wn.current,t!==null&&((nt&4194048)===nt?Nn!==null:(nt&62914560)!==nt&&(nt&536870912)===0||t!==Nn))throw Tr=Fl,Pg;e.flags|=8192}}function fa(e,t){t!==null&&(e.flags|=4),e.flags&16384&&(t=e.tag!==22?hs():536870912,e.lanes|=t,Ps|=t)}function Ir(e,t){if(!ot)switch(e.tailMode){case"hidden":t=e.tail;for(var i=null;t!==null;)t.alternate!==null&&(i=t),t=t.sibling;i===null?e.tail=null:i.sibling=null;break;case"collapsed":i=e.tail;for(var r=null;i!==null;)i.alternate!==null&&(r=i),i=i.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function wt(e){var t=e.alternate!==null&&e.alternate.child===e.child,i=0,r=0;if(t)for(var x=e.child;x!==null;)i|=x.lanes|x.childLanes,r|=x.subtreeFlags&65011712,r|=x.flags&65011712,x.return=e,x=x.sibling;else for(x=e.child;x!==null;)i|=x.lanes|x.childLanes,r|=x.subtreeFlags,r|=x.flags,x.return=e,x=x.sibling;return e.subtreeFlags|=r,e.childLanes=i,t}function Ek(e,t,i){var r=t.pendingProps;switch(Ml(t),t.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return wt(t),null;case 1:return wt(t),null;case 3:return i=t.stateNode,r=null,e!==null&&(r=e.memoizedState.cache),t.memoizedState.cache!==r&&(t.flags|=2048),jn(Tt),_e(),i.pendingContext&&(i.context=i.pendingContext,i.pendingContext=null),(e===null||e.child===null)&&(kr(t)?Qn(t):e===null||e.memoizedState.isDehydrated&&(t.flags&256)===0||(t.flags|=1024,qg())),wt(t),null;case 26:return i=t.memoizedState,e===null?(Qn(t),i!==null?(wt(t),ty(t,i)):(wt(t),t.flags&=-16777217)):i?i!==e.memoizedState?(Qn(t),wt(t),ty(t,i)):(wt(t),t.flags&=-16777217):(e.memoizedProps!==r&&Qn(t),wt(t),t.flags&=-16777217),null;case 27:J(t),i=N.current;var x=t.type;if(e!==null&&t.stateNode!=null)e.memoizedProps!==r&&Qn(t);else{if(!r){if(t.stateNode===null)throw Error(l(166));return wt(t),null}e=$.current,kr(t)?Bg(t):(e=t_(x,r,i),t.stateNode=e,Qn(t))}return wt(t),null;case 5:if(J(t),i=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==r&&Qn(t);else{if(!r){if(t.stateNode===null)throw Error(l(166));return wt(t),null}if(e=$.current,kr(t))Bg(t);else{switch(x=Aa(N.current),e){case 1:e=x.createElementNS("http://www.w3.org/2000/svg",i);break;case 2:e=x.createElementNS("http://www.w3.org/1998/Math/MathML",i);break;default:switch(i){case"svg":e=x.createElementNS("http://www.w3.org/2000/svg",i);break;case"math":e=x.createElementNS("http://www.w3.org/1998/Math/MathML",i);break;case"script":e=x.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild);break;case"select":e=typeof r.is=="string"?x.createElement("select",{is:r.is}):x.createElement("select"),r.multiple?e.multiple=!0:r.size&&(e.size=r.size);break;default:e=typeof r.is=="string"?x.createElement(i,{is:r.is}):x.createElement(i)}}e[Bt]=t,e[zt]=r;e:for(x=t.child;x!==null;){if(x.tag===5||x.tag===6)e.appendChild(x.stateNode);else if(x.tag!==4&&x.tag!==27&&x.child!==null){x.child.return=x,x=x.child;continue}if(x===t)break e;for(;x.sibling===null;){if(x.return===null||x.return===t)break e;x=x.return}x.sibling.return=x.return,x=x.sibling}t.stateNode=e;e:switch(It(e,i,r),i){case"button":case"input":case"select":case"textarea":e=!!r.autoFocus;break e;case"img":e=!0;break e;default:e=!1}e&&Qn(t)}}return wt(t),t.flags&=-16777217,null;case 6:if(e&&t.stateNode!=null)e.memoizedProps!==r&&Qn(t);else{if(typeof r!="string"&&t.stateNode===null)throw Error(l(166));if(e=N.current,kr(t)){if(e=t.stateNode,i=t.memoizedProps,r=null,x=Wt,x!==null)switch(x.tag){case 27:case 5:r=x.memoizedProps}e[Bt]=t,e=!!(e.nodeValue===i||r!==null&&r.suppressHydrationWarning===!0||Wy(e.nodeValue,i)),e||Xi(t)}else e=Aa(e).createTextNode(r),e[Bt]=t,t.stateNode=e}return wt(t),null;case 13:if(r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(x=kr(t),r!==null&&r.dehydrated!==null){if(e===null){if(!x)throw Error(l(318));if(x=t.memoizedState,x=x!==null?x.dehydrated:null,!x)throw Error(l(317));x[Bt]=t}else Sr(),(t.flags&128)===0&&(t.memoizedState=null),t.flags|=4;wt(t),x=!1}else x=qg(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=x),x=!0;if(!x)return t.flags&256?(Yn(t),t):(Yn(t),null)}if(Yn(t),(t.flags&128)!==0)return t.lanes=i,t;if(i=r!==null,e=e!==null&&e.memoizedState!==null,i){r=t.child,x=null,r.alternate!==null&&r.alternate.memoizedState!==null&&r.alternate.memoizedState.cachePool!==null&&(x=r.alternate.memoizedState.cachePool.pool);var K=null;r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(K=r.memoizedState.cachePool.pool),K!==x&&(r.flags|=2048)}return i!==e&&i&&(t.child.flags|=8192),fa(t,t.updateQueue),wt(t),null;case 4:return _e(),e===null&&Yc(t.stateNode.containerInfo),wt(t),null;case 10:return jn(t.type),wt(t),null;case 19:if(re(Dt),x=t.memoizedState,x===null)return wt(t),null;if(r=(t.flags&128)!==0,K=x.rendering,K===null)if(r)Ir(x,!1);else{if(vt!==0||e!==null&&(e.flags&128)!==0)for(e=t.child;e!==null;){if(K=la(e),K!==null){for(t.flags|=128,Ir(x,!1),e=K.updateQueue,t.updateQueue=e,fa(t,e),t.subtreeFlags=0,e=i,i=t.child;i!==null;)Tg(i,e),i=i.sibling;return W(Dt,Dt.current&1|2),t.child}e=e.sibling}x.tail!==null&&L()>ya&&(t.flags|=128,r=!0,Ir(x,!1),t.lanes=4194304)}else{if(!r)if(e=la(K),e!==null){if(t.flags|=128,r=!0,e=e.updateQueue,t.updateQueue=e,fa(t,e),Ir(x,!0),x.tail===null&&x.tailMode==="hidden"&&!K.alternate&&!ot)return wt(t),null}else 2*L()-x.renderingStartTime>ya&&i!==536870912&&(t.flags|=128,r=!0,Ir(x,!1),t.lanes=4194304);x.isBackwards?(K.sibling=t.child,t.child=K):(e=x.last,e!==null?e.sibling=K:t.child=K,x.last=K)}return x.tail!==null?(t=x.tail,x.rendering=t,x.tail=t.sibling,x.renderingStartTime=L(),t.sibling=null,e=Dt.current,W(Dt,r?e&1|2:e&1),t):(wt(t),null);case 22:case 23:return Yn(t),Ql(),r=t.memoizedState!==null,e!==null?e.memoizedState!==null!==r&&(t.flags|=8192):r&&(t.flags|=8192),r?(i&536870912)!==0&&(t.flags&128)===0&&(wt(t),t.subtreeFlags&6&&(t.flags|=8192)):wt(t),i=t.updateQueue,i!==null&&fa(t,i.retryQueue),i=null,e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(i=e.memoizedState.cachePool.pool),r=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(r=t.memoizedState.cachePool.pool),r!==i&&(t.flags|=2048),e!==null&&re(Ji),null;case 24:return i=null,e!==null&&(i=e.memoizedState.cache),t.memoizedState.cache!==i&&(t.flags|=2048),jn(Tt),wt(t),null;case 25:return null;case 30:return null}throw Error(l(156,t.tag))}function Ak(e,t){switch(Ml(t),t.tag){case 1:return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return jn(Tt),_e(),e=t.flags,(e&65536)!==0&&(e&128)===0?(t.flags=e&-65537|128,t):null;case 26:case 27:case 5:return J(t),null;case 13:if(Yn(t),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(l(340));Sr()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return re(Dt),null;case 4:return _e(),null;case 10:return jn(t.type),null;case 22:case 23:return Yn(t),Ql(),e!==null&&re(Ji),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 24:return jn(Tt),null;case 25:return null;default:return null}}function ny(e,t){switch(Ml(t),t.tag){case 3:jn(Tt),_e();break;case 26:case 27:case 5:J(t);break;case 4:_e();break;case 13:Yn(t);break;case 19:re(Dt);break;case 10:jn(t.type);break;case 22:case 23:Yn(t),Ql(),e!==null&&re(Ji);break;case 24:jn(Tt)}}function Kr(e,t){try{var i=t.updateQueue,r=i!==null?i.lastEffect:null;if(r!==null){var x=r.next;i=x;do{if((i.tag&e)===e){r=void 0;var K=i.create,ae=i.inst;r=K(),ae.destroy=r}i=i.next}while(i!==x)}}catch(ge){pt(t,t.return,ge)}}function wi(e,t,i){try{var r=t.updateQueue,x=r!==null?r.lastEffect:null;if(x!==null){var K=x.next;r=K;do{if((r.tag&e)===e){var ae=r.inst,ge=ae.destroy;if(ge!==void 0){ae.destroy=void 0,x=t;var be=i,Re=ge;try{Re()}catch(De){pt(x,be,De)}}}r=r.next}while(r!==K)}}catch(De){pt(t,t.return,De)}}function iy(e){var t=e.updateQueue;if(t!==null){var i=e.stateNode;try{Vg(t,i)}catch(r){pt(e,e.return,r)}}}function sy(e,t,i){i.props=ts(e.type,e.memoizedProps),i.state=e.memoizedState;try{i.componentWillUnmount()}catch(r){pt(e,t,r)}}function zr(e,t){try{var i=e.ref;if(i!==null){switch(e.tag){case 26:case 27:case 5:var r=e.stateNode;break;case 30:r=e.stateNode;break;default:r=e.stateNode}typeof i=="function"?e.refCleanup=i(r):i.current=r}}catch(x){pt(e,t,x)}}function qn(e,t){var i=e.ref,r=e.refCleanup;if(i!==null)if(typeof r=="function")try{r()}catch(x){pt(e,t,x)}finally{e.refCleanup=null,e=e.alternate,e!=null&&(e.refCleanup=null)}else if(typeof i=="function")try{i(null)}catch(x){pt(e,t,x)}else i.current=null}function ry(e){var t=e.type,i=e.memoizedProps,r=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":i.autoFocus&&r.focus();break e;case"img":i.src?r.src=i.src:i.srcSet&&(r.srcset=i.srcSet)}}catch(x){pt(e,e.return,x)}}function Sc(e,t,i){try{var r=e.stateNode;Yk(r,e.type,i,t),r[zt]=t}catch(x){pt(e,e.return,x)}}function oy(e){return e.tag===5||e.tag===3||e.tag===26||e.tag===27&&Ri(e.type)||e.tag===4}function xc(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||oy(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.tag===27&&Ri(e.type)||e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function Ec(e,t,i){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?(i.nodeType===9?i.body:i.nodeName==="HTML"?i.ownerDocument.body:i).insertBefore(e,t):(t=i.nodeType===9?i.body:i.nodeName==="HTML"?i.ownerDocument.body:i,t.appendChild(e),i=i._reactRootContainer,i!=null||t.onclick!==null||(t.onclick=Ea));else if(r!==4&&(r===27&&Ri(e.type)&&(i=e.stateNode,t=null),e=e.child,e!==null))for(Ec(e,t,i),e=e.sibling;e!==null;)Ec(e,t,i),e=e.sibling}function ga(e,t,i){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?i.insertBefore(e,t):i.appendChild(e);else if(r!==4&&(r===27&&Ri(e.type)&&(i=e.stateNode),e=e.child,e!==null))for(ga(e,t,i),e=e.sibling;e!==null;)ga(e,t,i),e=e.sibling}function ay(e){var t=e.stateNode,i=e.memoizedProps;try{for(var r=e.type,x=t.attributes;x.length;)t.removeAttributeNode(x[0]);It(t,r,i),t[Bt]=e,t[zt]=i}catch(K){pt(e,e.return,K)}}var Xn=!1,St=!1,Ac=!1,ly=typeof WeakSet=="function"?WeakSet:Set,Ct=null;function Rk(e,t){if(e=e.containerInfo,Xc=Na,e=wg(e),xl(e)){if("selectionStart"in e)var i={start:e.selectionStart,end:e.selectionEnd};else e:{i=(i=e.ownerDocument)&&i.defaultView||window;var r=i.getSelection&&i.getSelection();if(r&&r.rangeCount!==0){i=r.anchorNode;var x=r.anchorOffset,K=r.focusNode;r=r.focusOffset;try{i.nodeType,K.nodeType}catch{i=null;break e}var ae=0,ge=-1,be=-1,Re=0,De=0,Ne=e,Le=null;t:for(;;){for(var Te;Ne!==i||x!==0&&Ne.nodeType!==3||(ge=ae+x),Ne!==K||r!==0&&Ne.nodeType!==3||(be=ae+r),Ne.nodeType===3&&(ae+=Ne.nodeValue.length),(Te=Ne.firstChild)!==null;)Le=Ne,Ne=Te;for(;;){if(Ne===e)break t;if(Le===i&&++Re===x&&(ge=ae),Le===K&&++De===r&&(be=ae),(Te=Ne.nextSibling)!==null)break;Ne=Le,Le=Ne.parentNode}Ne=Te}i=ge===-1||be===-1?null:{start:ge,end:be}}else i=null}i=i||{start:0,end:0}}else i=null;for(Zc={focusedElem:e,selectionRange:i},Na=!1,Ct=t;Ct!==null;)if(t=Ct,e=t.child,(t.subtreeFlags&1024)!==0&&e!==null)e.return=t,Ct=e;else for(;Ct!==null;){switch(t=Ct,K=t.alternate,e=t.flags,t.tag){case 0:break;case 11:case 15:break;case 1:if((e&1024)!==0&&K!==null){e=void 0,i=t,x=K.memoizedProps,K=K.memoizedState,r=i.stateNode;try{var Ge=ts(i.type,x,i.elementType===i.type);e=r.getSnapshotBeforeUpdate(Ge,K),r.__reactInternalSnapshotBeforeUpdate=e}catch(Fe){pt(i,i.return,Fe)}}break;case 3:if((e&1024)!==0){if(e=t.stateNode.containerInfo,i=e.nodeType,i===9)eh(e);else if(i===1)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":eh(e);break;default:e.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((e&1024)!==0)throw Error(l(163))}if(e=t.sibling,e!==null){e.return=t.return,Ct=e;break}Ct=t.return}}function cy(e,t,i){var r=i.flags;switch(i.tag){case 0:case 11:case 15:bi(e,i),r&4&&Kr(5,i);break;case 1:if(bi(e,i),r&4)if(e=i.stateNode,t===null)try{e.componentDidMount()}catch(ae){pt(i,i.return,ae)}else{var x=ts(i.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(x,t,e.__reactInternalSnapshotBeforeUpdate)}catch(ae){pt(i,i.return,ae)}}r&64&&iy(i),r&512&&zr(i,i.return);break;case 3:if(bi(e,i),r&64&&(e=i.updateQueue,e!==null)){if(t=null,i.child!==null)switch(i.child.tag){case 27:case 5:t=i.child.stateNode;break;case 1:t=i.child.stateNode}try{Vg(e,t)}catch(ae){pt(i,i.return,ae)}}break;case 27:t===null&&r&4&&ay(i);case 26:case 5:bi(e,i),t===null&&r&4&&ry(i),r&512&&zr(i,i.return);break;case 12:bi(e,i);break;case 13:bi(e,i),r&4&&dy(e,i),r&64&&(e=i.memoizedState,e!==null&&(e=e.dehydrated,e!==null&&(i=Uk.bind(null,i),e1(e,i))));break;case 22:if(r=i.memoizedState!==null||Xn,!r){t=t!==null&&t.memoizedState!==null||St,x=Xn;var K=St;Xn=r,(St=t)&&!K?vi(e,i,(i.subtreeFlags&8772)!==0):bi(e,i),Xn=x,St=K}break;case 30:break;default:bi(e,i)}}function hy(e){var t=e.alternate;t!==null&&(e.alternate=null,hy(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&lr(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var mt=null,Jt=!1;function Zn(e,t,i){for(i=i.child;i!==null;)uy(e,t,i),i=i.sibling}function uy(e,t,i){if(ne&&typeof ne.onCommitFiberUnmount=="function")try{ne.onCommitFiberUnmount(F,i)}catch{}switch(i.tag){case 26:St||qn(i,t),Zn(e,t,i),i.memoizedState?i.memoizedState.count--:i.stateNode&&(i=i.stateNode,i.parentNode.removeChild(i));break;case 27:St||qn(i,t);var r=mt,x=Jt;Ri(i.type)&&(mt=i.stateNode,Jt=!1),Zn(e,t,i),Xr(i.stateNode),mt=r,Jt=x;break;case 5:St||qn(i,t);case 6:if(r=mt,x=Jt,mt=null,Zn(e,t,i),mt=r,Jt=x,mt!==null)if(Jt)try{(mt.nodeType===9?mt.body:mt.nodeName==="HTML"?mt.ownerDocument.body:mt).removeChild(i.stateNode)}catch(K){pt(i,t,K)}else try{mt.removeChild(i.stateNode)}catch(K){pt(i,t,K)}break;case 18:mt!==null&&(Jt?(e=mt,Jy(e.nodeType===9?e.body:e.nodeName==="HTML"?e.ownerDocument.body:e,i.stateNode),so(e)):Jy(mt,i.stateNode));break;case 4:r=mt,x=Jt,mt=i.stateNode.containerInfo,Jt=!0,Zn(e,t,i),mt=r,Jt=x;break;case 0:case 11:case 14:case 15:St||wi(2,i,t),St||wi(4,i,t),Zn(e,t,i);break;case 1:St||(qn(i,t),r=i.stateNode,typeof r.componentWillUnmount=="function"&&sy(i,t,r)),Zn(e,t,i);break;case 21:Zn(e,t,i);break;case 22:St=(r=St)||i.memoizedState!==null,Zn(e,t,i),St=r;break;default:Zn(e,t,i)}}function dy(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null&&(e=e.dehydrated,e!==null))))try{so(e)}catch(i){pt(t,t.return,i)}}function Lk(e){switch(e.tag){case 13:case 19:var t=e.stateNode;return t===null&&(t=e.stateNode=new ly),t;case 22:return e=e.stateNode,t=e._retryCache,t===null&&(t=e._retryCache=new ly),t;default:throw Error(l(435,e.tag))}}function Rc(e,t){var i=Lk(e);t.forEach(function(r){var x=Ok.bind(null,e,r);i.has(r)||(i.add(r),r.then(x,x))})}function cn(e,t){var i=t.deletions;if(i!==null)for(var r=0;r<i.length;r++){var x=i[r],K=e,ae=t,ge=ae;e:for(;ge!==null;){switch(ge.tag){case 27:if(Ri(ge.type)){mt=ge.stateNode,Jt=!1;break e}break;case 5:mt=ge.stateNode,Jt=!1;break e;case 3:case 4:mt=ge.stateNode.containerInfo,Jt=!0;break e}ge=ge.return}if(mt===null)throw Error(l(160));uy(K,ae,x),mt=null,Jt=!1,K=x.alternate,K!==null&&(K.return=null),x.return=null}if(t.subtreeFlags&13878)for(t=t.child;t!==null;)fy(t,e),t=t.sibling}var En=null;function fy(e,t){var i=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:cn(t,e),hn(e),r&4&&(wi(3,e,e.return),Kr(3,e),wi(5,e,e.return));break;case 1:cn(t,e),hn(e),r&512&&(St||i===null||qn(i,i.return)),r&64&&Xn&&(e=e.updateQueue,e!==null&&(r=e.callbacks,r!==null&&(i=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=i===null?r:i.concat(r))));break;case 26:var x=En;if(cn(t,e),hn(e),r&512&&(St||i===null||qn(i,i.return)),r&4){var K=i!==null?i.memoizedState:null;if(r=e.memoizedState,i===null)if(r===null)if(e.stateNode===null){e:{r=e.type,i=e.memoizedProps,x=x.ownerDocument||x;t:switch(r){case"title":K=x.getElementsByTagName("title")[0],(!K||K[Pi]||K[Bt]||K.namespaceURI==="http://www.w3.org/2000/svg"||K.hasAttribute("itemprop"))&&(K=x.createElement(r),x.head.insertBefore(K,x.querySelector("head > title"))),It(K,r,i),K[Bt]=e,Et(K),r=K;break e;case"link":var ae=a_("link","href",x).get(r+(i.href||""));if(ae){for(var ge=0;ge<ae.length;ge++)if(K=ae[ge],K.getAttribute("href")===(i.href==null||i.href===""?null:i.href)&&K.getAttribute("rel")===(i.rel==null?null:i.rel)&&K.getAttribute("title")===(i.title==null?null:i.title)&&K.getAttribute("crossorigin")===(i.crossOrigin==null?null:i.crossOrigin)){ae.splice(ge,1);break t}}K=x.createElement(r),It(K,r,i),x.head.appendChild(K);break;case"meta":if(ae=a_("meta","content",x).get(r+(i.content||""))){for(ge=0;ge<ae.length;ge++)if(K=ae[ge],K.getAttribute("content")===(i.content==null?null:""+i.content)&&K.getAttribute("name")===(i.name==null?null:i.name)&&K.getAttribute("property")===(i.property==null?null:i.property)&&K.getAttribute("http-equiv")===(i.httpEquiv==null?null:i.httpEquiv)&&K.getAttribute("charset")===(i.charSet==null?null:i.charSet)){ae.splice(ge,1);break t}}K=x.createElement(r),It(K,r,i),x.head.appendChild(K);break;default:throw Error(l(468,r))}K[Bt]=e,Et(K),r=K}e.stateNode=r}else l_(x,e.type,e.stateNode);else e.stateNode=o_(x,r,e.memoizedProps);else K!==r?(K===null?i.stateNode!==null&&(i=i.stateNode,i.parentNode.removeChild(i)):K.count--,r===null?l_(x,e.type,e.stateNode):o_(x,r,e.memoizedProps)):r===null&&e.stateNode!==null&&Sc(e,e.memoizedProps,i.memoizedProps)}break;case 27:cn(t,e),hn(e),r&512&&(St||i===null||qn(i,i.return)),i!==null&&r&4&&Sc(e,e.memoizedProps,i.memoizedProps);break;case 5:if(cn(t,e),hn(e),r&512&&(St||i===null||qn(i,i.return)),e.flags&32){x=e.stateNode;try{He(x,"")}catch(Te){pt(e,e.return,Te)}}r&4&&e.stateNode!=null&&(x=e.memoizedProps,Sc(e,x,i!==null?i.memoizedProps:x)),r&1024&&(Ac=!0);break;case 6:if(cn(t,e),hn(e),r&4){if(e.stateNode===null)throw Error(l(162));r=e.memoizedProps,i=e.stateNode;try{i.nodeValue=r}catch(Te){pt(e,e.return,Te)}}break;case 3:if(Ta=null,x=En,En=Ra(t.containerInfo),cn(t,e),En=x,hn(e),r&4&&i!==null&&i.memoizedState.isDehydrated)try{so(t.containerInfo)}catch(Te){pt(e,e.return,Te)}Ac&&(Ac=!1,gy(e));break;case 4:r=En,En=Ra(e.stateNode.containerInfo),cn(t,e),hn(e),En=r;break;case 12:cn(t,e),hn(e);break;case 13:cn(t,e),hn(e),e.child.flags&8192&&e.memoizedState!==null!=(i!==null&&i.memoizedState!==null)&&(qc=L()),r&4&&(r=e.updateQueue,r!==null&&(e.updateQueue=null,Rc(e,r)));break;case 22:x=e.memoizedState!==null;var be=i!==null&&i.memoizedState!==null,Re=Xn,De=St;if(Xn=Re||x,St=De||be,cn(t,e),St=De,Xn=Re,hn(e),r&8192)e:for(t=e.stateNode,t._visibility=x?t._visibility&-2:t._visibility|1,x&&(i===null||be||Xn||St||ns(e)),i=null,t=e;;){if(t.tag===5||t.tag===26){if(i===null){be=i=t;try{if(K=be.stateNode,x)ae=K.style,typeof ae.setProperty=="function"?ae.setProperty("display","none","important"):ae.display="none";else{ge=be.stateNode;var Ne=be.memoizedProps.style,Le=Ne!=null&&Ne.hasOwnProperty("display")?Ne.display:null;ge.style.display=Le==null||typeof Le=="boolean"?"":(""+Le).trim()}}catch(Te){pt(be,be.return,Te)}}}else if(t.tag===6){if(i===null){be=t;try{be.stateNode.nodeValue=x?"":be.memoizedProps}catch(Te){pt(be,be.return,Te)}}}else if((t.tag!==22&&t.tag!==23||t.memoizedState===null||t===e)&&t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;i===t&&(i=null),t=t.return}i===t&&(i=null),t.sibling.return=t.return,t=t.sibling}r&4&&(r=e.updateQueue,r!==null&&(i=r.retryQueue,i!==null&&(r.retryQueue=null,Rc(e,i))));break;case 19:cn(t,e),hn(e),r&4&&(r=e.updateQueue,r!==null&&(e.updateQueue=null,Rc(e,r)));break;case 30:break;case 21:break;default:cn(t,e),hn(e)}}function hn(e){var t=e.flags;if(t&2){try{for(var i,r=e.return;r!==null;){if(oy(r)){i=r;break}r=r.return}if(i==null)throw Error(l(160));switch(i.tag){case 27:var x=i.stateNode,K=xc(e);ga(e,K,x);break;case 5:var ae=i.stateNode;i.flags&32&&(He(ae,""),i.flags&=-33);var ge=xc(e);ga(e,ge,ae);break;case 3:case 4:var be=i.stateNode.containerInfo,Re=xc(e);Ec(e,Re,be);break;default:throw Error(l(161))}}catch(De){pt(e,e.return,De)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function gy(e){if(e.subtreeFlags&1024)for(e=e.child;e!==null;){var t=e;gy(t),t.tag===5&&t.flags&1024&&t.stateNode.reset(),e=e.sibling}}function bi(e,t){if(t.subtreeFlags&8772)for(t=t.child;t!==null;)cy(e,t.alternate,t),t=t.sibling}function ns(e){for(e=e.child;e!==null;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:wi(4,t,t.return),ns(t);break;case 1:qn(t,t.return);var i=t.stateNode;typeof i.componentWillUnmount=="function"&&sy(t,t.return,i),ns(t);break;case 27:Xr(t.stateNode);case 26:case 5:qn(t,t.return),ns(t);break;case 22:t.memoizedState===null&&ns(t);break;case 30:ns(t);break;default:ns(t)}e=e.sibling}}function vi(e,t,i){for(i=i&&(t.subtreeFlags&8772)!==0,t=t.child;t!==null;){var r=t.alternate,x=e,K=t,ae=K.flags;switch(K.tag){case 0:case 11:case 15:vi(x,K,i),Kr(4,K);break;case 1:if(vi(x,K,i),r=K,x=r.stateNode,typeof x.componentDidMount=="function")try{x.componentDidMount()}catch(Re){pt(r,r.return,Re)}if(r=K,x=r.updateQueue,x!==null){var ge=r.stateNode;try{var be=x.shared.hiddenCallbacks;if(be!==null)for(x.shared.hiddenCallbacks=null,x=0;x<be.length;x++)Fg(be[x],ge)}catch(Re){pt(r,r.return,Re)}}i&&ae&64&&iy(K),zr(K,K.return);break;case 27:ay(K);case 26:case 5:vi(x,K,i),i&&r===null&&ae&4&&ry(K),zr(K,K.return);break;case 12:vi(x,K,i);break;case 13:vi(x,K,i),i&&ae&4&&dy(x,K);break;case 22:K.memoizedState===null&&vi(x,K,i),zr(K,K.return);break;case 30:break;default:vi(x,K,i)}t=t.sibling}}function Lc(e,t){var i=null;e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(i=e.memoizedState.cachePool.pool),e=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(e=t.memoizedState.cachePool.pool),e!==i&&(e!=null&&e.refCount++,i!=null&&Ar(i))}function Tc(e,t){e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&Ar(e))}function Cn(e,t,i,r){if(t.subtreeFlags&10256)for(t=t.child;t!==null;)py(e,t,i,r),t=t.sibling}function py(e,t,i,r){var x=t.flags;switch(t.tag){case 0:case 11:case 15:Cn(e,t,i,r),x&2048&&Kr(9,t);break;case 1:Cn(e,t,i,r);break;case 3:Cn(e,t,i,r),x&2048&&(e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&Ar(e)));break;case 12:if(x&2048){Cn(e,t,i,r),e=t.stateNode;try{var K=t.memoizedProps,ae=K.id,ge=K.onPostCommit;typeof ge=="function"&&ge(ae,t.alternate===null?"mount":"update",e.passiveEffectDuration,-0)}catch(be){pt(t,t.return,be)}}else Cn(e,t,i,r);break;case 13:Cn(e,t,i,r);break;case 23:break;case 22:K=t.stateNode,ae=t.alternate,t.memoizedState!==null?K._visibility&2?Cn(e,t,i,r):Hr(e,t):K._visibility&2?Cn(e,t,i,r):(K._visibility|=2,Ms(e,t,i,r,(t.subtreeFlags&10256)!==0)),x&2048&&Lc(ae,t);break;case 24:Cn(e,t,i,r),x&2048&&Tc(t.alternate,t);break;default:Cn(e,t,i,r)}}function Ms(e,t,i,r,x){for(x=x&&(t.subtreeFlags&10256)!==0,t=t.child;t!==null;){var K=e,ae=t,ge=i,be=r,Re=ae.flags;switch(ae.tag){case 0:case 11:case 15:Ms(K,ae,ge,be,x),Kr(8,ae);break;case 23:break;case 22:var De=ae.stateNode;ae.memoizedState!==null?De._visibility&2?Ms(K,ae,ge,be,x):Hr(K,ae):(De._visibility|=2,Ms(K,ae,ge,be,x)),x&&Re&2048&&Lc(ae.alternate,ae);break;case 24:Ms(K,ae,ge,be,x),x&&Re&2048&&Tc(ae.alternate,ae);break;default:Ms(K,ae,ge,be,x)}t=t.sibling}}function Hr(e,t){if(t.subtreeFlags&10256)for(t=t.child;t!==null;){var i=e,r=t,x=r.flags;switch(r.tag){case 22:Hr(i,r),x&2048&&Lc(r.alternate,r);break;case 24:Hr(i,r),x&2048&&Tc(r.alternate,r);break;default:Hr(i,r)}t=t.sibling}}var Fr=8192;function Us(e){if(e.subtreeFlags&Fr)for(e=e.child;e!==null;)yy(e),e=e.sibling}function yy(e){switch(e.tag){case 26:Us(e),e.flags&Fr&&e.memoizedState!==null&&f1(En,e.memoizedState,e.memoizedProps);break;case 5:Us(e);break;case 3:case 4:var t=En;En=Ra(e.stateNode.containerInfo),Us(e),En=t;break;case 22:e.memoizedState===null&&(t=e.alternate,t!==null&&t.memoizedState!==null?(t=Fr,Fr=16777216,Us(e),Fr=t):Us(e));break;default:Us(e)}}function _y(e){var t=e.alternate;if(t!==null&&(e=t.child,e!==null)){t.child=null;do t=e.sibling,e.sibling=null,e=t;while(e!==null)}}function Vr(e){var t=e.deletions;if((e.flags&16)!==0){if(t!==null)for(var i=0;i<t.length;i++){var r=t[i];Ct=r,wy(r,e)}_y(e)}if(e.subtreeFlags&10256)for(e=e.child;e!==null;)my(e),e=e.sibling}function my(e){switch(e.tag){case 0:case 11:case 15:Vr(e),e.flags&2048&&wi(9,e,e.return);break;case 3:Vr(e);break;case 12:Vr(e);break;case 22:var t=e.stateNode;e.memoizedState!==null&&t._visibility&2&&(e.return===null||e.return.tag!==13)?(t._visibility&=-3,pa(e)):Vr(e);break;default:Vr(e)}}function pa(e){var t=e.deletions;if((e.flags&16)!==0){if(t!==null)for(var i=0;i<t.length;i++){var r=t[i];Ct=r,wy(r,e)}_y(e)}for(e=e.child;e!==null;){switch(t=e,t.tag){case 0:case 11:case 15:wi(8,t,t.return),pa(t);break;case 22:i=t.stateNode,i._visibility&2&&(i._visibility&=-3,pa(t));break;default:pa(t)}e=e.sibling}}function wy(e,t){for(;Ct!==null;){var i=Ct;switch(i.tag){case 0:case 11:case 15:wi(8,i,t);break;case 23:case 22:if(i.memoizedState!==null&&i.memoizedState.cachePool!==null){var r=i.memoizedState.cachePool.pool;r!=null&&r.refCount++}break;case 24:Ar(i.memoizedState.cache)}if(r=i.child,r!==null)r.return=i,Ct=r;else e:for(i=e;Ct!==null;){r=Ct;var x=r.sibling,K=r.return;if(hy(r),r===i){Ct=null;break e}if(x!==null){x.return=K,Ct=x;break e}Ct=K}}}var Tk={getCacheForType:function(e){var t=Ht(Tt),i=t.data.get(e);return i===void 0&&(i=e(),t.data.set(e,i)),i}},Dk=typeof WeakMap=="function"?WeakMap:Map,lt=0,yt=null,$e=null,nt=0,ct=0,un=null,ki=!1,Os=!1,Dc=!1,$n=0,vt=0,Si=0,is=0,Bc=0,bn=0,Ps=0,jr=null,en=null,Nc=!1,qc=0,ya=1/0,_a=null,xi=null,Pt=0,Ei=null,Is=null,Ks=0,Cc=0,Mc=null,by=null,Gr=0,Uc=null;function dn(){if((lt&2)!==0&&nt!==0)return nt&-nt;if(O.T!==null){var e=Rs;return e!==0?e:Fc()}return So()}function vy(){bn===0&&(bn=(nt&536870912)===0||ot?si():536870912);var e=wn.current;return e!==null&&(e.flags|=32),bn}function fn(e,t,i){(e===yt&&(ct===2||ct===9)||e.cancelPendingCommit!==null)&&(zs(e,0),Ai(e,nt,bn,!1)),Oi(e,i),((lt&2)===0||e!==yt)&&(e===yt&&((lt&2)===0&&(is|=i),vt===4&&Ai(e,nt,bn,!1)),Mn(e))}function ky(e,t,i){if((lt&6)!==0)throw Error(l(327));var r=!i&&(t&124)===0&&(t&e.expiredLanes)===0||xt(e,t),x=r?qk(e,t):Ic(e,t,!0),K=r;do{if(x===0){Os&&!r&&Ai(e,t,0,!1);break}else{if(i=e.current.alternate,K&&!Bk(i)){x=Ic(e,t,!1),K=!1;continue}if(x===2){if(K=t,e.errorRecoveryDisabledLanes&K)var ae=0;else ae=e.pendingLanes&-536870913,ae=ae!==0?ae:ae&536870912?536870912:0;if(ae!==0){t=ae;e:{var ge=e;x=jr;var be=ge.current.memoizedState.isDehydrated;if(be&&(zs(ge,ae).flags|=256),ae=Ic(ge,ae,!1),ae!==2){if(Dc&&!be){ge.errorRecoveryDisabledLanes|=K,is|=K,x=4;break e}K=en,en=x,K!==null&&(en===null?en=K:en.push.apply(en,K))}x=ae}if(K=!1,x!==2)continue}}if(x===1){zs(e,0),Ai(e,t,0,!0);break}e:{switch(r=e,K=x,K){case 0:case 1:throw Error(l(345));case 4:if((t&4194048)!==t)break;case 6:Ai(r,t,bn,!ki);break e;case 2:en=null;break;case 3:case 5:break;default:throw Error(l(329))}if((t&62914560)===t&&(x=qc+300-L(),10<x)){if(Ai(r,t,bn,!ki),at(r,0,!0)!==0)break e;r.timeoutHandle=Zy(Sy.bind(null,r,i,en,_a,Nc,t,bn,is,Ps,ki,K,2,-0,0),x);break e}Sy(r,i,en,_a,Nc,t,bn,is,Ps,ki,K,0,-0,0)}}break}while(!0);Mn(e)}function Sy(e,t,i,r,x,K,ae,ge,be,Re,De,Ne,Le,Te){if(e.timeoutHandle=-1,Ne=t.subtreeFlags,(Ne&8192||(Ne&16785408)===16785408)&&(Jr={stylesheets:null,count:0,unsuspend:d1},yy(t),Ne=g1(),Ne!==null)){e.cancelPendingCommit=Ne(Dy.bind(null,e,t,K,i,r,x,ae,ge,be,De,1,Le,Te)),Ai(e,K,ae,!Re);return}Dy(e,t,K,i,r,x,ae,ge,be)}function Bk(e){for(var t=e;;){var i=t.tag;if((i===0||i===11||i===15)&&t.flags&16384&&(i=t.updateQueue,i!==null&&(i=i.stores,i!==null)))for(var r=0;r<i.length;r++){var x=i[r],K=x.getSnapshot;x=x.value;try{if(!an(K(),x))return!1}catch{return!1}}if(i=t.child,t.subtreeFlags&16384&&i!==null)i.return=t,t=i;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Ai(e,t,i,r){t&=~Bc,t&=~is,e.suspendedLanes|=t,e.pingedLanes&=~t,r&&(e.warmLanes|=t),r=e.expirationTimes;for(var x=t;0<x;){var K=31-me(x),ae=1<<K;r[K]=-1,x&=~ae}i!==0&&vo(e,i,t)}function ma(){return(lt&6)===0?(Yr(0),!1):!0}function Oc(){if($e!==null){if(ct===0)var e=$e.return;else e=$e,Vn=Zi=null,ec(e),qs=null,Or=0,e=$e;for(;e!==null;)ny(e.alternate,e),e=e.return;$e=null}}function zs(e,t){var i=e.timeoutHandle;i!==-1&&(e.timeoutHandle=-1,Qk(i)),i=e.cancelPendingCommit,i!==null&&(e.cancelPendingCommit=null,i()),Oc(),yt=e,$e=i=zn(e.current,null),nt=t,ct=0,un=null,ki=!1,Os=xt(e,t),Dc=!1,Ps=bn=Bc=is=Si=vt=0,en=jr=null,Nc=!1,(t&8)!==0&&(t|=t&32);var r=e.entangledLanes;if(r!==0)for(e=e.entanglements,r&=t;0<r;){var x=31-me(r),K=1<<x;t|=e[x],r&=~K}return $n=t,Ko(),i}function xy(e,t){Qe=null,O.H=ra,t===Lr||t===Qo?(t=zg(),ct=3):t===Pg?(t=zg(),ct=4):ct=t===Hp?8:t!==null&&typeof t=="object"&&typeof t.then=="function"?6:1,un=t,$e===null&&(vt=1,ha(e,pn(t,e.current)))}function Ey(){var e=O.H;return O.H=ra,e===null?ra:e}function Ay(){var e=O.A;return O.A=Tk,e}function Pc(){vt=4,ki||(nt&4194048)!==nt&&wn.current!==null||(Os=!0),(Si&134217727)===0&&(is&134217727)===0||yt===null||Ai(yt,nt,bn,!1)}function Ic(e,t,i){var r=lt;lt|=2;var x=Ey(),K=Ay();(yt!==e||nt!==t)&&(_a=null,zs(e,t)),t=!1;var ae=vt;e:do try{if(ct!==0&&$e!==null){var ge=$e,be=un;switch(ct){case 8:Oc(),ae=6;break e;case 3:case 2:case 9:case 6:wn.current===null&&(t=!0);var Re=ct;if(ct=0,un=null,Hs(e,ge,be,Re),i&&Os){ae=0;break e}break;default:Re=ct,ct=0,un=null,Hs(e,ge,be,Re)}}Nk(),ae=vt;break}catch(De){xy(e,De)}while(!0);return t&&e.shellSuspendCounter++,Vn=Zi=null,lt=r,O.H=x,O.A=K,$e===null&&(yt=null,nt=0,Ko()),ae}function Nk(){for(;$e!==null;)Ry($e)}function qk(e,t){var i=lt;lt|=2;var r=Ey(),x=Ay();yt!==e||nt!==t?(_a=null,ya=L()+500,zs(e,t)):Os=xt(e,t);e:do try{if(ct!==0&&$e!==null){t=$e;var K=un;t:switch(ct){case 1:ct=0,un=null,Hs(e,t,K,1);break;case 2:case 9:if(Ig(K)){ct=0,un=null,Ly(t);break}t=function(){ct!==2&&ct!==9||yt!==e||(ct=7),Mn(e)},K.then(t,t);break e;case 3:ct=7;break e;case 4:ct=5;break e;case 7:Ig(K)?(ct=0,un=null,Ly(t)):(ct=0,un=null,Hs(e,t,K,7));break;case 5:var ae=null;switch($e.tag){case 26:ae=$e.memoizedState;case 5:case 27:var ge=$e;if(!ae||c_(ae)){ct=0,un=null;var be=ge.sibling;if(be!==null)$e=be;else{var Re=ge.return;Re!==null?($e=Re,wa(Re)):$e=null}break t}}ct=0,un=null,Hs(e,t,K,5);break;case 6:ct=0,un=null,Hs(e,t,K,6);break;case 8:Oc(),vt=6;break e;default:throw Error(l(462))}}Ck();break}catch(De){xy(e,De)}while(!0);return Vn=Zi=null,O.H=r,O.A=x,lt=i,$e!==null?0:(yt=null,nt=0,Ko(),vt)}function Ck(){for(;$e!==null&&!ie();)Ry($e)}function Ry(e){var t=ey(e.alternate,e,$n);e.memoizedProps=e.pendingProps,t===null?wa(e):$e=t}function Ly(e){var t=e,i=t.alternate;switch(t.tag){case 15:case 0:t=Wp(i,t,t.pendingProps,t.type,void 0,nt);break;case 11:t=Wp(i,t,t.pendingProps,t.type.render,t.ref,nt);break;case 5:ec(t);default:ny(i,t),t=$e=Tg(t,$n),t=ey(i,t,$n)}e.memoizedProps=e.pendingProps,t===null?wa(e):$e=t}function Hs(e,t,i,r){Vn=Zi=null,ec(t),qs=null,Or=0;var x=t.return;try{if(Sk(e,x,t,i,nt)){vt=1,ha(e,pn(i,e.current)),$e=null;return}}catch(K){if(x!==null)throw $e=x,K;vt=1,ha(e,pn(i,e.current)),$e=null;return}t.flags&32768?(ot||r===1?e=!0:Os||(nt&536870912)!==0?e=!1:(ki=e=!0,(r===2||r===9||r===3||r===6)&&(r=wn.current,r!==null&&r.tag===13&&(r.flags|=16384))),Ty(t,e)):wa(t)}function wa(e){var t=e;do{if((t.flags&32768)!==0){Ty(t,ki);return}e=t.return;var i=Ek(t.alternate,t,$n);if(i!==null){$e=i;return}if(t=t.sibling,t!==null){$e=t;return}$e=t=e}while(t!==null);vt===0&&(vt=5)}function Ty(e,t){do{var i=Ak(e.alternate,e);if(i!==null){i.flags&=32767,$e=i;return}if(i=e.return,i!==null&&(i.flags|=32768,i.subtreeFlags=0,i.deletions=null),!t&&(e=e.sibling,e!==null)){$e=e;return}$e=e=i}while(e!==null);vt=6,$e=null}function Dy(e,t,i,r,x,K,ae,ge,be){e.cancelPendingCommit=null;do ba();while(Pt!==0);if((lt&6)!==0)throw Error(l(327));if(t!==null){if(t===e.current)throw Error(l(177));if(K=t.lanes|t.childLanes,K|=Tl,cl(e,i,K,ae,ge,be),e===yt&&($e=yt=null,nt=0),Is=t,Ei=e,Ks=i,Cc=K,Mc=x,by=r,(t.subtreeFlags&10256)!==0||(t.flags&10256)!==0?(e.callbackNode=null,e.callbackPriority=0,Pk(C,function(){return My(),null})):(e.callbackNode=null,e.callbackPriority=0),r=(t.flags&13878)!==0,(t.subtreeFlags&13878)!==0||r){r=O.T,O.T=null,x=P.p,P.p=2,ae=lt,lt|=4;try{Rk(e,t,i)}finally{lt=ae,P.p=x,O.T=r}}Pt=1,By(),Ny(),qy()}}function By(){if(Pt===1){Pt=0;var e=Ei,t=Is,i=(t.flags&13878)!==0;if((t.subtreeFlags&13878)!==0||i){i=O.T,O.T=null;var r=P.p;P.p=2;var x=lt;lt|=4;try{fy(t,e);var K=Zc,ae=wg(e.containerInfo),ge=K.focusedElem,be=K.selectionRange;if(ae!==ge&&ge&&ge.ownerDocument&&mg(ge.ownerDocument.documentElement,ge)){if(be!==null&&xl(ge)){var Re=be.start,De=be.end;if(De===void 0&&(De=Re),"selectionStart"in ge)ge.selectionStart=Re,ge.selectionEnd=Math.min(De,ge.value.length);else{var Ne=ge.ownerDocument||document,Le=Ne&&Ne.defaultView||window;if(Le.getSelection){var Te=Le.getSelection(),Ge=ge.textContent.length,Fe=Math.min(be.start,Ge),ft=be.end===void 0?Fe:Math.min(be.end,Ge);!Te.extend&&Fe>ft&&(ae=ft,ft=Fe,Fe=ae);var xe=_g(ge,Fe),Se=_g(ge,ft);if(xe&&Se&&(Te.rangeCount!==1||Te.anchorNode!==xe.node||Te.anchorOffset!==xe.offset||Te.focusNode!==Se.node||Te.focusOffset!==Se.offset)){var Ae=Ne.createRange();Ae.setStart(xe.node,xe.offset),Te.removeAllRanges(),Fe>ft?(Te.addRange(Ae),Te.extend(Se.node,Se.offset)):(Ae.setEnd(Se.node,Se.offset),Te.addRange(Ae))}}}}for(Ne=[],Te=ge;Te=Te.parentNode;)Te.nodeType===1&&Ne.push({element:Te,left:Te.scrollLeft,top:Te.scrollTop});for(typeof ge.focus=="function"&&ge.focus(),ge=0;ge<Ne.length;ge++){var Be=Ne[ge];Be.element.scrollLeft=Be.left,Be.element.scrollTop=Be.top}}Na=!!Xc,Zc=Xc=null}finally{lt=x,P.p=r,O.T=i}}e.current=t,Pt=2}}function Ny(){if(Pt===2){Pt=0;var e=Ei,t=Is,i=(t.flags&8772)!==0;if((t.subtreeFlags&8772)!==0||i){i=O.T,O.T=null;var r=P.p;P.p=2;var x=lt;lt|=4;try{cy(e,t.alternate,t)}finally{lt=x,P.p=r,O.T=i}}Pt=3}}function qy(){if(Pt===4||Pt===3){Pt=0,I();var e=Ei,t=Is,i=Ks,r=by;(t.subtreeFlags&10256)!==0||(t.flags&10256)!==0?Pt=5:(Pt=0,Is=Ei=null,Cy(e,e.pendingLanes));var x=e.pendingLanes;if(x===0&&(xi=null),us(i),t=t.stateNode,ne&&typeof ne.onCommitFiberRoot=="function")try{ne.onCommitFiberRoot(F,t,void 0,(t.current.flags&128)===128)}catch{}if(r!==null){t=O.T,x=P.p,P.p=2,O.T=null;try{for(var K=e.onRecoverableError,ae=0;ae<r.length;ae++){var ge=r[ae];K(ge.value,{componentStack:ge.stack})}}finally{O.T=t,P.p=x}}(Ks&3)!==0&&ba(),Mn(e),x=e.pendingLanes,(i&4194090)!==0&&(x&42)!==0?e===Uc?Gr++:(Gr=0,Uc=e):Gr=0,Yr(0)}}function Cy(e,t){(e.pooledCacheLanes&=t)===0&&(t=e.pooledCache,t!=null&&(e.pooledCache=null,Ar(t)))}function ba(e){return By(),Ny(),qy(),My()}function My(){if(Pt!==5)return!1;var e=Ei,t=Cc;Cc=0;var i=us(Ks),r=O.T,x=P.p;try{P.p=32>i?32:i,O.T=null,i=Mc,Mc=null;var K=Ei,ae=Ks;if(Pt=0,Is=Ei=null,Ks=0,(lt&6)!==0)throw Error(l(331));var ge=lt;if(lt|=4,my(K.current),py(K,K.current,ae,i),lt=ge,Yr(0,!1),ne&&typeof ne.onPostCommitFiberRoot=="function")try{ne.onPostCommitFiberRoot(F,K)}catch{}return!0}finally{P.p=x,O.T=r,Cy(e,t)}}function Uy(e,t,i){t=pn(i,t),t=gc(e.stateNode,t,2),e=pi(e,t,2),e!==null&&(Oi(e,2),Mn(e))}function pt(e,t,i){if(e.tag===3)Uy(e,e,i);else for(;t!==null;){if(t.tag===3){Uy(t,e,i);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(xi===null||!xi.has(r))){e=pn(i,e),i=Kp(2),r=pi(t,i,2),r!==null&&(zp(i,r,t,e),Oi(r,2),Mn(r));break}}t=t.return}}function Kc(e,t,i){var r=e.pingCache;if(r===null){r=e.pingCache=new Dk;var x=new Set;r.set(t,x)}else x=r.get(t),x===void 0&&(x=new Set,r.set(t,x));x.has(i)||(Dc=!0,x.add(i),e=Mk.bind(null,e,t,i),t.then(e,e))}function Mk(e,t,i){var r=e.pingCache;r!==null&&r.delete(t),e.pingedLanes|=e.suspendedLanes&i,e.warmLanes&=~i,yt===e&&(nt&i)===i&&(vt===4||vt===3&&(nt&62914560)===nt&&300>L()-qc?(lt&2)===0&&zs(e,0):Bc|=i,Ps===nt&&(Ps=0)),Mn(e)}function Oy(e,t){t===0&&(t=hs()),e=Ss(e,t),e!==null&&(Oi(e,t),Mn(e))}function Uk(e){var t=e.memoizedState,i=0;t!==null&&(i=t.retryLane),Oy(e,i)}function Ok(e,t){var i=0;switch(e.tag){case 13:var r=e.stateNode,x=e.memoizedState;x!==null&&(i=x.retryLane);break;case 19:r=e.stateNode;break;case 22:r=e.stateNode._retryCache;break;default:throw Error(l(314))}r!==null&&r.delete(t),Oy(e,i)}function Pk(e,t){return k(e,t)}var va=null,Fs=null,zc=!1,ka=!1,Hc=!1,ss=0;function Mn(e){e!==Fs&&e.next===null&&(Fs===null?va=Fs=e:Fs=Fs.next=e),ka=!0,zc||(zc=!0,Kk())}function Yr(e,t){if(!Hc&&ka){Hc=!0;do for(var i=!1,r=va;r!==null;){if(e!==0){var x=r.pendingLanes;if(x===0)var K=0;else{var ae=r.suspendedLanes,ge=r.pingedLanes;K=(1<<31-me(42|e)+1)-1,K&=x&~(ae&~ge),K=K&201326741?K&201326741|1:K?K|2:0}K!==0&&(i=!0,zy(r,K))}else K=nt,K=at(r,r===yt?K:0,r.cancelPendingCommit!==null||r.timeoutHandle!==-1),(K&3)===0||xt(r,K)||(i=!0,zy(r,K));r=r.next}while(i);Hc=!1}}function Ik(){Py()}function Py(){ka=zc=!1;var e=0;ss!==0&&(Wk()&&(e=ss),ss=0);for(var t=L(),i=null,r=va;r!==null;){var x=r.next,K=Iy(r,t);K===0?(r.next=null,i===null?va=x:i.next=x,x===null&&(Fs=i)):(i=r,(e!==0||(K&3)!==0)&&(ka=!0)),r=x}Yr(e)}function Iy(e,t){for(var i=e.suspendedLanes,r=e.pingedLanes,x=e.expirationTimes,K=e.pendingLanes&-62914561;0<K;){var ae=31-me(K),ge=1<<ae,be=x[ae];be===-1?((ge&i)===0||(ge&r)!==0)&&(x[ae]=ii(ge,t)):be<=t&&(e.expiredLanes|=ge),K&=~ge}if(t=yt,i=nt,i=at(e,e===t?i:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),r=e.callbackNode,i===0||e===t&&(ct===2||ct===9)||e.cancelPendingCommit!==null)return r!==null&&r!==null&&X(r),e.callbackNode=null,e.callbackPriority=0;if((i&3)===0||xt(e,i)){if(t=i&-i,t===e.callbackPriority)return t;switch(r!==null&&X(r),us(i)){case 2:case 8:i=de;break;case 32:i=C;break;case 268435456:i=fe;break;default:i=C}return r=Ky.bind(null,e),i=k(i,r),e.callbackPriority=t,e.callbackNode=i,t}return r!==null&&r!==null&&X(r),e.callbackPriority=2,e.callbackNode=null,2}function Ky(e,t){if(Pt!==0&&Pt!==5)return e.callbackNode=null,e.callbackPriority=0,null;var i=e.callbackNode;if(ba()&&e.callbackNode!==i)return null;var r=nt;return r=at(e,e===yt?r:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),r===0?null:(ky(e,r,t),Iy(e,L()),e.callbackNode!=null&&e.callbackNode===i?Ky.bind(null,e):null)}function zy(e,t){if(ba())return null;ky(e,t,!0)}function Kk(){Xk(function(){(lt&6)!==0?k(te,Ik):Py()})}function Fc(){return ss===0&&(ss=si()),ss}function Hy(e){return e==null||typeof e=="symbol"||typeof e=="boolean"?null:typeof e=="function"?e:Yt(""+e)}function Fy(e,t){var i=t.ownerDocument.createElement("input");return i.name=t.name,i.value=t.value,e.id&&i.setAttribute("form",e.id),t.parentNode.insertBefore(i,t),e=new FormData(e),i.parentNode.removeChild(i),e}function zk(e,t,i,r,x){if(t==="submit"&&i&&i.stateNode===x){var K=Hy((x[zt]||null).action),ae=r.submitter;ae&&(t=(t=ae[zt]||null)?Hy(t.formAction):ae.getAttribute("formAction"),t!==null&&(K=t,ae=null));var ge=new Oo("action","action",null,r,x);e.push({event:ge,listeners:[{instance:null,listener:function(){if(r.defaultPrevented){if(ss!==0){var be=ae?Fy(x,ae):new FormData(x);cc(i,{pending:!0,data:be,method:x.method,action:K},null,be)}}else typeof K=="function"&&(ge.preventDefault(),be=ae?Fy(x,ae):new FormData(x),cc(i,{pending:!0,data:be,method:x.method,action:K},K,be))},currentTarget:x}]})}}for(var Vc=0;Vc<Ll.length;Vc++){var jc=Ll[Vc],Hk=jc.toLowerCase(),Fk=jc[0].toUpperCase()+jc.slice(1);xn(Hk,"on"+Fk)}xn(kg,"onAnimationEnd"),xn(Sg,"onAnimationIteration"),xn(xg,"onAnimationStart"),xn("dblclick","onDoubleClick"),xn("focusin","onFocus"),xn("focusout","onBlur"),xn(ok,"onTransitionRun"),xn(ak,"onTransitionStart"),xn(lk,"onTransitionCancel"),xn(Eg,"onTransitionEnd"),li("onMouseEnter",["mouseout","mouseover"]),li("onMouseLeave",["mouseout","mouseover"]),li("onPointerEnter",["pointerout","pointerover"]),li("onPointerLeave",["pointerout","pointerover"]),In("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),In("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),In("onBeforeInput",["compositionend","keypress","textInput","paste"]),In("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),In("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),In("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Wr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Vk=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Wr));function Vy(e,t){t=(t&4)!==0;for(var i=0;i<e.length;i++){var r=e[i],x=r.event;r=r.listeners;e:{var K=void 0;if(t)for(var ae=r.length-1;0<=ae;ae--){var ge=r[ae],be=ge.instance,Re=ge.currentTarget;if(ge=ge.listener,be!==K&&x.isPropagationStopped())break e;K=ge,x.currentTarget=Re;try{K(x)}catch(De){ca(De)}x.currentTarget=null,K=be}else for(ae=0;ae<r.length;ae++){if(ge=r[ae],be=ge.instance,Re=ge.currentTarget,ge=ge.listener,be!==K&&x.isPropagationStopped())break e;K=ge,x.currentTarget=Re;try{K(x)}catch(De){ca(De)}x.currentTarget=null,K=be}}}}function Je(e,t){var i=t[or];i===void 0&&(i=t[or]=new Set);var r=e+"__bubble";i.has(r)||(jy(t,e,2,!1),i.add(r))}function Gc(e,t,i){var r=0;t&&(r|=4),jy(i,e,r,t)}var Sa="_reactListening"+Math.random().toString(36).slice(2);function Yc(e){if(!e[Sa]){e[Sa]=!0,Eo.forEach(function(i){i!=="selectionchange"&&(Vk.has(i)||Gc(i,!1,e),Gc(i,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[Sa]||(t[Sa]=!0,Gc("selectionchange",!1,t))}}function jy(e,t,i,r){switch(p_(t)){case 2:var x=_1;break;case 8:x=m1;break;default:x=ah}i=x.bind(null,t,i,e),x=void 0,!pl||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(x=!0),r?x!==void 0?e.addEventListener(t,i,{capture:!0,passive:x}):e.addEventListener(t,i,!0):x!==void 0?e.addEventListener(t,i,{passive:x}):e.addEventListener(t,i,!1)}function Wc(e,t,i,r,x){var K=r;if((t&1)===0&&(t&2)===0&&r!==null)e:for(;;){if(r===null)return;var ae=r.tag;if(ae===3||ae===4){var ge=r.stateNode.containerInfo;if(ge===x)break;if(ae===4)for(ae=r.return;ae!==null;){var be=ae.tag;if((be===3||be===4)&&ae.stateNode.containerInfo===x)return;ae=ae.return}for(;ge!==null;){if(ae=oi(ge),ae===null)return;if(be=ae.tag,be===5||be===6||be===26||be===27){r=K=ae;continue e}ge=ge.parentNode}}r=r.return}$f(function(){var Re=K,De=Hi(i),Ne=[];e:{var Le=Ag.get(e);if(Le!==void 0){var Te=Oo,Ge=e;switch(e){case"keypress":if(Mo(i)===0)break e;case"keydown":case"keyup":Te=P0;break;case"focusin":Ge="focus",Te=wl;break;case"focusout":Ge="blur",Te=wl;break;case"beforeblur":case"afterblur":Te=wl;break;case"click":if(i.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Te=tg;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Te=A0;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Te=z0;break;case kg:case Sg:case xg:Te=T0;break;case Eg:Te=F0;break;case"scroll":case"scrollend":Te=x0;break;case"wheel":Te=j0;break;case"copy":case"cut":case"paste":Te=B0;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Te=ig;break;case"toggle":case"beforetoggle":Te=Y0}var Fe=(t&4)!==0,ft=!Fe&&(e==="scroll"||e==="scrollend"),xe=Fe?Le!==null?Le+"Capture":null:Le;Fe=[];for(var Se=Re,Ae;Se!==null;){var Be=Se;if(Ae=Be.stateNode,Be=Be.tag,Be!==5&&Be!==26&&Be!==27||Ae===null||xe===null||(Be=fr(Se,xe),Be!=null&&Fe.push(Qr(Se,Be,Ae))),ft)break;Se=Se.return}0<Fe.length&&(Le=new Te(Le,Ge,null,i,De),Ne.push({event:Le,listeners:Fe}))}}if((t&7)===0){e:{if(Le=e==="mouseover"||e==="pointerover",Te=e==="mouseout"||e==="pointerout",Le&&i!==gn&&(Ge=i.relatedTarget||i.fromElement)&&(oi(Ge)||Ge[ri]))break e;if((Te||Le)&&(Le=De.window===De?De:(Le=De.ownerDocument)?Le.defaultView||Le.parentWindow:window,Te?(Ge=i.relatedTarget||i.toElement,Te=Re,Ge=Ge?oi(Ge):null,Ge!==null&&(ft=y(Ge),Fe=Ge.tag,Ge!==ft||Fe!==5&&Fe!==27&&Fe!==6)&&(Ge=null)):(Te=null,Ge=Re),Te!==Ge)){if(Fe=tg,Be="onMouseLeave",xe="onMouseEnter",Se="mouse",(e==="pointerout"||e==="pointerover")&&(Fe=ig,Be="onPointerLeave",xe="onPointerEnter",Se="pointer"),ft=Te==null?Le:Ii(Te),Ae=Ge==null?Le:Ii(Ge),Le=new Fe(Be,Se+"leave",Te,i,De),Le.target=ft,Le.relatedTarget=Ae,Be=null,oi(De)===Re&&(Fe=new Fe(xe,Se+"enter",Ge,i,De),Fe.target=Ae,Fe.relatedTarget=ft,Be=Fe),ft=Be,Te&&Ge)t:{for(Fe=Te,xe=Ge,Se=0,Ae=Fe;Ae;Ae=Vs(Ae))Se++;for(Ae=0,Be=xe;Be;Be=Vs(Be))Ae++;for(;0<Se-Ae;)Fe=Vs(Fe),Se--;for(;0<Ae-Se;)xe=Vs(xe),Ae--;for(;Se--;){if(Fe===xe||xe!==null&&Fe===xe.alternate)break t;Fe=Vs(Fe),xe=Vs(xe)}Fe=null}else Fe=null;Te!==null&&Gy(Ne,Le,Te,Fe,!1),Ge!==null&&ft!==null&&Gy(Ne,ft,Ge,Fe,!0)}}e:{if(Le=Re?Ii(Re):window,Te=Le.nodeName&&Le.nodeName.toLowerCase(),Te==="select"||Te==="input"&&Le.type==="file")var Ie=ug;else if(cg(Le))if(dg)Ie=ik;else{Ie=tk;var Ze=ek}else Te=Le.nodeName,!Te||Te.toLowerCase()!=="input"||Le.type!=="checkbox"&&Le.type!=="radio"?Re&&Dn(Re.elementType)&&(Ie=ug):Ie=nk;if(Ie&&(Ie=Ie(e,Re))){hg(Ne,Ie,i,De);break e}Ze&&Ze(e,Le,Re),e==="focusout"&&Re&&Le.type==="number"&&Re.memoizedProps.value!=null&&dr(Le,"number",Le.value)}switch(Ze=Re?Ii(Re):window,e){case"focusin":(cg(Ze)||Ze.contentEditable==="true")&&(bs=Ze,El=Re,vr=null);break;case"focusout":vr=El=bs=null;break;case"mousedown":Al=!0;break;case"contextmenu":case"mouseup":case"dragend":Al=!1,bg(Ne,i,De);break;case"selectionchange":if(rk)break;case"keydown":case"keyup":bg(Ne,i,De)}var Ke;if(vl)e:{switch(e){case"compositionstart":var Ve="onCompositionStart";break e;case"compositionend":Ve="onCompositionEnd";break e;case"compositionupdate":Ve="onCompositionUpdate";break e}Ve=void 0}else ws?ag(e,i)&&(Ve="onCompositionEnd"):e==="keydown"&&i.keyCode===229&&(Ve="onCompositionStart");Ve&&(sg&&i.locale!=="ko"&&(ws||Ve!=="onCompositionStart"?Ve==="onCompositionEnd"&&ws&&(Ke=Jf()):(ui=De,yl="value"in ui?ui.value:ui.textContent,ws=!0)),Ze=xa(Re,Ve),0<Ze.length&&(Ve=new ng(Ve,e,null,i,De),Ne.push({event:Ve,listeners:Ze}),Ke?Ve.data=Ke:(Ke=lg(i),Ke!==null&&(Ve.data=Ke)))),(Ke=Q0?X0(e,i):Z0(e,i))&&(Ve=xa(Re,"onBeforeInput"),0<Ve.length&&(Ze=new ng("onBeforeInput","beforeinput",null,i,De),Ne.push({event:Ze,listeners:Ve}),Ze.data=Ke)),zk(Ne,e,Re,i,De)}Vy(Ne,t)})}function Qr(e,t,i){return{instance:e,listener:t,currentTarget:i}}function xa(e,t){for(var i=t+"Capture",r=[];e!==null;){var x=e,K=x.stateNode;if(x=x.tag,x!==5&&x!==26&&x!==27||K===null||(x=fr(e,i),x!=null&&r.unshift(Qr(e,x,K)),x=fr(e,t),x!=null&&r.push(Qr(e,x,K))),e.tag===3)return r;e=e.return}return[]}function Vs(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5&&e.tag!==27);return e||null}function Gy(e,t,i,r,x){for(var K=t._reactName,ae=[];i!==null&&i!==r;){var ge=i,be=ge.alternate,Re=ge.stateNode;if(ge=ge.tag,be!==null&&be===r)break;ge!==5&&ge!==26&&ge!==27||Re===null||(be=Re,x?(Re=fr(i,K),Re!=null&&ae.unshift(Qr(i,Re,be))):x||(Re=fr(i,K),Re!=null&&ae.push(Qr(i,Re,be)))),i=i.return}ae.length!==0&&e.push({event:t,listeners:ae})}var jk=/\r\n?/g,Gk=/\u0000|\uFFFD/g;function Yy(e){return(typeof e=="string"?e:""+e).replace(jk,`
`).replace(Gk,"")}function Wy(e,t){return t=Yy(t),Yy(e)===t}function Ea(){}function dt(e,t,i,r,x,K){switch(i){case"children":typeof r=="string"?t==="body"||t==="textarea"&&r===""||He(e,r):(typeof r=="number"||typeof r=="bigint")&&t!=="body"&&He(e,""+r);break;case"className":Ki(e,"class",r);break;case"tabIndex":Ki(e,"tabindex",r);break;case"dir":case"role":case"viewBox":case"width":case"height":Ki(e,i,r);break;case"style":ht(e,r,K);break;case"data":if(t!=="object"){Ki(e,"data",r);break}case"src":case"href":if(r===""&&(t!=="a"||i!=="href")){e.removeAttribute(i);break}if(r==null||typeof r=="function"||typeof r=="symbol"||typeof r=="boolean"){e.removeAttribute(i);break}r=Yt(""+r),e.setAttribute(i,r);break;case"action":case"formAction":if(typeof r=="function"){e.setAttribute(i,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof K=="function"&&(i==="formAction"?(t!=="input"&&dt(e,t,"name",x.name,x,null),dt(e,t,"formEncType",x.formEncType,x,null),dt(e,t,"formMethod",x.formMethod,x,null),dt(e,t,"formTarget",x.formTarget,x,null)):(dt(e,t,"encType",x.encType,x,null),dt(e,t,"method",x.method,x,null),dt(e,t,"target",x.target,x,null)));if(r==null||typeof r=="symbol"||typeof r=="boolean"){e.removeAttribute(i);break}r=Yt(""+r),e.setAttribute(i,r);break;case"onClick":r!=null&&(e.onclick=Ea);break;case"onScroll":r!=null&&Je("scroll",e);break;case"onScrollEnd":r!=null&&Je("scrollend",e);break;case"dangerouslySetInnerHTML":if(r!=null){if(typeof r!="object"||!("__html"in r))throw Error(l(61));if(i=r.__html,i!=null){if(x.children!=null)throw Error(l(60));e.innerHTML=i}}break;case"multiple":e.multiple=r&&typeof r!="function"&&typeof r!="symbol";break;case"muted":e.muted=r&&typeof r!="function"&&typeof r!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(r==null||typeof r=="function"||typeof r=="boolean"||typeof r=="symbol"){e.removeAttribute("xlink:href");break}i=Yt(""+r),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",i);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":r!=null&&typeof r!="function"&&typeof r!="symbol"?e.setAttribute(i,""+r):e.removeAttribute(i);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":r&&typeof r!="function"&&typeof r!="symbol"?e.setAttribute(i,""):e.removeAttribute(i);break;case"capture":case"download":r===!0?e.setAttribute(i,""):r!==!1&&r!=null&&typeof r!="function"&&typeof r!="symbol"?e.setAttribute(i,r):e.removeAttribute(i);break;case"cols":case"rows":case"size":case"span":r!=null&&typeof r!="function"&&typeof r!="symbol"&&!isNaN(r)&&1<=r?e.setAttribute(i,r):e.removeAttribute(i);break;case"rowSpan":case"start":r==null||typeof r=="function"||typeof r=="symbol"||isNaN(r)?e.removeAttribute(i):e.setAttribute(i,r);break;case"popover":Je("beforetoggle",e),Je("toggle",e),Tn(e,"popover",r);break;case"xlinkActuate":on(e,"http://www.w3.org/1999/xlink","xlink:actuate",r);break;case"xlinkArcrole":on(e,"http://www.w3.org/1999/xlink","xlink:arcrole",r);break;case"xlinkRole":on(e,"http://www.w3.org/1999/xlink","xlink:role",r);break;case"xlinkShow":on(e,"http://www.w3.org/1999/xlink","xlink:show",r);break;case"xlinkTitle":on(e,"http://www.w3.org/1999/xlink","xlink:title",r);break;case"xlinkType":on(e,"http://www.w3.org/1999/xlink","xlink:type",r);break;case"xmlBase":on(e,"http://www.w3.org/XML/1998/namespace","xml:base",r);break;case"xmlLang":on(e,"http://www.w3.org/XML/1998/namespace","xml:lang",r);break;case"xmlSpace":on(e,"http://www.w3.org/XML/1998/namespace","xml:space",r);break;case"is":Tn(e,"is",r);break;case"innerText":case"textContent":break;default:(!(2<i.length)||i[0]!=="o"&&i[0]!=="O"||i[1]!=="n"&&i[1]!=="N")&&(i=zi.get(i)||i,Tn(e,i,r))}}function Qc(e,t,i,r,x,K){switch(i){case"style":ht(e,r,K);break;case"dangerouslySetInnerHTML":if(r!=null){if(typeof r!="object"||!("__html"in r))throw Error(l(61));if(i=r.__html,i!=null){if(x.children!=null)throw Error(l(60));e.innerHTML=i}}break;case"children":typeof r=="string"?He(e,r):(typeof r=="number"||typeof r=="bigint")&&He(e,""+r);break;case"onScroll":r!=null&&Je("scroll",e);break;case"onScrollEnd":r!=null&&Je("scrollend",e);break;case"onClick":r!=null&&(e.onclick=Ea);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Ao.hasOwnProperty(i))e:{if(i[0]==="o"&&i[1]==="n"&&(x=i.endsWith("Capture"),t=i.slice(2,x?i.length-7:void 0),K=e[zt]||null,K=K!=null?K[i]:null,typeof K=="function"&&e.removeEventListener(t,K,x),typeof r=="function")){typeof K!="function"&&K!==null&&(i in e?e[i]=null:e.hasAttribute(i)&&e.removeAttribute(i)),e.addEventListener(t,r,x);break e}i in e?e[i]=r:r===!0?e.setAttribute(i,""):Tn(e,i,r)}}}function It(e,t,i){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Je("error",e),Je("load",e);var r=!1,x=!1,K;for(K in i)if(i.hasOwnProperty(K)){var ae=i[K];if(ae!=null)switch(K){case"src":r=!0;break;case"srcSet":x=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(l(137,t));default:dt(e,t,K,ae,i,null)}}x&&dt(e,t,"srcSet",i.srcSet,i,null),r&&dt(e,t,"src",i.src,i,null);return;case"input":Je("invalid",e);var ge=K=ae=x=null,be=null,Re=null;for(r in i)if(i.hasOwnProperty(r)){var De=i[r];if(De!=null)switch(r){case"name":x=De;break;case"type":ae=De;break;case"checked":be=De;break;case"defaultChecked":Re=De;break;case"value":K=De;break;case"defaultValue":ge=De;break;case"children":case"dangerouslySetInnerHTML":if(De!=null)throw Error(l(137,t));break;default:dt(e,t,r,De,i,null)}}qo(e,K,ge,be,Re,ae,x,!1),ps(e);return;case"select":Je("invalid",e),r=ae=K=null;for(x in i)if(i.hasOwnProperty(x)&&(ge=i[x],ge!=null))switch(x){case"value":K=ge;break;case"defaultValue":ae=ge;break;case"multiple":r=ge;default:dt(e,t,x,ge,i,null)}t=K,i=ae,e.multiple=!!r,t!=null?Me(e,!!r,t,!1):i!=null&&Me(e,!!r,i,!0);return;case"textarea":Je("invalid",e),K=x=r=null;for(ae in i)if(i.hasOwnProperty(ae)&&(ge=i[ae],ge!=null))switch(ae){case"value":r=ge;break;case"defaultValue":x=ge;break;case"children":K=ge;break;case"dangerouslySetInnerHTML":if(ge!=null)throw Error(l(91));break;default:dt(e,t,ae,ge,i,null)}Ce(e,r,x,K),ps(e);return;case"option":for(be in i)if(i.hasOwnProperty(be)&&(r=i[be],r!=null))switch(be){case"selected":e.selected=r&&typeof r!="function"&&typeof r!="symbol";break;default:dt(e,t,be,r,i,null)}return;case"dialog":Je("beforetoggle",e),Je("toggle",e),Je("cancel",e),Je("close",e);break;case"iframe":case"object":Je("load",e);break;case"video":case"audio":for(r=0;r<Wr.length;r++)Je(Wr[r],e);break;case"image":Je("error",e),Je("load",e);break;case"details":Je("toggle",e);break;case"embed":case"source":case"link":Je("error",e),Je("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Re in i)if(i.hasOwnProperty(Re)&&(r=i[Re],r!=null))switch(Re){case"children":case"dangerouslySetInnerHTML":throw Error(l(137,t));default:dt(e,t,Re,r,i,null)}return;default:if(Dn(t)){for(De in i)i.hasOwnProperty(De)&&(r=i[De],r!==void 0&&Qc(e,t,De,r,i,void 0));return}}for(ge in i)i.hasOwnProperty(ge)&&(r=i[ge],r!=null&&dt(e,t,ge,r,i,null))}function Yk(e,t,i,r){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var x=null,K=null,ae=null,ge=null,be=null,Re=null,De=null;for(Te in i){var Ne=i[Te];if(i.hasOwnProperty(Te)&&Ne!=null)switch(Te){case"checked":break;case"value":break;case"defaultValue":be=Ne;default:r.hasOwnProperty(Te)||dt(e,t,Te,null,r,Ne)}}for(var Le in r){var Te=r[Le];if(Ne=i[Le],r.hasOwnProperty(Le)&&(Te!=null||Ne!=null))switch(Le){case"type":K=Te;break;case"name":x=Te;break;case"checked":Re=Te;break;case"defaultChecked":De=Te;break;case"value":ae=Te;break;case"defaultValue":ge=Te;break;case"children":case"dangerouslySetInnerHTML":if(Te!=null)throw Error(l(137,t));break;default:Te!==Ne&&dt(e,t,Le,Te,r,Ne)}}_s(e,ae,ge,be,Re,De,K,x);return;case"select":Te=ae=ge=Le=null;for(K in i)if(be=i[K],i.hasOwnProperty(K)&&be!=null)switch(K){case"value":break;case"multiple":Te=be;default:r.hasOwnProperty(K)||dt(e,t,K,null,r,be)}for(x in r)if(K=r[x],be=i[x],r.hasOwnProperty(x)&&(K!=null||be!=null))switch(x){case"value":Le=K;break;case"defaultValue":ge=K;break;case"multiple":ae=K;default:K!==be&&dt(e,t,x,K,r,be)}t=ge,i=ae,r=Te,Le!=null?Me(e,!!i,Le,!1):!!r!=!!i&&(t!=null?Me(e,!!i,t,!0):Me(e,!!i,i?[]:"",!1));return;case"textarea":Te=Le=null;for(ge in i)if(x=i[ge],i.hasOwnProperty(ge)&&x!=null&&!r.hasOwnProperty(ge))switch(ge){case"value":break;case"children":break;default:dt(e,t,ge,null,r,x)}for(ae in r)if(x=r[ae],K=i[ae],r.hasOwnProperty(ae)&&(x!=null||K!=null))switch(ae){case"value":Le=x;break;case"defaultValue":Te=x;break;case"children":break;case"dangerouslySetInnerHTML":if(x!=null)throw Error(l(91));break;default:x!==K&&dt(e,t,ae,x,r,K)}pe(e,Le,Te);return;case"option":for(var Ge in i)if(Le=i[Ge],i.hasOwnProperty(Ge)&&Le!=null&&!r.hasOwnProperty(Ge))switch(Ge){case"selected":e.selected=!1;break;default:dt(e,t,Ge,null,r,Le)}for(be in r)if(Le=r[be],Te=i[be],r.hasOwnProperty(be)&&Le!==Te&&(Le!=null||Te!=null))switch(be){case"selected":e.selected=Le&&typeof Le!="function"&&typeof Le!="symbol";break;default:dt(e,t,be,Le,r,Te)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Fe in i)Le=i[Fe],i.hasOwnProperty(Fe)&&Le!=null&&!r.hasOwnProperty(Fe)&&dt(e,t,Fe,null,r,Le);for(Re in r)if(Le=r[Re],Te=i[Re],r.hasOwnProperty(Re)&&Le!==Te&&(Le!=null||Te!=null))switch(Re){case"children":case"dangerouslySetInnerHTML":if(Le!=null)throw Error(l(137,t));break;default:dt(e,t,Re,Le,r,Te)}return;default:if(Dn(t)){for(var ft in i)Le=i[ft],i.hasOwnProperty(ft)&&Le!==void 0&&!r.hasOwnProperty(ft)&&Qc(e,t,ft,void 0,r,Le);for(De in r)Le=r[De],Te=i[De],!r.hasOwnProperty(De)||Le===Te||Le===void 0&&Te===void 0||Qc(e,t,De,Le,r,Te);return}}for(var xe in i)Le=i[xe],i.hasOwnProperty(xe)&&Le!=null&&!r.hasOwnProperty(xe)&&dt(e,t,xe,null,r,Le);for(Ne in r)Le=r[Ne],Te=i[Ne],!r.hasOwnProperty(Ne)||Le===Te||Le==null&&Te==null||dt(e,t,Ne,Le,r,Te)}var Xc=null,Zc=null;function Aa(e){return e.nodeType===9?e:e.ownerDocument}function Qy(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function Xy(e,t){if(e===0)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return e===1&&t==="foreignObject"?0:e}function $c(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.children=="bigint"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var Jc=null;function Wk(){var e=window.event;return e&&e.type==="popstate"?e===Jc?!1:(Jc=e,!0):(Jc=null,!1)}var Zy=typeof setTimeout=="function"?setTimeout:void 0,Qk=typeof clearTimeout=="function"?clearTimeout:void 0,$y=typeof Promise=="function"?Promise:void 0,Xk=typeof queueMicrotask=="function"?queueMicrotask:typeof $y<"u"?function(e){return $y.resolve(null).then(e).catch(Zk)}:Zy;function Zk(e){setTimeout(function(){throw e})}function Ri(e){return e==="head"}function Jy(e,t){var i=t,r=0,x=0;do{var K=i.nextSibling;if(e.removeChild(i),K&&K.nodeType===8)if(i=K.data,i==="/$"){if(0<r&&8>r){i=r;var ae=e.ownerDocument;if(i&1&&Xr(ae.documentElement),i&2&&Xr(ae.body),i&4)for(i=ae.head,Xr(i),ae=i.firstChild;ae;){var ge=ae.nextSibling,be=ae.nodeName;ae[Pi]||be==="SCRIPT"||be==="STYLE"||be==="LINK"&&ae.rel.toLowerCase()==="stylesheet"||i.removeChild(ae),ae=ge}}if(x===0){e.removeChild(K),so(t);return}x--}else i==="$"||i==="$?"||i==="$!"?x++:r=i.charCodeAt(0)-48;else r=0;i=K}while(i);so(t)}function eh(e){var t=e.firstChild;for(t&&t.nodeType===10&&(t=t.nextSibling);t;){var i=t;switch(t=t.nextSibling,i.nodeName){case"HTML":case"HEAD":case"BODY":eh(i),lr(i);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(i.rel.toLowerCase()==="stylesheet")continue}e.removeChild(i)}}function $k(e,t,i,r){for(;e.nodeType===1;){var x=i;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!r&&(e.nodeName!=="INPUT"||e.type!=="hidden"))break}else if(r){if(!e[Pi])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if(K=e.getAttribute("rel"),K==="stylesheet"&&e.hasAttribute("data-precedence"))break;if(K!==x.rel||e.getAttribute("href")!==(x.href==null||x.href===""?null:x.href)||e.getAttribute("crossorigin")!==(x.crossOrigin==null?null:x.crossOrigin)||e.getAttribute("title")!==(x.title==null?null:x.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(K=e.getAttribute("src"),(K!==(x.src==null?null:x.src)||e.getAttribute("type")!==(x.type==null?null:x.type)||e.getAttribute("crossorigin")!==(x.crossOrigin==null?null:x.crossOrigin))&&K&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else if(t==="input"&&e.type==="hidden"){var K=x.name==null?null:""+x.name;if(x.type==="hidden"&&e.getAttribute("name")===K)return e}else return e;if(e=An(e.nextSibling),e===null)break}return null}function Jk(e,t,i){if(t==="")return null;for(;e.nodeType!==3;)if((e.nodeType!==1||e.nodeName!=="INPUT"||e.type!=="hidden")&&!i||(e=An(e.nextSibling),e===null))return null;return e}function th(e){return e.data==="$!"||e.data==="$?"&&e.ownerDocument.readyState==="complete"}function e1(e,t){var i=e.ownerDocument;if(e.data!=="$?"||i.readyState==="complete")t();else{var r=function(){t(),i.removeEventListener("DOMContentLoaded",r)};i.addEventListener("DOMContentLoaded",r),e._reactRetry=r}}function An(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?"||t==="F!"||t==="F")break;if(t==="/$")return null}}return e}var nh=null;function e_(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var i=e.data;if(i==="$"||i==="$!"||i==="$?"){if(t===0)return e;t--}else i==="/$"&&t++}e=e.previousSibling}return null}function t_(e,t,i){switch(t=Aa(i),e){case"html":if(e=t.documentElement,!e)throw Error(l(452));return e;case"head":if(e=t.head,!e)throw Error(l(453));return e;case"body":if(e=t.body,!e)throw Error(l(454));return e;default:throw Error(l(451))}}function Xr(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);lr(e)}var vn=new Map,n_=new Set;function Ra(e){return typeof e.getRootNode=="function"?e.getRootNode():e.nodeType===9?e:e.ownerDocument}var Jn=P.d;P.d={f:t1,r:n1,D:i1,C:s1,L:r1,m:o1,X:l1,S:a1,M:c1};function t1(){var e=Jn.f(),t=ma();return e||t}function n1(e){var t=ai(e);t!==null&&t.tag===5&&t.type==="form"?kp(t):Jn.r(e)}var js=typeof document>"u"?null:document;function i_(e,t,i){var r=js;if(r&&typeof t=="string"&&t){var x=Gt(t);x='link[rel="'+e+'"][href="'+x+'"]',typeof i=="string"&&(x+='[crossorigin="'+i+'"]'),n_.has(x)||(n_.add(x),e={rel:e,crossOrigin:i,href:t},r.querySelector(x)===null&&(t=r.createElement("link"),It(t,"link",e),Et(t),r.head.appendChild(t)))}}function i1(e){Jn.D(e),i_("dns-prefetch",e,null)}function s1(e,t){Jn.C(e,t),i_("preconnect",e,t)}function r1(e,t,i){Jn.L(e,t,i);var r=js;if(r&&e&&t){var x='link[rel="preload"][as="'+Gt(t)+'"]';t==="image"&&i&&i.imageSrcSet?(x+='[imagesrcset="'+Gt(i.imageSrcSet)+'"]',typeof i.imageSizes=="string"&&(x+='[imagesizes="'+Gt(i.imageSizes)+'"]')):x+='[href="'+Gt(e)+'"]';var K=x;switch(t){case"style":K=Gs(e);break;case"script":K=Ys(e)}vn.has(K)||(e=u({rel:"preload",href:t==="image"&&i&&i.imageSrcSet?void 0:e,as:t},i),vn.set(K,e),r.querySelector(x)!==null||t==="style"&&r.querySelector(Zr(K))||t==="script"&&r.querySelector($r(K))||(t=r.createElement("link"),It(t,"link",e),Et(t),r.head.appendChild(t)))}}function o1(e,t){Jn.m(e,t);var i=js;if(i&&e){var r=t&&typeof t.as=="string"?t.as:"script",x='link[rel="modulepreload"][as="'+Gt(r)+'"][href="'+Gt(e)+'"]',K=x;switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":K=Ys(e)}if(!vn.has(K)&&(e=u({rel:"modulepreload",href:e},t),vn.set(K,e),i.querySelector(x)===null)){switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(i.querySelector($r(K)))return}r=i.createElement("link"),It(r,"link",e),Et(r),i.head.appendChild(r)}}}function a1(e,t,i){Jn.S(e,t,i);var r=js;if(r&&e){var x=Pn(r).hoistableStyles,K=Gs(e);t=t||"default";var ae=x.get(K);if(!ae){var ge={loading:0,preload:null};if(ae=r.querySelector(Zr(K)))ge.loading=5;else{e=u({rel:"stylesheet",href:e,"data-precedence":t},i),(i=vn.get(K))&&ih(e,i);var be=ae=r.createElement("link");Et(be),It(be,"link",e),be._p=new Promise(function(Re,De){be.onload=Re,be.onerror=De}),be.addEventListener("load",function(){ge.loading|=1}),be.addEventListener("error",function(){ge.loading|=2}),ge.loading|=4,La(ae,t,r)}ae={type:"stylesheet",instance:ae,count:1,state:ge},x.set(K,ae)}}}function l1(e,t){Jn.X(e,t);var i=js;if(i&&e){var r=Pn(i).hoistableScripts,x=Ys(e),K=r.get(x);K||(K=i.querySelector($r(x)),K||(e=u({src:e,async:!0},t),(t=vn.get(x))&&sh(e,t),K=i.createElement("script"),Et(K),It(K,"link",e),i.head.appendChild(K)),K={type:"script",instance:K,count:1,state:null},r.set(x,K))}}function c1(e,t){Jn.M(e,t);var i=js;if(i&&e){var r=Pn(i).hoistableScripts,x=Ys(e),K=r.get(x);K||(K=i.querySelector($r(x)),K||(e=u({src:e,async:!0,type:"module"},t),(t=vn.get(x))&&sh(e,t),K=i.createElement("script"),Et(K),It(K,"link",e),i.head.appendChild(K)),K={type:"script",instance:K,count:1,state:null},r.set(x,K))}}function s_(e,t,i,r){var x=(x=N.current)?Ra(x):null;if(!x)throw Error(l(446));switch(e){case"meta":case"title":return null;case"style":return typeof i.precedence=="string"&&typeof i.href=="string"?(t=Gs(i.href),i=Pn(x).hoistableStyles,r=i.get(t),r||(r={type:"style",instance:null,count:0,state:null},i.set(t,r)),r):{type:"void",instance:null,count:0,state:null};case"link":if(i.rel==="stylesheet"&&typeof i.href=="string"&&typeof i.precedence=="string"){e=Gs(i.href);var K=Pn(x).hoistableStyles,ae=K.get(e);if(ae||(x=x.ownerDocument||x,ae={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},K.set(e,ae),(K=x.querySelector(Zr(e)))&&!K._p&&(ae.instance=K,ae.state.loading=5),vn.has(e)||(i={rel:"preload",as:"style",href:i.href,crossOrigin:i.crossOrigin,integrity:i.integrity,media:i.media,hrefLang:i.hrefLang,referrerPolicy:i.referrerPolicy},vn.set(e,i),K||h1(x,e,i,ae.state))),t&&r===null)throw Error(l(528,""));return ae}if(t&&r!==null)throw Error(l(529,""));return null;case"script":return t=i.async,i=i.src,typeof i=="string"&&t&&typeof t!="function"&&typeof t!="symbol"?(t=Ys(i),i=Pn(x).hoistableScripts,r=i.get(t),r||(r={type:"script",instance:null,count:0,state:null},i.set(t,r)),r):{type:"void",instance:null,count:0,state:null};default:throw Error(l(444,e))}}function Gs(e){return'href="'+Gt(e)+'"'}function Zr(e){return'link[rel="stylesheet"]['+e+"]"}function r_(e){return u({},e,{"data-precedence":e.precedence,precedence:null})}function h1(e,t,i,r){e.querySelector('link[rel="preload"][as="style"]['+t+"]")?r.loading=1:(t=e.createElement("link"),r.preload=t,t.addEventListener("load",function(){return r.loading|=1}),t.addEventListener("error",function(){return r.loading|=2}),It(t,"link",i),Et(t),e.head.appendChild(t))}function Ys(e){return'[src="'+Gt(e)+'"]'}function $r(e){return"script[async]"+e}function o_(e,t,i){if(t.count++,t.instance===null)switch(t.type){case"style":var r=e.querySelector('style[data-href~="'+Gt(i.href)+'"]');if(r)return t.instance=r,Et(r),r;var x=u({},i,{"data-href":i.href,"data-precedence":i.precedence,href:null,precedence:null});return r=(e.ownerDocument||e).createElement("style"),Et(r),It(r,"style",x),La(r,i.precedence,e),t.instance=r;case"stylesheet":x=Gs(i.href);var K=e.querySelector(Zr(x));if(K)return t.state.loading|=4,t.instance=K,Et(K),K;r=r_(i),(x=vn.get(x))&&ih(r,x),K=(e.ownerDocument||e).createElement("link"),Et(K);var ae=K;return ae._p=new Promise(function(ge,be){ae.onload=ge,ae.onerror=be}),It(K,"link",r),t.state.loading|=4,La(K,i.precedence,e),t.instance=K;case"script":return K=Ys(i.src),(x=e.querySelector($r(K)))?(t.instance=x,Et(x),x):(r=i,(x=vn.get(K))&&(r=u({},i),sh(r,x)),e=e.ownerDocument||e,x=e.createElement("script"),Et(x),It(x,"link",r),e.head.appendChild(x),t.instance=x);case"void":return null;default:throw Error(l(443,t.type))}else t.type==="stylesheet"&&(t.state.loading&4)===0&&(r=t.instance,t.state.loading|=4,La(r,i.precedence,e));return t.instance}function La(e,t,i){for(var r=i.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),x=r.length?r[r.length-1]:null,K=x,ae=0;ae<r.length;ae++){var ge=r[ae];if(ge.dataset.precedence===t)K=ge;else if(K!==x)break}K?K.parentNode.insertBefore(e,K.nextSibling):(t=i.nodeType===9?i.head:i,t.insertBefore(e,t.firstChild))}function ih(e,t){e.crossOrigin==null&&(e.crossOrigin=t.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=t.referrerPolicy),e.title==null&&(e.title=t.title)}function sh(e,t){e.crossOrigin==null&&(e.crossOrigin=t.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=t.referrerPolicy),e.integrity==null&&(e.integrity=t.integrity)}var Ta=null;function a_(e,t,i){if(Ta===null){var r=new Map,x=Ta=new Map;x.set(i,r)}else x=Ta,r=x.get(i),r||(r=new Map,x.set(i,r));if(r.has(e))return r;for(r.set(e,null),i=i.getElementsByTagName(e),x=0;x<i.length;x++){var K=i[x];if(!(K[Pi]||K[Bt]||e==="link"&&K.getAttribute("rel")==="stylesheet")&&K.namespaceURI!=="http://www.w3.org/2000/svg"){var ae=K.getAttribute(t)||"";ae=e+ae;var ge=r.get(ae);ge?ge.push(K):r.set(ae,[K])}}return r}function l_(e,t,i){e=e.ownerDocument||e,e.head.insertBefore(i,t==="title"?e.querySelector("head > title"):null)}function u1(e,t,i){if(i===1||t.itemProp!=null)return!1;switch(e){case"meta":case"title":return!0;case"style":if(typeof t.precedence!="string"||typeof t.href!="string"||t.href==="")break;return!0;case"link":if(typeof t.rel!="string"||typeof t.href!="string"||t.href===""||t.onLoad||t.onError)break;switch(t.rel){case"stylesheet":return e=t.disabled,typeof t.precedence=="string"&&e==null;default:return!0}case"script":if(t.async&&typeof t.async!="function"&&typeof t.async!="symbol"&&!t.onLoad&&!t.onError&&t.src&&typeof t.src=="string")return!0}return!1}function c_(e){return!(e.type==="stylesheet"&&(e.state.loading&3)===0)}var Jr=null;function d1(){}function f1(e,t,i){if(Jr===null)throw Error(l(475));var r=Jr;if(t.type==="stylesheet"&&(typeof i.media!="string"||matchMedia(i.media).matches!==!1)&&(t.state.loading&4)===0){if(t.instance===null){var x=Gs(i.href),K=e.querySelector(Zr(x));if(K){e=K._p,e!==null&&typeof e=="object"&&typeof e.then=="function"&&(r.count++,r=Da.bind(r),e.then(r,r)),t.state.loading|=4,t.instance=K,Et(K);return}K=e.ownerDocument||e,i=r_(i),(x=vn.get(x))&&ih(i,x),K=K.createElement("link"),Et(K);var ae=K;ae._p=new Promise(function(ge,be){ae.onload=ge,ae.onerror=be}),It(K,"link",i),t.instance=K}r.stylesheets===null&&(r.stylesheets=new Map),r.stylesheets.set(t,e),(e=t.state.preload)&&(t.state.loading&3)===0&&(r.count++,t=Da.bind(r),e.addEventListener("load",t),e.addEventListener("error",t))}}function g1(){if(Jr===null)throw Error(l(475));var e=Jr;return e.stylesheets&&e.count===0&&rh(e,e.stylesheets),0<e.count?function(t){var i=setTimeout(function(){if(e.stylesheets&&rh(e,e.stylesheets),e.unsuspend){var r=e.unsuspend;e.unsuspend=null,r()}},6e4);return e.unsuspend=t,function(){e.unsuspend=null,clearTimeout(i)}}:null}function Da(){if(this.count--,this.count===0){if(this.stylesheets)rh(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}}var Ba=null;function rh(e,t){e.stylesheets=null,e.unsuspend!==null&&(e.count++,Ba=new Map,t.forEach(p1,e),Ba=null,Da.call(e))}function p1(e,t){if(!(t.state.loading&4)){var i=Ba.get(e);if(i)var r=i.get(null);else{i=new Map,Ba.set(e,i);for(var x=e.querySelectorAll("link[data-precedence],style[data-precedence]"),K=0;K<x.length;K++){var ae=x[K];(ae.nodeName==="LINK"||ae.getAttribute("media")!=="not all")&&(i.set(ae.dataset.precedence,ae),r=ae)}r&&i.set(null,r)}x=t.instance,ae=x.getAttribute("data-precedence"),K=i.get(ae)||r,K===r&&i.set(null,x),i.set(ae,x),this.count++,r=Da.bind(this),x.addEventListener("load",r),x.addEventListener("error",r),K?K.parentNode.insertBefore(x,K.nextSibling):(e=e.nodeType===9?e.head:e,e.insertBefore(x,e.firstChild)),t.state.loading|=4}}var eo={$$typeof:j,Provider:null,Consumer:null,_currentValue:Z,_currentValue2:Z,_threadCount:0};function y1(e,t,i,r,x,K,ae,ge){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Ui(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ui(0),this.hiddenUpdates=Ui(null),this.identifierPrefix=r,this.onUncaughtError=x,this.onCaughtError=K,this.onRecoverableError=ae,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=ge,this.incompleteTransitions=new Map}function h_(e,t,i,r,x,K,ae,ge,be,Re,De,Ne){return e=new y1(e,t,i,ae,ge,be,Re,Ne),t=1,K===!0&&(t|=24),K=ln(3,null,null,t),e.current=K,K.stateNode=e,t=Kl(),t.refCount++,e.pooledCache=t,t.refCount++,K.memoizedState={element:r,isDehydrated:i,cache:t},Vl(K),e}function u_(e){return e?(e=xs,e):xs}function d_(e,t,i,r,x,K){x=u_(x),r.context===null?r.context=x:r.pendingContext=x,r=gi(t),r.payload={element:i},K=K===void 0?null:K,K!==null&&(r.callback=K),i=pi(e,r,t),i!==null&&(fn(i,e,t),Dr(i,e,t))}function f_(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var i=e.retryLane;e.retryLane=i!==0&&i<t?i:t}}function oh(e,t){f_(e,t),(e=e.alternate)&&f_(e,t)}function g_(e){if(e.tag===13){var t=Ss(e,67108864);t!==null&&fn(t,e,67108864),oh(e,67108864)}}var Na=!0;function _1(e,t,i,r){var x=O.T;O.T=null;var K=P.p;try{P.p=2,ah(e,t,i,r)}finally{P.p=K,O.T=x}}function m1(e,t,i,r){var x=O.T;O.T=null;var K=P.p;try{P.p=8,ah(e,t,i,r)}finally{P.p=K,O.T=x}}function ah(e,t,i,r){if(Na){var x=lh(r);if(x===null)Wc(e,t,r,qa,i),y_(e,r);else if(b1(x,e,t,i,r))r.stopPropagation();else if(y_(e,r),t&4&&-1<w1.indexOf(e)){for(;x!==null;){var K=ai(x);if(K!==null)switch(K.tag){case 3:if(K=K.stateNode,K.current.memoizedState.isDehydrated){var ae=it(K.pendingLanes);if(ae!==0){var ge=K;for(ge.pendingLanes|=2,ge.entangledLanes|=2;ae;){var be=1<<31-me(ae);ge.entanglements[1]|=be,ae&=~be}Mn(K),(lt&6)===0&&(ya=L()+500,Yr(0))}}break;case 13:ge=Ss(K,2),ge!==null&&fn(ge,K,2),ma(),oh(K,2)}if(K=lh(r),K===null&&Wc(e,t,r,qa,i),K===x)break;x=K}x!==null&&r.stopPropagation()}else Wc(e,t,r,null,i)}}function lh(e){return e=Hi(e),ch(e)}var qa=null;function ch(e){if(qa=null,e=oi(e),e!==null){var t=y(e);if(t===null)e=null;else{var i=t.tag;if(i===13){if(e=h(t),e!==null)return e;e=null}else if(i===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return qa=e,null}function p_(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(V()){case te:return 2;case de:return 8;case C:case ee:return 32;case fe:return 268435456;default:return 32}default:return 32}}var hh=!1,Li=null,Ti=null,Di=null,to=new Map,no=new Map,Bi=[],w1="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function y_(e,t){switch(e){case"focusin":case"focusout":Li=null;break;case"dragenter":case"dragleave":Ti=null;break;case"mouseover":case"mouseout":Di=null;break;case"pointerover":case"pointerout":to.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":no.delete(t.pointerId)}}function io(e,t,i,r,x,K){return e===null||e.nativeEvent!==K?(e={blockedOn:t,domEventName:i,eventSystemFlags:r,nativeEvent:K,targetContainers:[x]},t!==null&&(t=ai(t),t!==null&&g_(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,x!==null&&t.indexOf(x)===-1&&t.push(x),e)}function b1(e,t,i,r,x){switch(t){case"focusin":return Li=io(Li,e,t,i,r,x),!0;case"dragenter":return Ti=io(Ti,e,t,i,r,x),!0;case"mouseover":return Di=io(Di,e,t,i,r,x),!0;case"pointerover":var K=x.pointerId;return to.set(K,io(to.get(K)||null,e,t,i,r,x)),!0;case"gotpointercapture":return K=x.pointerId,no.set(K,io(no.get(K)||null,e,t,i,r,x)),!0}return!1}function __(e){var t=oi(e.target);if(t!==null){var i=y(t);if(i!==null){if(t=i.tag,t===13){if(t=h(i),t!==null){e.blockedOn=t,xo(e.priority,function(){if(i.tag===13){var r=dn();r=rr(r);var x=Ss(i,r);x!==null&&fn(x,i,r),oh(i,r)}});return}}else if(t===3&&i.stateNode.current.memoizedState.isDehydrated){e.blockedOn=i.tag===3?i.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Ca(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var i=lh(e.nativeEvent);if(i===null){i=e.nativeEvent;var r=new i.constructor(i.type,i);gn=r,i.target.dispatchEvent(r),gn=null}else return t=ai(i),t!==null&&g_(t),e.blockedOn=i,!1;t.shift()}return!0}function m_(e,t,i){Ca(e)&&i.delete(t)}function v1(){hh=!1,Li!==null&&Ca(Li)&&(Li=null),Ti!==null&&Ca(Ti)&&(Ti=null),Di!==null&&Ca(Di)&&(Di=null),to.forEach(m_),no.forEach(m_)}function Ma(e,t){e.blockedOn===t&&(e.blockedOn=null,hh||(hh=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,v1)))}var Ua=null;function w_(e){Ua!==e&&(Ua=e,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Ua===e&&(Ua=null);for(var t=0;t<e.length;t+=3){var i=e[t],r=e[t+1],x=e[t+2];if(typeof r!="function"){if(ch(r||i)===null)continue;break}var K=ai(i);K!==null&&(e.splice(t,3),t-=3,cc(K,{pending:!0,data:x,method:i.method,action:r},r,x))}}))}function so(e){function t(be){return Ma(be,e)}Li!==null&&Ma(Li,e),Ti!==null&&Ma(Ti,e),Di!==null&&Ma(Di,e),to.forEach(t),no.forEach(t);for(var i=0;i<Bi.length;i++){var r=Bi[i];r.blockedOn===e&&(r.blockedOn=null)}for(;0<Bi.length&&(i=Bi[0],i.blockedOn===null);)__(i),i.blockedOn===null&&Bi.shift();if(i=(e.ownerDocument||e).$$reactFormReplay,i!=null)for(r=0;r<i.length;r+=3){var x=i[r],K=i[r+1],ae=x[zt]||null;if(typeof K=="function")ae||w_(i);else if(ae){var ge=null;if(K&&K.hasAttribute("formAction")){if(x=K,ae=K[zt]||null)ge=ae.formAction;else if(ch(x)!==null)continue}else ge=ae.action;typeof ge=="function"?i[r+1]=ge:(i.splice(r,3),r-=3),w_(i)}}}function uh(e){this._internalRoot=e}Oa.prototype.render=uh.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(l(409));var i=t.current,r=dn();d_(i,r,e,t,null,null)},Oa.prototype.unmount=uh.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;d_(e.current,2,null,e,null,null),ma(),t[ri]=null}};function Oa(e){this._internalRoot=e}Oa.prototype.unstable_scheduleHydration=function(e){if(e){var t=So();e={blockedOn:null,target:e,priority:t};for(var i=0;i<Bi.length&&t!==0&&t<Bi[i].priority;i++);Bi.splice(i,0,e),i===0&&__(e)}};var b_=a.version;if(b_!=="19.1.0")throw Error(l(527,b_,"19.1.0"));P.findDOMNode=function(e){var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(l(188)):(e=Object.keys(e).join(","),Error(l(268,e)));return e=c(t),e=e!==null?s(e):null,e=e===null?null:e.stateNode,e};var k1={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:O,reconcilerVersion:"19.1.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Pa=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Pa.isDisabled&&Pa.supportsFiber)try{F=Pa.inject(k1),ne=Pa}catch{}}return fo.createRoot=function(e,t){if(!g(e))throw Error(l(299));var i=!1,r="",x=Up,K=Op,ae=Pp,ge=null;return t!=null&&(t.unstable_strictMode===!0&&(i=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onUncaughtError!==void 0&&(x=t.onUncaughtError),t.onCaughtError!==void 0&&(K=t.onCaughtError),t.onRecoverableError!==void 0&&(ae=t.onRecoverableError),t.unstable_transitionCallbacks!==void 0&&(ge=t.unstable_transitionCallbacks)),t=h_(e,1,!1,null,null,i,r,x,K,ae,ge,null),e[ri]=t.current,Yc(e),new uh(t)},fo.hydrateRoot=function(e,t,i){if(!g(e))throw Error(l(299));var r=!1,x="",K=Up,ae=Op,ge=Pp,be=null,Re=null;return i!=null&&(i.unstable_strictMode===!0&&(r=!0),i.identifierPrefix!==void 0&&(x=i.identifierPrefix),i.onUncaughtError!==void 0&&(K=i.onUncaughtError),i.onCaughtError!==void 0&&(ae=i.onCaughtError),i.onRecoverableError!==void 0&&(ge=i.onRecoverableError),i.unstable_transitionCallbacks!==void 0&&(be=i.unstable_transitionCallbacks),i.formState!==void 0&&(Re=i.formState)),t=h_(e,1,!0,t,i??null,r,x,K,ae,ge,be,Re),t.context=u_(null),i=t.current,r=dn(),r=rr(r),x=gi(r),x.callback=null,pi(i,x,r),i=r,t.current.lanes=i,Oi(t,i),Mn(t),e[ri]=t.current,Yc(e),new Oa(t)},fo.version="19.1.0",fo}var xv;function hE(){if(xv)return Nf.exports;xv=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(a){console.error(a)}}return n(),Nf.exports=cE(),Nf.exports}var uE=hE();const dE=ti(uE),k0=rt.createContext({networks:new Map,activeNetwork:null,isConnected:!1,peers:[],stats:null,setActiveNetwork:()=>{},refreshNetworks:()=>{},createNetwork:()=>{},joinNetwork:()=>{},leaveNetwork:()=>{}}),ir=()=>{const n=rt.useContext(k0);if(!n)throw new Error("useNetwork must be used within a NetworkProvider");return n},fE=({children:n})=>{const[a,p]=rt.useState(new Map),[l,g]=rt.useState(null),[y,h]=rt.useState(!1),[o,c]=rt.useState([]),[s,u]=rt.useState(null);rt.useEffect(()=>{if(!window.hyperShare)return;const M=()=>{p(new Map(window.hyperShare.networks)),window.hyperShare.activeNetwork&&(g(window.hyperShare.activeNetwork),h(!!window.hyperShare.activeNetwork.swarm?.connections?.size))},z=v=>{console.log("Role update received in React context:",v.detail),l&&v.detail.role&&g(w=>({...w,role:v.detail.role,adminKeypair:window.hyperShare.activeNetwork?.adminKeypair}))};window.addEventListener("role-updated",z),M();const j=setInterval(M,2e3);return()=>{window.removeEventListener("role-updated",z),clearInterval(j)}},[l]),rt.useEffect(()=>{if(!window.hyperShare||!l)return;const M=async()=>{try{const j=await window.hyperShare.getNetworkStats();u(j),j.swarm?.connections&&(c(Array.from(j.swarm.connections.values())),h(j.swarm.connections.size>0))}catch(j){console.error("Failed to update stats:",j)}};M();const z=setInterval(M,2e3);return()=>clearInterval(z)},[l]);const B={networks:a,activeNetwork:l,isConnected:y,peers:o,stats:s,setActiveNetwork:async M=>{const z=a.get(M);z&&(window.hyperShare.activeNetwork=z,g(z))},refreshNetworks:()=>{window.hyperShare&&p(new Map(window.hyperShare.networks))},createNetwork:async(M,z)=>{if(!window.hyperShare)throw new Error("HyperShare not initialized");const j=await window.hyperShare.createNetwork(M,z);return p(new Map(window.hyperShare.networks)),g(j.network),j},joinNetwork:async M=>{if(!window.hyperShare)throw new Error("HyperShare not initialized");const z=await window.hyperShare.joinNetwork(M);return p(new Map(window.hyperShare.networks)),g(z),z},leaveNetwork:async M=>{if(!window.hyperShare)throw new Error("HyperShare not initialized");const z=await window.hyperShare.leaveNetwork(M);return p(new Map(window.hyperShare.networks)),g(z),z}};return ke.jsx(k0.Provider,{value:B,children:n})},S0=rt.createContext({modalState:{},openModal:()=>{},closeModal:()=>{},closeAllModals:()=>{},loading:{},setLoading:()=>{},currentView:"browse",setCurrentView:()=>{},fileBrowserState:{viewMode:"list",sortBy:"name",sortOrder:"asc",searchTerm:"",currentPath:"/",currentDriveKey:"",currentDriveName:""},updateFileBrowserState:()=>{},uploadProgress:{},setUploadProgress:()=>{}}),sr=()=>{const n=rt.useContext(S0);if(!n)throw new Error("useUI must be used within a UIProvider");return n},gE=({children:n})=>{const[a,p]=rt.useState({}),[l,g]=rt.useState({}),[y,h]=rt.useState("browse"),[o,c]=rt.useState({viewMode:"list",sortBy:"name",sortOrder:"asc",searchTerm:"",currentPath:"/",currentDriveKey:"",currentDriveName:""}),[s,u]=rt.useState({}),B={modalState:a,openModal:(M,z={})=>{p(j=>({...j,[M]:{isOpen:!0,data:z}}))},closeModal:M=>{p(z=>({...z,[M]:{isOpen:!1,data:{}}}))},closeAllModals:()=>{p({})},loading:l,setLoading:(M,z)=>{g(j=>({...j,[M]:z}))},currentView:y,setCurrentView:h,fileBrowserState:o,updateFileBrowserState:M=>{c(z=>({...z,...M}))},uploadProgress:s,setUploadProgress:u};return ke.jsx(S0.Provider,{value:B,children:n})},pE=()=>ke.jsxs("div",{className:"title-bar",children:[ke.jsx("div",{className:"title-bar-button close",id:"close-btn"}),ke.jsx("div",{className:"title-bar-button minimize",id:"minimize-btn"}),ke.jsx("div",{className:"title-bar-button maximize",id:"maximize-btn"})]}),yE=()=>{const{openModal:n}=sr(),a=()=>{n("create-network")},p=()=>{n("join-network")};return ke.jsx("div",{id:"welcome-screen",style:{display:"flex"},children:ke.jsxs("div",{className:"welcome-container",children:[ke.jsx("div",{className:"logo",children:"⚡ HyperShare"}),ke.jsx("p",{className:"tagline",children:"Decentralized file sharing networks with curated content"}),ke.jsxs("div",{className:"welcome-options",children:[ke.jsxs("div",{className:"option-card",onClick:a,children:[ke.jsx("h3",{children:"Create Network"}),ke.jsx("p",{children:"Start a new file sharing network as the founder admin"})]}),ke.jsxs("div",{className:"option-card",onClick:p,children:[ke.jsx("h3",{children:"Join Network"}),ke.jsx("p",{children:"Connect to an existing network with an invite code"})]})]})]})})},_E=()=>{const{networks:n,activeNetwork:a,setActiveNetwork:p}=ir(),{openModal:l}=sr(),g=o=>{p(o)},y=()=>{l("welcome-screen")},h=Array.from(n.values());return ke.jsxs("div",{className:"networks-bar",children:[ke.jsx("div",{id:"network-list",children:h.map(o=>ke.jsxs("div",{className:`network-icon ${a?.key===o.key?"active":""}`,onClick:()=>g(o.key),title:o.name,children:[o.name.substring(0,2).toUpperCase(),a?.key===o.key&&ke.jsx("div",{className:"peer-indicator"})]},o.key))}),ke.jsx("div",{className:"network-divider"}),ke.jsx("div",{className:"network-icon add",onClick:y,children:"+"})]})},mE=()=>{const{activeNetwork:n,stats:a,leaveNetwork:p}=ir(),{currentView:l,setCurrentView:g,openModal:y}=sr(),h=n?.role==="admin",o=u=>{g(u)},c=()=>{y("network-info")},s=()=>{n&&confirm(`Are you sure you want to leave the network "${n.name}"? This cannot be undone.`)&&p(n.key)};return ke.jsxs("div",{className:"nav-sidebar",children:[ke.jsxs("div",{className:"network-info",children:[ke.jsx("div",{className:"network-name",id:"current-network-name",children:n?.name||"Loading..."}),ke.jsx("span",{className:`network-role ${n?.role||"reader"}`,id:"user-role",children:(n?.role||"Reader").toUpperCase()}),ke.jsx("button",{className:"btn btn-secondary",onClick:c,style:{marginTop:"10px",width:"100%"},children:"📋 Network Info"}),ke.jsx("button",{className:"btn btn-secondary",onClick:s,style:{marginTop:"5px",width:"100%"},children:"Leave Network"})]}),ke.jsxs("div",{className:"nav-section",children:[ke.jsx("h4",{children:"Browse"}),ke.jsxs("div",{className:`nav-item ${l==="browse"?"active":""}`,onClick:()=>o("browse"),children:[ke.jsx("span",{children:"🌐"})," All Drives"]}),ke.jsxs("div",{className:`nav-item ${l==="categories"?"active":""}`,onClick:()=>o("categories"),children:[ke.jsx("span",{children:"📁"})," Categories"]}),ke.jsxs("div",{className:`nav-item ${l==="verified"?"active":""}`,onClick:()=>o("verified"),children:[ke.jsx("span",{children:"✓"})," Verified Only"]})]}),ke.jsxs("div",{className:"nav-section",children:[ke.jsx("h4",{children:"Personal"}),ke.jsxs("div",{className:`nav-item ${l==="downloads"?"active":""}`,onClick:()=>o("downloads"),children:[ke.jsx("span",{children:"⬇️"})," Downloads"]}),ke.jsxs("div",{className:`nav-item ${l==="my-drives"?"active":""}`,onClick:()=>o("my-drives"),children:[ke.jsx("span",{children:"💾"})," My Drives"]})]}),h&&ke.jsxs("div",{className:"nav-section",id:"admin-section",children:[ke.jsx("h4",{children:"Admin"}),ke.jsxs("div",{className:`nav-item ${l==="publish"?"active":""}`,onClick:()=>o("publish"),children:[ke.jsx("span",{children:"📤"})," Publish Drive"]}),ke.jsxs("div",{className:`nav-item ${l==="manage-admins"?"active":""}`,onClick:()=>o("manage-admins"),children:[ke.jsx("span",{children:"👥"})," Manage Admins"]})]}),ke.jsxs("div",{className:"nav-section",children:[ke.jsx("h4",{children:"Network Stats"}),ke.jsxs("div",{className:"stats-grid",children:[ke.jsxs("div",{className:"stat-item",children:[ke.jsx("div",{className:"stat-label",children:"Peers"}),ke.jsx("div",{className:"stat-value",id:"peer-count",children:a?.peers||0})]}),ke.jsxs("div",{className:"stat-item",children:[ke.jsx("div",{className:"stat-label",children:"Drives"}),ke.jsx("div",{className:"stat-value",id:"drive-count",children:a?.drives||0})]}),ke.jsxs("div",{className:"stat-item",children:[ke.jsx("div",{className:"stat-label",children:"Upload"}),ke.jsx("div",{className:"stat-value",id:"upload-speed",children:a?.swarm?.uploadSpeed?Ev(a.swarm.uploadSpeed):"0 B/s"})]}),ke.jsxs("div",{className:"stat-item",children:[ke.jsx("div",{className:"stat-label",children:"Download"}),ke.jsx("div",{className:"stat-value",id:"download-speed",children:a?.swarm?.downloadSpeed?Ev(a.swarm.downloadSpeed):"0 B/s"})]})]})]})]})},Ev=n=>{if(n===0)return"0 B/s";const a=1024,p=["B/s","KB/s","MB/s","GB/s","TB/s"],l=Math.floor(Math.log(n)/Math.log(a));return parseFloat((n/Math.pow(a,l)).toFixed(2))+" "+p[l]},wE=()=>{const{stats:n}=ir(),[a,p]=rt.useState(""),l=async y=>{if(y.key==="Enter"&&a.trim()&&window.hyperShare){const h=await window.hyperShare.searchFiles(a.trim());console.log("Search results:",h)}},g=()=>{alert("Filters coming soon!")};return ke.jsxs("div",{className:"top-bar",children:[ke.jsxs("div",{className:"search-bar",children:[ke.jsx("span",{className:"search-icon",children:"🔍"}),ke.jsx("input",{type:"text",className:"search-input",placeholder:"Search files across the network...",value:a,onChange:y=>p(y.target.value),onKeyPress:l})]}),ke.jsxs("button",{className:"filter-button",onClick:g,children:[ke.jsx("span",{children:"⚙️"})," Filters"]}),ke.jsxs("div",{className:"stats-bar",children:[ke.jsxs("div",{className:"stat",children:[ke.jsx("div",{className:"stat-value",children:n?.peers||0}),ke.jsx("div",{className:"stat-label",children:"Peers"})]}),ke.jsxs("div",{className:"stat",children:[ke.jsx("div",{className:"stat-value",children:n?.drives||0}),ke.jsx("div",{className:"stat-label",children:"Drives"})]})]})]})},Av=()=>{const{activeNetwork:n}=ir(),[a,p]=rt.useState([]),[l,g]=rt.useState(!0),[y,h]=rt.useState(null);rt.useEffect(()=>{o()},[n]);const o=async()=>{if(!(!window.hyperShare||!n))try{g(!0),h(null);const b=await window.hyperShare.browseDrives();p(b)}catch(b){console.error("Error loading drives:",b),h(b.message)}finally{g(!1)}},c=()=>{o()},s=b=>{if(b===0)return"0 B";const _=1024,B=["B","KB","MB","GB","TB"],M=Math.floor(Math.log(b)/Math.log(_));return parseFloat((b/Math.pow(_,M)).toFixed(2))+" "+B[M]},u=b=>{const _=n?.role==="admin",B=_&&b.owner?.id===n?.autobase?.local?.key?.toString("hex");return ke.jsxs("div",{className:"drive-card",onClick:()=>f(b.key,b.name),children:[ke.jsx("div",{className:"drive-header",children:ke.jsxs("div",{className:"drive-title",children:[b.name||"Unnamed Drive",b.verified&&ke.jsx("span",{className:"verified-badge",children:"VERIFIED"})]})}),ke.jsxs("div",{className:"drive-owner",children:["by ",b.owner?.name||"Unknown"]}),ke.jsx("div",{className:"drive-description",children:b.description||"No description"}),ke.jsxs("div",{className:"drive-stats",children:[ke.jsx("span",{className:"drive-stat",children:ke.jsx("strong",{children:s(b.stats?.totalSize||0)})}),ke.jsxs("span",{className:"drive-stat",children:[ke.jsx("strong",{children:b.stats?.fileCount||0})," files"]})]}),ke.jsx("div",{className:"drive-tags",children:(b.tags||[]).map(M=>ke.jsx("span",{className:"tag",children:M},M))}),ke.jsxs("div",{className:"drive-actions",children:[ke.jsx("button",{className:"btn",onClick:M=>{M.stopPropagation(),f(b.key,b.name)},children:"Browse Files"}),_&&!b.verified&&ke.jsx("button",{className:"btn btn-secondary",onClick:M=>{M.stopPropagation(),m(b.key)},children:"Verify"}),B&&ke.jsx("button",{className:"btn btn-danger",onClick:M=>{M.stopPropagation(),E(b.key)},children:"Unpublish"})]})]},b.key)},f=(b,_)=>{console.log("Browse drive:",b,_)},m=async b=>{try{await window.hyperShare.verifyDrive(b),alert("Drive verified!"),o()}catch(_){alert("Failed to verify drive: "+_.message)}},E=async b=>{if(confirm("Are you sure you want to unpublish this drive? This will remove it from the network index for all users."))try{await window.hyperShare.unpublishDrive(b),alert("Unpublish event sent! The drive will be removed shortly."),setTimeout(()=>o(),1e3)}catch(_){alert("Failed to unpublish drive: "+_.message)}};return l?ke.jsxs("div",{children:[ke.jsxs("div",{className:"view-header",children:[ke.jsx("h1",{className:"view-title",children:"Browse Drives"}),ke.jsx("p",{className:"view-description",children:"Explore all published drives in the network"})]}),ke.jsxs("div",{className:"loading",children:[ke.jsx("div",{className:"spinner"}),ke.jsx("p",{children:"Loading drives..."})]})]}):y?ke.jsxs("div",{children:[ke.jsxs("div",{className:"view-header",children:[ke.jsx("h1",{className:"view-title",children:"Browse Drives"}),ke.jsx("p",{className:"view-description",children:"Explore all published drives in the network"})]}),ke.jsxs("div",{className:"error-state",children:[ke.jsxs("p",{style:{color:"var(--danger)"},children:["Error loading drives: ",y]}),ke.jsx("button",{className:"btn",onClick:c,children:"Try Again"})]})]}):ke.jsxs("div",{children:[ke.jsxs("div",{className:"view-header",children:[ke.jsx("h1",{className:"view-title",children:"Browse Drives"}),ke.jsx("p",{className:"view-description",children:"Explore all published drives in the network"}),ke.jsx("button",{className:"btn btn-secondary",onClick:c,style:{marginTop:"10px"},children:"🔄 Refresh"})]}),ke.jsx("div",{className:"drives-grid",children:a.length===0?ke.jsx("div",{className:"empty-state",children:ke.jsxs("div",{className:"loading-content",children:[ke.jsx("div",{className:"spinner",style:{marginBottom:"16px"}}),ke.jsx("h3",{children:"Discovering drives..."}),ke.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"16px"},children:"Connecting to peers and synchronizing the network database. This may take a few moments for new networks."}),ke.jsx("button",{className:"btn btn-secondary",onClick:c,children:"Check Again"})]})}):a.map(b=>u(b))})]})},bE=()=>{const{activeNetwork:n}=ir(),{setCurrentView:a}=sr(),[p,l]=rt.useState(""),[g,y]=rt.useState(""),[h,o]=rt.useState(""),c=n?.role==="admin",s=()=>{alert("File upload modal coming soon!")},u=async()=>{if(!p.trim()){alert("Please enter a drive name");return}if(!window.hyperShare){alert("HyperShare not initialized");return}try{const f=h.split(",").map(m=>m.trim()).filter(m=>m);await window.hyperShare.publishDrive({name:p,description:g,tags:f,categories:[]}),alert("Drive published successfully!"),a("browse")}catch(f){alert("Failed to publish drive: "+f.message)}};return c?ke.jsxs("div",{children:[ke.jsxs("div",{className:"view-header",children:[ke.jsx("h1",{className:"view-title",children:"Publish Drive"}),ke.jsx("p",{className:"view-description",children:"Share your files with the network"})]}),ke.jsxs("div",{className:"form-group",children:[ke.jsx("label",{className:"form-label",children:"Drive Name"}),ke.jsx("input",{type:"text",className:"form-input",value:p,onChange:f=>l(f.target.value),placeholder:"My Awesome Collection"})]}),ke.jsxs("div",{className:"form-group",children:[ke.jsx("label",{className:"form-label",children:"Description"}),ke.jsx("textarea",{className:"form-textarea",value:g,onChange:f=>y(f.target.value),placeholder:"Describe your collection..."})]}),ke.jsxs("div",{className:"form-group",children:[ke.jsx("label",{className:"form-label",children:"Tags (comma separated)"}),ke.jsx("input",{type:"text",className:"form-input",value:h,onChange:f=>o(f.target.value),placeholder:"movies, 1080p, action"})]}),ke.jsx("button",{className:"btn",onClick:s,children:"Upload Files"}),ke.jsx("div",{id:"file-list",style:{marginTop:"20px"}}),ke.jsx("button",{className:"btn",onClick:u,style:{marginTop:"20px"},children:"Publish Drive"})]}):ke.jsxs("div",{children:[ke.jsxs("div",{className:"view-header",children:[ke.jsx("h1",{className:"view-title",children:"Publish Drive"}),ke.jsx("p",{className:"view-description",children:"Share your files with the network"})]}),ke.jsx("div",{className:"error-state",children:ke.jsx("p",{children:"You need admin permissions to publish drives."})})]})},vE=()=>{const{activeNetwork:n}=ir(),{setCurrentView:a}=sr(),[p,l]=rt.useState([]),[g,y]=rt.useState(!0),h=n?.role==="admin";rt.useEffect(()=>{o()},[n]);const o=async()=>{if(!window.hyperShare||!h){y(!1);return}try{y(!0);const m=await window.hyperShare.getMyDrives();l(m)}catch(m){console.error("Error loading my drives:",m)}finally{y(!1)}},c=m=>{if(m===0)return"0 B";const E=1024,b=["B","KB","MB","GB","TB"],_=Math.floor(Math.log(m)/Math.log(E));return parseFloat((m/Math.pow(E,_)).toFixed(2))+" "+b[_]},s=async m=>{if(!p.find(b=>b.key===m)){alert("Drive not found!");return}alert("Drive information will be pre-filled in the publish form."),a("publish")},u=async m=>{if(confirm("Are you sure you want to unpublish this drive? It will be removed for all users on the network."))try{await window.hyperShare.unpublishDrive(m),alert("Drive unpublished successfully!"),o()}catch(E){alert("Failed to unpublish drive: "+E.message)}},f=m=>ke.jsxs("div",{className:"drive-card",children:[ke.jsx("div",{className:"drive-header",children:ke.jsxs("div",{className:"drive-title",children:[m.name||"Unnamed Drive",m.verified&&ke.jsx("span",{className:"verified-badge",children:"VERIFIED"})]})}),ke.jsx("div",{className:"drive-description",children:m.description||"No description"}),ke.jsxs("div",{className:"drive-stats",children:[ke.jsx("span",{className:"drive-stat",children:ke.jsx("strong",{children:c(m.stats?.totalSize||0)})}),ke.jsxs("span",{className:"drive-stat",children:[ke.jsx("strong",{children:m.stats?.fileCount||0})," files"]})]}),ke.jsx("div",{className:"drive-tags",children:(m.tags||[]).map(E=>ke.jsx("span",{className:"tag",children:E},E))}),ke.jsxs("div",{className:"drive-actions",children:[ke.jsx("button",{className:"btn",onClick:()=>s(m.key),children:"Republish"}),ke.jsx("button",{className:"btn btn-danger",onClick:()=>u(m.key),children:"Unpublish"})]})]},m.key);return h?g?ke.jsxs("div",{children:[ke.jsxs("div",{className:"view-header",children:[ke.jsx("h1",{className:"view-title",children:"My Published Drives"}),ke.jsx("p",{className:"view-description",children:"Manage the drives you've shared with the network"})]}),ke.jsxs("div",{className:"loading",children:[ke.jsx("div",{className:"spinner"}),ke.jsx("p",{children:"Loading your drives..."})]})]}):ke.jsxs("div",{children:[ke.jsxs("div",{className:"view-header",children:[ke.jsx("h1",{className:"view-title",children:"My Published Drives"}),ke.jsx("p",{className:"view-description",children:"Manage the drives you've shared with the network"})]}),ke.jsx("div",{className:"drives-grid",children:p.length===0?ke.jsx("p",{style:{color:"var(--text-secondary)"},children:"You haven't published any drives yet."}):p.map(m=>f(m))})]}):ke.jsxs("div",{children:[ke.jsxs("div",{className:"view-header",children:[ke.jsx("h1",{className:"view-title",children:"My Published Drives"}),ke.jsx("p",{className:"view-description",children:"Manage the drives you've shared with the network"})]}),ke.jsx("p",{children:"You do not have any published drives."})]})},kE=()=>{const{currentView:n}=sr(),a=()=>{switch(n){case"browse":return ke.jsx(Av,{});case"publish":return ke.jsx(bE,{});case"my-drives":return ke.jsx(vE,{});case"categories":case"verified":case"downloads":case"manage-admins":return ke.jsxs("div",{className:"loading",children:[ke.jsx("div",{className:"spinner"}),ke.jsx("p",{children:"View coming soon..."})]});default:return ke.jsx(Av,{})}};return ke.jsx("div",{className:"content-area",id:"content-area",children:a()})},SE=()=>ke.jsxs("div",{className:"main-content",children:[ke.jsx(wE,{}),ke.jsx(kE,{})]}),xE=()=>ke.jsxs("div",{className:"app-layout",children:[ke.jsx(_E,{}),ke.jsx(mE,{}),ke.jsx(SE,{})]}),EE=()=>ke.jsx("div",{id:"main-app",style:{display:"block"},children:ke.jsx(xE,{})}),AE=()=>{rt.useEffect(()=>{if(typeof Pear<"u"){Pear.teardown(()=>{window.hyperShare&&console.log("Cleaning up HyperShare connections...")});const n=()=>{const a=Pear.Window.self,p=document.getElementById("close-btn"),l=document.getElementById("minimize-btn"),g=document.getElementById("maximize-btn");p&&p.addEventListener("click",()=>a.close()),l&&l.addEventListener("click",()=>a.minimize()),g&&g.addEventListener("click",()=>a.maximize())};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",n):n()}},[])};function RE(){const[n,a]=rt.useState(!1),[p,l]=rt.useState(!1);return AE(),rt.useEffect(()=>{const g=setInterval(async()=>{if(window.hyperShare&&window.hyperShare.ready){clearInterval(g),a(!0);const y=Array.from(window.hyperShare.networks.values());l(y.length>0)}},100);return()=>clearInterval(g)},[]),n?ke.jsx(fE,{children:ke.jsx(gE,{children:ke.jsxs("div",{className:"app",children:[ke.jsx(pE,{}),p?ke.jsx(EE,{}):ke.jsx(yE,{})]})})}):ke.jsxs("div",{className:"loading",children:[ke.jsx("div",{className:"spinner"}),ke.jsx("p",{children:"Initializing HyperShare..."})]})}typeof globalThis>"u"&&(window.global=window);dE.createRoot(document.getElementById("root")).render(ke.jsx(sE.StrictMode,{children:ke.jsx(RE,{})}));
